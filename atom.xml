<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>远芳</title>
  
  <subtitle>算法小亭</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuanfang.tech/"/>
  <updated>2019-07-31T07:06:55.080Z</updated>
  <id>https://yuanfang.tech/</id>
  
  <author>
    <name>Mengfei Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>poj1511</title>
    <link href="https://yuanfang.tech/2019/07/31/poj1511.html"/>
    <id>https://yuanfang.tech/2019/07/31/poj1511.html</id>
    <published>2019-07-31T06:48:55.000Z</published>
    <updated>2019-07-31T07:06:55.080Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><br>poj1511，双向最短路，数据较大，需要SPFA或dijstra堆优化<p></p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=1511" target="_blank" rel="noopener">http://poj.org/problem?id=1511</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>T组数据。</p><p>每组第一行n,m代表有n个点，m条单向边</p><p>之后m行告诉你每条边a到b的距离w。</p><p>求1到其余各点的最短路径和+其余各点到1的最短路径和。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>数据很大，最后结果需要longlong存放。</p><p>边很多，需要用起点边索引。</p><p>memset不能初始化dis为inf。通常只能初始化为0或1。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>SPFA:1844ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1e10+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> first[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> k,n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[k].v=v;</span><br><span class="line">edge[k].w=w;</span><br><span class="line">edge[k].next=first[u];</span><br><span class="line">first[u]=k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=<span class="literal">true</span>;</span><br><span class="line">dis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[u]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(i=first[u];i;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">int</span> w=edge[i].w;</span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[u]+w)</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]+w;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])</span><br><span class="line">&#123;</span><br><span class="line">q.push(v);</span><br><span class="line">vis[v]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=ans+dis[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line"><span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">dis[i]=inf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line">adde(a[i],b[i],c[i]);</span><br><span class="line">&#125;</span><br><span class="line">ans=ans+spfa(<span class="number">1</span>);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">adde(b[i],a[i],c[i]);</span><br><span class="line">ans=ans+spfa(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;br&gt;poj1511，双向最短路，数据较大，需要SPFA或dijstra堆优化&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="poj" scheme="https://yuanfang.tech/categories/poj/"/>
    
    
      <category term="dijstra" scheme="https://yuanfang.tech/tags/dijstra/"/>
    
      <category term="poj" scheme="https://yuanfang.tech/tags/poj/"/>
    
      <category term="kuangbin" scheme="https://yuanfang.tech/tags/kuangbin/"/>
    
      <category term="spfa" scheme="https://yuanfang.tech/tags/spfa/"/>
    
  </entry>
  
  <entry>
    <title>spfa</title>
    <link href="https://yuanfang.tech/2019/07/30/spfa.html"/>
    <id>https://yuanfang.tech/2019/07/30/spfa.html</id>
    <published>2019-07-30T09:20:03.000Z</published>
    <updated>2019-07-31T07:02:31.440Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><p></p><h2 id="SPFA算法（Shortest-Path-Faster-Algorithm）"><a href="#SPFA算法（Shortest-Path-Faster-Algorithm）" class="headerlink" title="SPFA算法（Shortest Path Faster Algorithm）"></a>SPFA算法（Shortest Path Faster Algorithm）</h2><p>复杂度：O（KE）</p><p>k为所有顶点进队的平均次数，可以证明k一般小于等于2。</p><p>计算单源最短路，图可带负权。玄学复杂度，比普通Dijstra和Floyd要低。</p><p>可以判断是否有负环。</p><a id="more"></a><p>例：求a点到其余各点的最短路径。</p><p><img src="spfa\1_1.png" alt="img"></p><p>首先建立起始点a到其余各点的最短路径表格dis[]</p><p><img src="spfa\1.jpg" alt="img"></p><p>首先源点a入队，当队列非空时：队首元素（a）出队，对以a为起始点的所有边的终点依次进行松弛操作（此处有b,c,d三个点），此时路径表格状态为：</p><p><img src="spfa\2.jpg" alt="img"></p><p>在松弛时三个点的最短路径估值变小了，而这些点队列中都没有出现，这些点需要入队，此时，队列中新入队了三个结点b,c,d</p><p>队首元素b点出队，对以b为起始点的所有边的终点依次进行松弛操作（此处只有e点），此时路径表格状态为：</p><p><img src="spfa\3.jpg" alt="img"></p><p>在最短路径表中，e的最短路径估值也变小了，e在队列中不存在，因此e也要入队，此时队列中的元素为c，d，e</p><p>队首元素c点出队，对以c为起始点的所有边的终点依次进行松弛操作（此处有e,f两个点），此时路径表格状态为：</p><p><img src="spfa\4.jpg" alt="img"></p><p>在最短路径表中，e，f的最短路径估值变小了，e在队列中存在，f不存在。因此e不用入队了，f要入队，此时队列中的元素为d，e，f</p><p> 队首元素d点出队，对以d为起始点的所有边的终点依次进行松弛操作（此处只有g这个点），此时路径表格状态为：</p><p><img src="spfa\5.jpg" alt="img"></p><p>在最短路径表中，g的最短路径估值没有变小（松弛不成功），没有新结点入队，队列中元素为f，g</p><p>队首元素f点出队，对以f为起始点的所有边的终点依次进行松弛操作（此处有d，e，g三个点），此时路径表格状态为：</p><p><img src="spfa\6.jpg" alt="img"></p><p>在最短路径表中，e，g的最短路径估值又变小，队列中无e点，e入队，队列中存在g这个点，g不用入队，此时队列中元素为g，e</p><p>队首元素g点出队，对以g为起始点的所有边的终点依次进行松弛操作（此处只有b点），此时路径表格状态为：</p><p><img src="spfa\7.jpg" alt="img"></p><p>在最短路径表中，b的最短路径估值又变小，队列中无b点，b入队，此时队列中元素为e，b队首元素e点出队，对以e为起始点的所有边的终点依次进行松弛操作（此处只有g这个点），此时路径表格状态为：</p><p><img src="spfa\8.jpg" alt="img"></p><p>在最短路径表中，g的最短路径估值没变化（松弛不成功），此时队列中元素为b</p><p>队首元素b点出队，对以b为起始点的所有边的终点依次进行松弛操作（此处只有e这个点），此时路径表格状态为：</p><p><img src="spfa\9.jpg" alt="img"></p><p>在最短路径表中，e的最短路径估值没变化（松弛不成功），此时队列为空了。算法结束。</p><p>最终dis[]即为a到各点最短路。</p><p>若某个点进队了n次即图存在负环。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、创建一个队列，将源点放入。</p><p>2、每次从队列中取出一个点X，遍历点X的所有与X相通的节点Y，比较dis[x]+e[x] [y]&lt;dis[y];</p><p>如果dis[x]+e[x] [y]&lt;dis[y]，则说明需要更新操作。</p><p>dis[y]=dis[x]+e[x] [y]//更新最短路径</p><p>由于Y改变了最短路径长度，所以需要以Y开始往后更新，因此如果Y不在队列中，则将Y加入队列。</p><p>（在此期间可以记录各个节点的入队次数，判断是否存在负环）</p><p>3.循环2，直到队列为空。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">q.push(x);<span class="comment">//将源点放入队列中</span></span><br><span class="line">vis[x]=<span class="literal">true</span>;<span class="comment">//vis变true</span></span><br><span class="line">dis[x]=<span class="number">0</span>;<span class="comment">//源点距离为0，其余点为inf</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())<span class="comment">//直到队列为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();<span class="comment">//取出队列第一个元素</span></span><br><span class="line">q.pop();<span class="comment">//弹出第一个元素</span></span><br><span class="line">vis[u]=<span class="literal">false</span>;<span class="comment">//第一个元素因为出队了，所以vis变false</span></span><br><span class="line"><span class="keyword">for</span>(i=first[u];i;i=edge[i].next)<span class="comment">//遍历第一个元素的所有出边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">int</span> w=edge[i].w;</span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[u]+w)<span class="comment">//判断能否通过第一个元素出边进行松弛</span></span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]+w;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])<span class="comment">//可以松弛但不在队列中，那么就放入队列，vis变true</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(v);</span><br><span class="line">vis[v]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;SPFA算法（Shortest-Path-Faster-Algorithm）&quot;&gt;&lt;a href=&quot;#SPFA算法（Shortest-Path-Faster-Algorithm）&quot; class=&quot;headerlink&quot; title=&quot;SPFA算法（Shortest Path Faster Algorithm）&quot;&gt;&lt;/a&gt;SPFA算法（Shortest Path Faster Algorithm）&lt;/h2&gt;&lt;p&gt;复杂度：O（KE）&lt;/p&gt;
&lt;p&gt;k为所有顶点进队的平均次数，可以证明k一般小于等于2。&lt;/p&gt;
&lt;p&gt;计算单源最短路，图可带负权。玄学复杂度，比普通Dijstra和Floyd要低。&lt;/p&gt;
&lt;p&gt;可以判断是否有负环。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://yuanfang.tech/categories/algorithm/"/>
    
    
      <category term="spfa" scheme="https://yuanfang.tech/tags/spfa/"/>
    
  </entry>
  
  <entry>
    <title>Topological sort</title>
    <link href="https://yuanfang.tech/2019/07/30/Topological-sort.html"/>
    <id>https://yuanfang.tech/2019/07/30/Topological-sort.html</id>
    <published>2019-07-30T06:49:54.000Z</published>
    <updated>2019-07-30T07:08:48.245Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><p></p><h2 id="拓扑排序（Topological-sort）"><a href="#拓扑排序（Topological-sort）" class="headerlink" title="拓扑排序（Topological sort）"></a>拓扑排序（Topological sort）</h2><p>拓扑排序是一个比较常用的图论算法，经常用于完成有依赖关系的任务的排序。</p><p>时间复杂度：O（N+E）</p><p>空间复杂度：O（N）</p><a id="more"></a><p>举个例子：</p><p>有人想要制作一件工具，但是这个工具不是一次就可以完成的，分很多个步骤，而且这些步骤是有顺序的，也就是说，假设B的顺序在A的后面，那么你就必须要先完成A再完成B，但是也有些步骤不分顺序，意思是你先做哪一个都是可以的。</p><p>面对这样的问题，我们可以把步骤建立成一张有向无环图，A指向B意思是A要在B前面完成，那么下面，我们就要找到一个顺序，来使答案符合题目要求。拓扑排序就是干这样的事情的。</p><p><img src="Topological-sort\20150507001759702" alt="topsort"></p><p>那么如何做呢？</p><p>只需要遍历一边所有节点，然后找出没有入度的节点，将他们放到一个队列中。</p><p>然后通过队列中的无入度的节点，弹出它，删掉这个节点的所有出边，会形成新的没有入度的节点。</p><p>再将新的没有入读的节点放入队列，以此循环。</p><p>直到队列为空。</p><p>如果拓扑排序后的序列个数k小于图的节点数n，那么图中则存在环。环的节点数即为n-k。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="comment">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;</span></span><br><span class="line"><span class="comment">//优先队列的话，会按照数值大小有顺序的输出</span></span><br><span class="line"><span class="comment">//此处为了理解，暂时就用简单队列</span></span><br><span class="line">inttopo()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(inti=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp=q.front();<span class="comment">//如果是优先队列，这里可以是top()</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;"</span>,temp);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(inti=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//遍历从temp出发的每一条边，入度--</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[temp][i])</span><br><span class="line">            &#123;</span><br><span class="line">                indegree[i]--;</span><br><span class="line">                <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;拓扑排序（Topological-sort）&quot;&gt;&lt;a href=&quot;#拓扑排序（Topological-sort）&quot; class=&quot;headerlink&quot; title=&quot;拓扑排序（Topological sort）&quot;&gt;&lt;/a&gt;拓扑排序（Topological sort）&lt;/h2&gt;&lt;p&gt;拓扑排序是一个比较常用的图论算法，经常用于完成有依赖关系的任务的排序。&lt;/p&gt;
&lt;p&gt;时间复杂度：O（N+E）&lt;/p&gt;
&lt;p&gt;空间复杂度：O（N）&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://yuanfang.tech/categories/algorithm/"/>
    
    
      <category term="topsort" scheme="https://yuanfang.tech/tags/topsort/"/>
    
  </entry>
  
  <entry>
    <title>poj2240</title>
    <link href="https://yuanfang.tech/2019/07/29/poj2240.html"/>
    <id>https://yuanfang.tech/2019/07/29/poj2240.html</id>
    <published>2019-07-29T10:35:15.000Z</published>
    <updated>2019-07-29T10:40:04.515Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><br>poj2240,bellman求正环，map使用<p></p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=2240" target="_blank" rel="noopener">http://poj.org/problem?id=2240</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>T个国家，接下来T行每个国家的名字。</p><p>再输入N，代表N个交换所。</p><p>接下来N行，输入A C B</p><p>表示A国到B国的汇率是C。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>用map解决输入问题之后做法就同poj1860</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;name;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">double</span> w;</span><br><span class="line">&#125;e[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j;</span><br><span class="line"><span class="built_in">string</span> s,u,v;</span><br><span class="line"><span class="keyword">double</span> w,dis[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> time=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> tt=t;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">name[s]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k=n;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; w &gt;&gt; v ;</span><br><span class="line">e[i].u=name[u];</span><br><span class="line">e[i].v=name[v];</span><br><span class="line">e[i].w=w;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=tt;i++)</span><br><span class="line">dis[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=tt;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[e[j].v]&lt;dis[e[j].u]*e[j].w)</span><br><span class="line">dis[e[j].v]=dis[e[j].u]*e[j].w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[e[j].v]&lt;dis[e[j].u]*e[j].w)</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">"Case %d: Yes\n"</span>,time);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d: No\n"</span>,time);</span><br><span class="line">time++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;br&gt;poj2240,bellman求正环，map使用&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="poj" scheme="https://yuanfang.tech/categories/poj/"/>
    
    
      <category term="bellman" scheme="https://yuanfang.tech/tags/bellman/"/>
    
      <category term="poj" scheme="https://yuanfang.tech/tags/poj/"/>
    
      <category term="kuangbin" scheme="https://yuanfang.tech/tags/kuangbin/"/>
    
  </entry>
  
  <entry>
    <title>poj3660</title>
    <link href="https://yuanfang.tech/2019/07/28/poj3660.html"/>
    <id>https://yuanfang.tech/2019/07/28/poj3660.html</id>
    <published>2019-07-28T09:01:49.000Z</published>
    <updated>2019-07-28T09:08:12.545Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><br>pojj3660,floyd求有向图的传递闭包<p></p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=3660" target="_blank" rel="noopener">http://poj.org/problem?id=3660</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>N头牛，给你M个两头牛的关系，即a可以打败b。</p><p>问最多能确定几头牛的名次。</p><p>即如果这头牛和其余的牛的关系是确定的，那么这个牛的排名就是确定的。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>传递闭包： 关系之间具有传递性（例如a&gt; b, b&gt; c, 那么a&gt; c）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 99999999 </span></span><br><span class="line"><span class="keyword">int</span> e[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">e[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">e[a][b]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[i][k]&amp;&amp;e[k][j])</span><br><span class="line">e[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>,flag;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(e[i][j]==<span class="number">0</span>&amp;&amp;e[j][i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">1</span>)ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;br&gt;pojj3660,floyd求有向图的传递闭包&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="poj" scheme="https://yuanfang.tech/categories/poj/"/>
    
    
      <category term="poj" scheme="https://yuanfang.tech/tags/poj/"/>
    
      <category term="kuangbin" scheme="https://yuanfang.tech/tags/kuangbin/"/>
    
      <category term="floyd" scheme="https://yuanfang.tech/tags/floyd/"/>
    
  </entry>
  
  <entry>
    <title>poj1502</title>
    <link href="https://yuanfang.tech/2019/07/28/poj1502.html"/>
    <id>https://yuanfang.tech/2019/07/28/poj1502.html</id>
    <published>2019-07-28T08:08:49.000Z</published>
    <updated>2019-07-28T08:14:02.026Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><br>poj1502,单源最短路，坑爹题意，优雅使用sscanf<p></p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=1502" target="_blank" rel="noopener">http://poj.org/problem?id=1502</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>N个点，之后给你半个邻接矩阵。由于自己到自己是0，所以也不给。</p><p>x为无法到达。</p><p>求最短路中的最大值。即dis[]中最大值。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>dijstra模板题。就是输入比较麻烦。</p><p>sscanf(s,”%d”,&amp;e[i] [j]);</p><p>这样输入就很简单了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 99999999</span></span><br><span class="line"><span class="keyword">int</span> e[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)e[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> e[i][j]=inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'x'</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(s,<span class="string">"%d"</span>,&amp;e[i][j]);</span><br><span class="line">e[j][i]=e[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">dis[i]=e[<span class="number">1</span>][i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">book[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">book[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> min,temp;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">min=inf;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[j]&lt;min&amp;&amp;book[j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">min=dis[j];</span><br><span class="line">temp=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">book[temp]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[temp]+e[temp][j]&lt;dis[j])</span><br><span class="line">dis[j]=dis[temp]+e[temp][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(max&lt;dis[i])max=dis[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;br&gt;poj1502,单源最短路，坑爹题意，优雅使用sscanf&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="poj" scheme="https://yuanfang.tech/categories/poj/"/>
    
    
      <category term="dijstra" scheme="https://yuanfang.tech/tags/dijstra/"/>
    
      <category term="poj" scheme="https://yuanfang.tech/tags/poj/"/>
    
      <category term="kuangbin" scheme="https://yuanfang.tech/tags/kuangbin/"/>
    
  </entry>
  
  <entry>
    <title>poj3259</title>
    <link href="https://yuanfang.tech/2019/07/28/poj3259.html"/>
    <id>https://yuanfang.tech/2019/07/28/poj3259.html</id>
    <published>2019-07-28T07:22:18.000Z</published>
    <updated>2019-07-28T07:25:48.981Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><br>poj3259,求负环<p></p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=3259" target="_blank" rel="noopener">http://poj.org/problem?id=3259</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有N个点，M条路，W个虫洞。路是双向的，虫洞是单向的。</p><p>每次穿越虫洞将会时间回溯虫洞的权值。</p><p>问能否通过虫洞回到过去？</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>bellman求负环板子题</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 99999999</span></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> u[<span class="number">6000</span>],v[<span class="number">6000</span>],w[<span class="number">6000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,n,m,w1,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;w1);</span><br><span class="line"><span class="keyword">int</span> i,a,b,c,k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">u[k]=a;v[k]=b;w[k++]=c;</span><br><span class="line">u[k]=b;v[k]=a;w[k++]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=w1;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">u[k]=a;v[k]=b;w[k++]=-c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">dis[i]=inf;</span><br><span class="line"></span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n<span class="number">-1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v[i]]&gt;dis[u[i]]+w[i])</span><br><span class="line">dis[v[i]]=dis[u[i]]+w[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v[i]]&gt;dis[u[i]]+w[i])</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;br&gt;poj3259,求负环&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="poj" scheme="https://yuanfang.tech/categories/poj/"/>
    
    
      <category term="bellman" scheme="https://yuanfang.tech/tags/bellman/"/>
    
      <category term="poj" scheme="https://yuanfang.tech/tags/poj/"/>
    
      <category term="kuangbin" scheme="https://yuanfang.tech/tags/kuangbin/"/>
    
  </entry>
  
  <entry>
    <title>bellman</title>
    <link href="https://yuanfang.tech/2019/07/26/bellman.html"/>
    <id>https://yuanfang.tech/2019/07/26/bellman.html</id>
    <published>2019-07-26T06:56:16.000Z</published>
    <updated>2019-07-26T08:08:38.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Bellman算法"><a href="#Bellman算法" class="headerlink" title="Bellman算法"></a>Bellman算法</h2><p>Dijstra只能求没有负权边的图，因为当所有边权为正时，不会存在一个路程更短的没有拓展过的点，所以这个点的路程永远不会再改变，从而保证了dijstra的正确性。</p><p>那么有没有一个算法可以求带有负权边的指定顶点到其余各个顶点的最短路径算法呢？</p><p>那就到Bellman-Ford出场了。</p><p>复杂度：O(NM)</p><p>优化后：&lt;=O(NM)</p><a id="more"></a><p>求1号顶点到其余所有顶点的最短路径。</p><p><img src="bellman\1564125629485.png" alt="1564125629485"></p><p>依旧用dis[]存储1号顶点到所有顶点的距离。</p><p><img src="bellman\1564125848909.png" alt="1564125848909"></p><p>接下来根据边给出的顺序，先处理第一条边2-3  2。</p><p>通过2-3这条边进行松弛。即判断dis[3]是否大于dis[2]+2。此时dis[3]是∞，dis[2]也是∞，那么dis[3]&lt;dis[2]+2。所以通过2-3-2不能是dis[3]的值变小，松弛失败。</p><p>继续处理第二条边1-2  -3。</p><p>发现dis[2]&gt;dis[1]+(-3)，通过这条边可以使dis[2]的值从∞变成-3。因此松弛成功。</p><p>以此类推，用同样的方法处理剩下的每一条边。对所有的边松弛一便后的结果如下：</p><p><img src="bellman\1564126314876.png" alt="1564126314876"></p><p>可以发现，1-2和1-5的距离变短了。我们再对所有边进行一轮松弛操作。</p><p><img src="bellman\1564126386305.png" alt="1564126386305"></p><p>如果说floyd是每次只能经过一个点中转来求到达其余个点的最短路径长度，那bellman就是每次只能经过一条边来求到达其余个点的最短路径长度。</p><p>如果进行k轮的话，那么就是从1号顶点最多经过k条边到达其余各顶点的最短路径长度。</p><p>因为再含有n个顶点的图中，任意两点间的最短路径最多包含n-1条边。</p><p>所以最多只需要进行n-1轮松弛即可求出最短路径。</p><p>另外，最短路径可能包含回路。</p><p>回路分为正权回路和负权回路。</p><p>如果包含正权回路，那么去掉正权回路之后一定能找到更短的路径。</p><p>如果包含负权回路，那么肯定没有最短路径。因为每多走一次负权回路就可以得到更短的路径。</p><p>继续</p><p><img src="bellman\1564127047514.png" alt="1564127047514"></p><p>完工！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对所有的边进行n-1次松弛操作。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="keyword">if</span>(dis[v[i]]&gt;dis[u[i]]+w[i])</span><br><span class="line">dis[v[i]]=dis[u[i]]+w[i];</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>待施工~~~</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bellman算法&quot;&gt;&lt;a href=&quot;#Bellman算法&quot; class=&quot;headerlink&quot; title=&quot;Bellman算法&quot;&gt;&lt;/a&gt;Bellman算法&lt;/h2&gt;&lt;p&gt;Dijstra只能求没有负权边的图，因为当所有边权为正时，不会存在一个路程更短的没有拓展过的点，所以这个点的路程永远不会再改变，从而保证了dijstra的正确性。&lt;/p&gt;
&lt;p&gt;那么有没有一个算法可以求带有负权边的指定顶点到其余各个顶点的最短路径算法呢？&lt;/p&gt;
&lt;p&gt;那就到Bellman-Ford出场了。&lt;/p&gt;
&lt;p&gt;复杂度：O(NM)&lt;/p&gt;
&lt;p&gt;优化后：&amp;lt;=O(NM)&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://yuanfang.tech/categories/algorithm/"/>
    
    
      <category term="bellman" scheme="https://yuanfang.tech/tags/bellman/"/>
    
  </entry>
  
  <entry>
    <title>poj1860</title>
    <link href="https://yuanfang.tech/2019/07/26/poj1860.html"/>
    <id>https://yuanfang.tech/2019/07/26/poj1860.html</id>
    <published>2019-07-26T06:48:25.000Z</published>
    <updated>2019-07-26T06:55:47.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><br>poj1860，求图正环<p></p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=1860" target="_blank" rel="noopener">http://poj.org/problem?id=1860</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有多种汇币，汇币之间可以交换，这需要手续费，当你用100A币交换B币时，A到B的汇率是29.75，手续费是0.39，那么你可以得到(100 - 0.39) * 29.75 = 2963.3975 B币。问s币的金额经过交换最终得到的s币金额数能否增加。</p><p>输入：</p><p>第一行，N种货币，M个交换所，你手上拥有的货币种类s，你手上拥有的money；</p><p>接下来m行，a币，b币，a到b的汇率，a到b的手续费，b到a的汇率，b到a的手续费。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>bellman算法求正环，只需要按所有边都松弛一边之后然后进行判断能否再次松弛即可。能继续松弛即为有正环。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 99999999</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u[<span class="number">220</span>],v[<span class="number">220</span>];</span><br><span class="line"><span class="keyword">double</span> dis[<span class="number">110</span>],wl[<span class="number">220</span>],ws[<span class="number">220</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,s,i;</span><br><span class="line"><span class="keyword">double</span> money;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%lf"</span>,&amp;n,&amp;m,&amp;s,&amp;money);</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k=m;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">double</span> al,as,bl,bs;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf%lf%lf%lf"</span>,&amp;a,&amp;b,&amp;al,&amp;as,&amp;bl,&amp;bs);</span><br><span class="line">u[i]=a;v[i]=b;wl[i]=al;ws[i]=as;</span><br><span class="line">i++;</span><br><span class="line">u[i]=b;v[i]=a;wl[i]=bl;ws[i]=bs;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;=n;t++)</span><br><span class="line">&#123;</span><br><span class="line">dis[t]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s]=money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">1</span>;t&lt;=k;t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v[j]]&lt;(dis[u[j]]-ws[j])*wl[j])</span><br><span class="line">dis[v[j]]=(dis[u[j]]-ws[j])*wl[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v[j]]&lt;(dis[u[j]]-ws[j])*wl[j])</span><br><span class="line">&#123;</span><br><span class="line">dis[v[j]]=(dis[u[j]]-ws[j])*wl[j];</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;br&gt;poj1860，求图正环&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="poj" scheme="https://yuanfang.tech/categories/poj/"/>
    
    
      <category term="bellman" scheme="https://yuanfang.tech/tags/bellman/"/>
    
      <category term="poj" scheme="https://yuanfang.tech/tags/poj/"/>
    
      <category term="kuangbin" scheme="https://yuanfang.tech/tags/kuangbin/"/>
    
  </entry>
  
  <entry>
    <title>floyd</title>
    <link href="https://yuanfang.tech/2019/07/25/floyd.html"/>
    <id>https://yuanfang.tech/2019/07/25/floyd.html</id>
    <published>2019-07-25T10:34:24.000Z</published>
    <updated>2019-07-25T11:10:01.920Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><p></p><h2 id="Floyed算法"><a href="#Floyed算法" class="headerlink" title="Floyed算法"></a>Floyed算法</h2><p>复杂度：O（n^3）</p><p>poj又又又又炸了。写一下Floyd吧。核心代码五行，很简单。</p><p>求一张图内任意两点间的距离。</p><p><img src="http://pv35325dx.bkt.clouddn.com/guahua.gif" alt="=w="></p><a id="more"></a><p>例如：求任意两个点的最短路程。</p><p><img src="floyd\1564051171338.png" alt="1564051171338"></p><p>用矩阵存储图。</p><p><img src="floyd\1564051237886.png" alt="1564051237886"></p><p>首先我们知道两个点之间的距离了，接下来可以思考，有没有办法通过第三个点来进行中转来缩短路程呢？</p><p>因此我们可以假设现在只允许通过1号点进行中转，来进行尝试缩短路程。</p><p>只需要判断e[i] [1]+e[1] [j]是否比e[i] [j]小即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[i][j]&gt;e[i][<span class="number">1</span>]+e[<span class="number">1</span>][j])</span><br><span class="line">e[i][j]=e[i][<span class="number">1</span>]+e[<span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在只允许通过1号顶点的情况下，任意两点间的最短路径更新为：</p><p><img src="floyd\1564052208614.png" alt="1564052208614"></p><p>以此类推，然后考虑只允许通过2号点进行中转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[i][j]&gt;e[i][<span class="number">2</span>]+e[<span class="number">2</span>][j])</span><br><span class="line">e[i][j]=e[i][<span class="number">2</span>]+e[<span class="number">2</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几乎一毛一样，1变成2。</p><p>更新：</p><p><img src="floyd\1564052291135.png" alt="1564052291135"></p><p>通过3号点中转更新：</p><p><img src="floyd\1564052336765.png" alt="1564052336765"></p><p>通过4号点中转更新：</p><p><img src="floyd\1564052379218.png" alt="1564052379218"></p><p>更新完毕。上图即为任意两点间最终的最短路程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说就是遍历通过1-n个点的中转来缩短最短路程。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j])</span><br><span class="line">e[i][j]=e[i][k]+e[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;Floyed算法&quot;&gt;&lt;a href=&quot;#Floyed算法&quot; class=&quot;headerlink&quot; title=&quot;Floyed算法&quot;&gt;&lt;/a&gt;Floyed算法&lt;/h2&gt;&lt;p&gt;复杂度：O（n^3）&lt;/p&gt;
&lt;p&gt;poj又又又又炸了。写一下Floyd吧。核心代码五行，很简单。&lt;/p&gt;
&lt;p&gt;求一张图内任意两点间的距离。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pv35325dx.bkt.clouddn.com/guahua.gif&quot; alt=&quot;=w=&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://yuanfang.tech/categories/algorithm/"/>
    
    
      <category term="floyd" scheme="https://yuanfang.tech/tags/floyd/"/>
    
  </entry>
  
  <entry>
    <title>poj3268</title>
    <link href="https://yuanfang.tech/2019/07/25/poj3268.html"/>
    <id>https://yuanfang.tech/2019/07/25/poj3268.html</id>
    <published>2019-07-24T17:39:39.000Z</published>
    <updated>2019-07-24T17:48:58.479Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><br>poj3268,最短路变形，有向图，求来回距离<p></p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=3268" target="_blank" rel="noopener">http://poj.org/problem?id=3268</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出n个点和m条边，接着是m条边，代表从牛a到牛b需要花费c时间，现在所有牛要到牛x那里去参加聚会，并且所有牛参加聚会后还要回来，给你牛x，除了牛x之外的牛，他们都有一个参加聚会并且回来的最短时间，从这些最短时间里找出一个最大值输出。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>首先可以想到，所有牛到X的最短距离，那么将X作为起点就可以通过dijstra知道X到其他点的距离。即返程的距离。</p><p>只需要转置矩阵一下，就可以求出其他点到X的距离了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 99999999</span></span><br><span class="line"><span class="keyword">int</span> e[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)book[i]=<span class="number">0</span>;</span><br><span class="line">book[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=e[x][i];</span><br><span class="line">dis[x]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min=inf,temp,v;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(book[j]==<span class="number">0</span>&amp;&amp;dis[j]&lt;min)</span><br><span class="line">&#123;</span><br><span class="line">min=dis[j];</span><br><span class="line">temp=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">book[temp]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[temp][v]&lt;inf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum[i]=sum[i]+dis[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c,i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;x);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">e[i][j]=inf;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">sum[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">e[a][b]=c;</span><br><span class="line">&#125;</span><br><span class="line">dijstra();</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">temp=e[i][j];</span><br><span class="line">e[i][j]=e[j][i];</span><br><span class="line">e[j][i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">dijstra();</span><br><span class="line"><span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==x)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sum[i]&gt;max)max=sum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,max);</span><br><span class="line">&#125; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 99999999</span></span><br><span class="line"><span class="keyword">int</span> e[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)book[i]=<span class="number">0</span>;</span><br><span class="line">book[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=e[x][i];</span><br><span class="line">dis[x]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min=inf,temp,v;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(book[j]==<span class="number">0</span>&amp;&amp;dis[j]&lt;min)</span><br><span class="line">&#123;</span><br><span class="line">min=dis[j];</span><br><span class="line">temp=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">book[temp]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[temp][v]&lt;inf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum[i]=sum[i]+dis[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c,i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;x);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">e[i][j]=inf;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">sum[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">e[a][b]=c;</span><br><span class="line">&#125;</span><br><span class="line">dijstra();</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">temp=e[i][j];</span><br><span class="line">e[i][j]=e[j][i];</span><br><span class="line">e[j][i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">dijstra();</span><br><span class="line"><span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==x)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sum[i]&gt;max)max=sum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;br&gt;poj3268,最短路变形，有向图，求来回距离&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="poj" scheme="https://yuanfang.tech/categories/poj/"/>
    
    
      <category term="dijstra" scheme="https://yuanfang.tech/tags/dijstra/"/>
    
      <category term="poj" scheme="https://yuanfang.tech/tags/poj/"/>
    
      <category term="kuangbin" scheme="https://yuanfang.tech/tags/kuangbin/"/>
    
  </entry>
  
  <entry>
    <title>poj1797</title>
    <link href="https://yuanfang.tech/2019/07/24/poj1797.html"/>
    <id>https://yuanfang.tech/2019/07/24/poj1797.html</id>
    <published>2019-07-24T12:00:23.000Z</published>
    <updated>2019-07-24T17:50:33.553Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><br>poj1797,最短路变形<p></p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=1797" target="_blank" rel="noopener">http://poj.org/problem?id=1797</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>青蛙那题的变形版本。</p><p>输入T组，每组x个点，y条边。</p><p>接下来y行分别是a到b的边的权重。</p><p>求1到x的所有边中最大的最小边权重。（2333读懂题目就会了）</p><p>形象一点理解就是权重为道路的载重量，这题求的就是一辆卡车从1开到x，卡车最多可以载重多少。当然取决于一条路上载重量最低的那条路。输出那条路的载重量。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>思路：反过来查找dis[]中最大的，那么就能确定1到那个点的最大权重了，然后进行。。松弛？</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Dijstra变形：一开始读错题了导致代码写丑了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 99999999</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funmin</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)<span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funmax</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[<span class="number">1010</span>][<span class="number">1010</span>],book[<span class="number">1010</span>],dis[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i,j,x,y,a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=x;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=x;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)e[i][j]=<span class="number">0</span>;</span><br><span class="line">e[i][j]=-inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(y--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">e[a][b]=c;</span><br><span class="line">e[b][a]=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=x;i++)</span><br><span class="line">&#123;</span><br><span class="line">dis[i]=e[<span class="number">1</span>][i];</span><br><span class="line">book[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>;book[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> max=-inf;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=x;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[j]&gt;max&amp;&amp;book[j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">max=dis[j];</span><br><span class="line">temp=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">book[temp]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">2</span>;v&lt;=x;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[temp][v]&gt;<span class="number">0</span>&amp;&amp;book[v]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=funmax(dis[v],funmin(e[temp][v],dis[temp]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n%d\n\n"</span>,count++,dis[x]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;br&gt;poj1797,最短路变形&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="poj" scheme="https://yuanfang.tech/categories/poj/"/>
    
    
      <category term="dijstra" scheme="https://yuanfang.tech/tags/dijstra/"/>
    
      <category term="poj" scheme="https://yuanfang.tech/tags/poj/"/>
    
      <category term="kuangbin" scheme="https://yuanfang.tech/tags/kuangbin/"/>
    
  </entry>
  
  <entry>
    <title>poj2253</title>
    <link href="https://yuanfang.tech/2019/07/24/poj2253.html"/>
    <id>https://yuanfang.tech/2019/07/24/poj2253.html</id>
    <published>2019-07-24T09:42:08.000Z</published>
    <updated>2019-07-24T17:50:05.753Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><br>poj2253,最短路变形<p></p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=2253" target="_blank" rel="noopener">http://poj.org/problem?id=2253</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>第一行T，告诉你有T个点，下面T行是它们的坐标</p><p>有两只青蛙，T的第一个是a青蛙坐标，第二个是b青蛙坐标</p><p>求a青蛙到b青蛙那里的所有路中最短的 路径中最大的边</p><p><img src="poj2253\2253.png" alt="2253"></p><p>例：如图所示，1到3距离为1，2到3距离为1，1到2距离为2，那么根据题意，1-3-2最长的边是1，1-2最长的是2，所以输出1。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>输出有俩\n</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Dijstra改一改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 99999999</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funmin</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)<span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funmax</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">210</span>],y[<span class="number">210</span>],book[<span class="number">210</span>];</span><br><span class="line"><span class="keyword">double</span> e[<span class="number">210</span>][<span class="number">210</span>],dis[<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=t;j++)</span><br><span class="line">e[i][j]=inf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;t;i++)</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=t;j++)</span><br><span class="line">&#123;</span><br><span class="line">e[i][j]=e[j][i]=<span class="built_in">sqrt</span>(<span class="keyword">double</span>(x[i]-x[j])*(x[i]-x[j])+<span class="keyword">double</span>(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">&#123;</span><br><span class="line">dis[i]=e[<span class="number">1</span>][i];</span><br><span class="line">book[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>;book[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> min=inf;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=t;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[j]&lt;min&amp;&amp;book[j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">min=dis[j];</span><br><span class="line">temp=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">book[temp]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">1</span>;v&lt;=t;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[temp][v]&lt;inf)</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=funmin(dis[v],funmax(e[temp][v],dis[temp]));<span class="comment">//比较经过temp点松弛后的路线中最长跳跃距离和dis[v]的距离</span></span><br><span class="line"><span class="comment">//if(e[temp][v]+dis[temp]&lt;dis[v])dis[v]=dis[temp]+e[temp][v];</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Scenario #%d\nFrog Distance = %.3lf\n\n"</span>,count++,dis[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;br&gt;poj2253,最短路变形&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="poj" scheme="https://yuanfang.tech/categories/poj/"/>
    
    
      <category term="dijstra" scheme="https://yuanfang.tech/tags/dijstra/"/>
    
      <category term="poj" scheme="https://yuanfang.tech/tags/poj/"/>
    
      <category term="kuangbin" scheme="https://yuanfang.tech/tags/kuangbin/"/>
    
  </entry>
  
  <entry>
    <title>poj2387</title>
    <link href="https://yuanfang.tech/2019/07/24/poj2387.html"/>
    <id>https://yuanfang.tech/2019/07/24/poj2387.html</id>
    <published>2019-07-24T08:15:07.000Z</published>
    <updated>2019-07-24T12:51:59.682Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><br>板子题，最短路，poj2387<p></p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://poj.org/problem?id=2387" target="_blank" rel="noopener">http://poj.org/problem?id=2387</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>第一行T组数据，N个顶点</p><p>之后T行告诉你a到b的距离c</p><p>求到n的最短路径</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>有重边 \ \两点之间的路未必只有一条</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Dijstra：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 99999999</span></span><br><span class="line"><span class="keyword">int</span> e[<span class="number">1010</span>][<span class="number">1010</span>],dis[<span class="number">1010</span>],book[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,t,a,b,c,i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)e[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> e[i][j]=inf; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="keyword">if</span>(e[a][b]&gt;c)</span><br><span class="line">&#123;</span><br><span class="line">e[a][b]=c;</span><br><span class="line">e[b][a]=c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">dis[i]=e[<span class="number">1</span>][i];</span><br><span class="line">book[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">book[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min=inf;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[j]&lt;min&amp;&amp;book[j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">min=dis[j];</span><br><span class="line">temp=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">book[temp]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[temp][v]&lt;inf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,dis[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;br&gt;板子题，最短路，poj2387&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="poj" scheme="https://yuanfang.tech/categories/poj/"/>
    
    
      <category term="dijstra" scheme="https://yuanfang.tech/tags/dijstra/"/>
    
      <category term="poj" scheme="https://yuanfang.tech/tags/poj/"/>
    
      <category term="kuangbin" scheme="https://yuanfang.tech/tags/kuangbin/"/>
    
  </entry>
  
  <entry>
    <title>dijstra</title>
    <link href="https://yuanfang.tech/2019/07/23/dijstra.html"/>
    <id>https://yuanfang.tech/2019/07/23/dijstra.html</id>
    <published>2019-07-23T06:09:13.000Z</published>
    <updated>2019-07-23T08:33:50.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Dijstra算法"><a href="#Dijstra算法" class="headerlink" title="Dijstra算法"></a>Dijstra算法</h2><p>博客初建，先记录一个基础的单源最短路算法，Dijstra。</p><p>复杂度：O（N²）</p><p><img src="http://pv35325dx.bkt.clouddn.com/lalala.gif" alt="lalala"></p><a id="more"></a><p>例如求1到各个顶点的最短路径。</p><p><img src="http://pv35325dx.bkt.clouddn.com/1563866213798.png" alt="1"></p><p>首先考虑图的存储问题，使用二维数组e来进行存储各个点之间的边的长度。</p><p><img src="http://pv35325dx.bkt.clouddn.com/1563862729194.png" alt="2"></p><p>然后创建一个一维数组dis来存储1号顶点到其余各个顶点的初始路程。</p><p><img src="http://pv35325dx.bkt.clouddn.com/1563862773804.png" alt="3"></p><p>此时dis数组中的值称为最短路程的“估计值”。</p><p>既然是找最短路，那么根据dis可以寻找到离点1最近的顶点是2。</p><p>那么dis[2]的值就变成了“确定值”。即点1到点2的最短距离就是dis[2]的值。</p><p>既然选择了2号顶点，那就继续看2号顶点的几条出边。有2-3和2-4这两条，先讨论2-3能否让1号顶点到3号顶点的路程变短，即比较dis[3]和dis[2]+e[2] [3]的大小。</p><p>dis[3]=12,dis[2]+e[2] [3]=10,dis[3]&gt;dis[2]+e[2] [3],所以可以通过1-2-3这样缩短1-3的距离，因此dis[3]更新为10。这个过程专业点称为“松弛”。</p><p>同理，dis[2]+e[2] [4]&lt;dis[4],dis[4]的值可以松弛为4。</p><p>这样2号顶点的所有出边就都松弛完了。松弛之后的dis数组为：</p><p><img src="http://pv35325dx.bkt.clouddn.com/1563863527940.png" alt="5"></p><p>接下来以此类推，在剩下的3，4，5，6号顶点中选出离1最近的顶点。</p><p>通过dis数组可以发现最近的顶点是4。</p><p>dis[4]的值变成“确定值”。</p><p>然后继续对4号顶点的所有出边进行松弛。松弛之后的dis数组为：</p><p><img src="http://pv35325dx.bkt.clouddn.com/1563863664903.png" alt="6"></p><p>以此类推，在剩下的3，5，6号顶点中，选出离1号最近的顶点。这次选择3号顶点。</p><p>dis[3]的值变成“确定值”。</p><p>对3号顶点的所有出边进行松弛。松弛之后的dis数组为：</p><p><img src="http://pv35325dx.bkt.clouddn.com/1563863742582.png" alt="7"></p><p>在剩下的5，6号顶点中，选出离1号最近的顶点。选择5号。</p><p>dis[5]的值变成“确定值”。</p><p>对5号顶点的所有出边进行松弛。松弛之后的dis数组为：</p><p><img src="http://pv35325dx.bkt.clouddn.com/1563863819140.png" alt="8"></p><p>最后选择6号。</p><p>dis[6]的值变成“确定值”。</p><p>最后对6号顶点的所有出边进行松弛。因为此例6号没有出边，因此不用处理。</p><p>至此，dis数组中所有的值都已经从“估计值”变成了“确定值”。</p><p>最终dis数组如下，这便是1号顶点到各个顶点的最短路径。</p><p><img src="http://pv35325dx.bkt.clouddn.com/1563863951516.png" alt="10"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算法基本思想：每次都找离源点最近的顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 101 <span class="comment">//最大顶点数 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> e[MAXN][MAXN],dis[MAXN];</span><br><span class="line"><span class="keyword">int</span> temp,v,i,j,a,b,c,n,m,min;</span><br><span class="line"><span class="keyword">int</span> inf=<span class="number">99999999</span>;<span class="comment">//存储一个认为正无穷的值</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);<span class="comment">//n个顶点，m条边</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span>(i==j)e[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> e[i][j]=inf;</span><br><span class="line"><span class="comment">//初始化 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">e[a][b]=c;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//读入边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">dis[i]=e[<span class="number">1</span>][i];</span><br><span class="line"><span class="comment">//初始化dis数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> book[MAXN];<span class="comment">//在代码中，需要用一个book数组进行标记估计值还是确定值</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)book[i]=<span class="number">0</span>;</span><br><span class="line">book[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijstra算法核心语句</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">min=inf;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(book[j]==<span class="number">0</span> &amp;&amp; dis[j]&lt;min)</span><br><span class="line">&#123;</span><br><span class="line">min=dis[j];</span><br><span class="line">temp=j;<span class="comment">//记录最小的顶点号 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">book[temp]=<span class="number">1</span>;<span class="comment">//dis[temp]变成确定值</span></span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[temp][v]&lt;inf)<span class="comment">//进行松弛 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[temp]+e[temp][v]&lt;dis[v])</span><br><span class="line">dis[v]=dis[temp]+e[temp][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i]);<span class="comment">//输出结果 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dijstra算法&quot;&gt;&lt;a href=&quot;#Dijstra算法&quot; class=&quot;headerlink&quot; title=&quot;Dijstra算法&quot;&gt;&lt;/a&gt;Dijstra算法&lt;/h2&gt;&lt;p&gt;博客初建，先记录一个基础的单源最短路算法，Dijstra。&lt;/p&gt;
&lt;p&gt;复杂度：O（N²）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pv35325dx.bkt.clouddn.com/lalala.gif&quot; alt=&quot;lalala&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://yuanfang.tech/categories/algorithm/"/>
    
    
      <category term="dijstra" scheme="https://yuanfang.tech/tags/dijstra/"/>
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="https://yuanfang.tech/2019/07/22/my-first.html"/>
    <id>https://yuanfang.tech/2019/07/22/my-first.html</id>
    <published>2019-07-22T13:16:19.000Z</published>
    <updated>2019-07-23T13:53:12.710Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p class="description"></p><br><img src="http://pv35325dx.bkt.clouddn.com/first.jpg" alt="first"><p></p><a id="more"></a><p>经过两天的搭建，终于好像搭好了！安装上了node,git,hexo.然后扔GitHub然后买了个域名。编辑md软件用的Typora，蛮好用。</p><p>域名yuanfang.tech，既有远方，又有远芳的意思，还可以记成元芳，给别人记应该很好记23333（没办法lmf太贵了）。本来还想起个英文的，但算了，中文更写意。tech很有dalao的感觉。</p><p>计划以后写题啊算法啥的都往上放。</p><p>就先这样，功能慢慢加，日后完善。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;http://pv35325dx.bkt.clouddn.com/first.jpg&quot; alt=&quot;first&quot;&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="somethings" scheme="https://yuanfang.tech/categories/somethings/"/>
    
    
      <category term="test" scheme="https://yuanfang.tech/tags/test/"/>
    
  </entry>
  
</feed>
