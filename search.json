[{"title":"hdu3038","url":"%2F2019%2F08%2F10%2Fhdu3038.html","content":"<p class=\"description\"></p>\nhdu3038,加权并查集，需要理解\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3038\n\n## 题意\n\n求在有n个数中，有m次询问，每次询问在这给定的区间和这区间里数的和为s，求每次给出的是不是正确的和s。也就是和前面的矛盾不矛盾。\n\n## 细节\n\n用一个sum[]来记录当前端点到父亲节点的距离。\n\n若输入的a，b的父亲节点相同时，进行判断。\n\n否则更新父亲节点，同时更新点的sum[]。\n\n## 代码\n\n```c++\n#include <cstdio>\n#define maxn 200010\nusing namespace std;\nint sum[maxn],pr[maxn];//pr存父亲节点，sum存父亲节点到当前节点的距离 \nint n,m,ans;\nvoid init()\n{\n\tint i;\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tpr[i]=i;\n\t\tsum[i]=0;\n\t}\n\tans=0;\n}\n\nint find(int x)\n{\n\tif(x==pr[x])return x;\n\telse \n\t{\n\t\tint k=pr[x];\n\t\tpr[x]=find(pr[x]);\n\t\tsum[x]=sum[x]+sum[k];\n\t\treturn pr[x];\n\t}\n}\n\nvoid to_union(int a,int b,int c)\n{\n\tint x,y;\n\tx=find(a);\n\ty=find(b);\n\tif(x==y)\n\t{\n\t\tif(sum[a]+c!=sum[b])\n\t\t{\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t}\n\telse if(x<y)\n\t{\n\t\tpr[y]=x;\n\t\tsum[y]=sum[a]+c-sum[b];\n\t}\n\telse\n\t{\n\t\tpr[x]=y;\n\t\tsum[x]=sum[b]-sum[a]-c;\n\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF)\n\t{\n\t\tint a,b,c;\n\t\tinit();\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tto_union(a-1,b,c);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["hdu"]},{"title":"hdu1213","url":"%2F2019%2F08%2F09%2Fhdu1213.html","content":"<p class=\"description\"></p>\nhdu1213，并查集水题\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1213\n\n## 题意\n\n输入t组，n个人，m组关系。\n\na认识b，b认识c，那么a也等于认识c。\n\n认识的人可以坐一张桌子上，求最少要多少张桌子。\n\n## 细节\n\n假设一开始有n张桌子，每有一个人并到集合中去，就减少一张桌子\n\n代码\n\n```c++\n#include <vector>\n#include <iostream>\n#include <cstdio>\nusing namespace std; \nvector<int> parent;\nvoid init(int max_size)\n{\n\t// 初始化每一个元素的根节点都为自身\n\tparent.clear();\n\tfor (int i = 0; i <=max_size; ++i)\n\t\tparent.push_back(i);\n}\nint find(int x)\n{\n\treturn parent[x] == x ? x : find(parent[x]);\n}\nvoid to_union(int x1, int x2)\n{\n\tparent[find(x1)] = find(x2);\n}\nint main()\n{\n\tint t,n,m,i,a,b;\n\tint vis[1010];\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tinit(n);\n\t\tint ans=n;\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t{\n\t\t\t\tif(find(a)!=find(b))\n\t\t\t\t{\n\t\t\t\t\tans--;\n\t\t\t\t\tto_union(a,b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["hdu"]},{"title":"七夕","url":"%2F2019%2F08%2F07%2F%E4%B8%83%E5%A4%95.html","content":"<p class=\"description\"></p>\n一看居然七夕了。\n\n![](http://pv35325dx.bkt.clouddn.com/56884409_p0.jpg)\n\n<!-- more -->\n\n我是对这个节日不怎么感冒的。\n\n当然，我相信爱情，而且是很单纯的那种。我相信美好的爱情。\n\n我甚至有时候感觉我自己长情到可怕。一个名字刻在心里十几年，我才活了多少岁。只是随着时间时间流逝，多年未见，已经与她没有任何交集了。我甚至开始怀疑，也许那只是我还小，不懂得爱慕和喜欢的区别。\n\n我也觉得我不适合爱人。我懂啥，我啥也不懂。我能给予什么，我什么也给不了。我甚至为未来而迷茫。\n\n爱乐之城真的很棒，梦想会一直伴随着你，爱人也许不会。\n\n所以我觉得更应该去努力提升自己。\n\n今天又是wrong answer了一个下午，日常自闭。但我很满足，很充实，我能感受到我在做有意义的事情。\n\n就算是平庸如我，渺小如我，世间辽阔，也只一个。\n\n这心头热火，唇间冰河，悉数无关我。\n\n词不达意。\n\n\n\n<hr />\n","categories":["somethings"]},{"title":"poj1611","url":"%2F2019%2F08%2F07%2Fpoj1611.html","content":"<p class=\"description\"></p>\npoj1611,并查集水题\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1611\n\n## 题意\n\n0号学生得了流感，跟他一组的就会受到感染，间接的也会。\n\n第一行告诉你有n个学生，m组。\n\n接下来m行告诉你每组有t个人，接下来是t个人的编号。\n\n输出有多少个学生被感染了。\n\n## 细节\n\n水水水。。。每组跟第一个人to_union一下就好。\n\n最后查一下跟0号parent一样的就ans++\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define maxn 30010\nusing namespace std;\nint parent[maxn];\nint rank[maxn];\nint sets[maxn];\nint n,m;\nint find(int x)\n{\n    return x == parent[x] ? x : (parent[x] = find(parent[x]));\n}\n\nvoid to_union(int x1, int x2)\n{\n\tint f1 = find(x1);\n\tint f2 = find(x2);\n\tif (rank[f1] > rank[f2])\n\t\tparent[f2] = f1;\n    else\n        {\n            parent[f1] = f2;\n            if (rank[f1] == rank[f2])\n                ++rank[f2];\n        }\n}\n\nvoid init()\n{\n\tint i;\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tparent[i]=i;\n\t\trank[i]=0;\n\t}\n}\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&m))\n\t{\n\t\tif(n==0&&m==0)break;\n\t\tinit();\n\t\tint i,j;\n\t\twhile(m--)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(i=0;i<t;i++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&sets[i]);\n\t\t\t}\n\t\t\tfor(i=1;i<t;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tto_union(sets[0],sets[i]);\n\t\t\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(find(i)==find(0))ans++;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj2236","url":"%2F2019%2F08%2F04%2Fpoj2236.html","content":"<p class=\"description\"></p>\npoj2236,并查集\n\n**能用puts就别用printf！！！**\n\nimportant！！![](http://pv35325dx.bkt.clouddn.com/%E5%BC%9F%E5%BC%9F.jpeg)\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2236\n\n## 题意\n\n有n台计算机, 已知每台计算机的坐标, 初始时所有计算机都是坏的, 然后修复其中一些计算机, 已修复的计算机距离不超过distance的可以联网(若a, b之间可以联网, b, c之间可以联网, 则a, c之间可以联网),询问x, y之间可否联网;\n\n第一行输入n, distance, 表示有n台计算机, 联网的两台计算机距离不能超过distance;\n\n接下来n分别表示n台计算机的坐标;\n\n再接下来到输入结束, 输入格式为: O, x 的表示修复第x台计算机, 输入格式为S, x, y 的表示询问x, y之间能否联网, 若能输出 SUCCESS, 不能则输出 FAIL;\n\n## 细节\n\n并查集，修好的机器就跟别的机器尝试连接一下，满足条件就放入一个集合\n\n## 代码\n\n3032ms，看到有1000+ms就过了的，晚点看看人家是怎么做的\n\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#define maxn 1010\nusing namespace std;\nint n,d,k;\nvector<int> parent;\nvector<int> rank;\nvoid init(int max_size)\n{\n\t// 初始化每一个元素的根节点都为自身\n\tparent.clear();\n\trank.clear();\n\tfor (int i = 0; i <=max_size; ++i)\n\t\t{\n\t\t\tparent.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n}\n\nint find(int x)\n{\n    return x == parent[x] ? x : (parent[x] = find(parent[x]));\n}\n\nvoid to_union(int x1, int x2)\n{\n\tint f1 = find(x1);\n\tint f2 = find(x2);\n\tif (rank[f1] > rank[f2])\n\t\tparent[f2] = f1;\n    else\n        {\n            parent[f1] = f2;\n            if (rank[f1] == rank[f2])\n                ++rank[f2];\n        }\n}\n\nbool is_same(int e1, int e2)\n{\n\treturn find(e1) == find(e2);\n}\n\nstruct point\n{\n\tint x,y,vis;\n}po[maxn]; \n\ndouble dis(int a,int b)\n{\n\treturn sqrt((po[a].x-po[b].x)*(po[a].x-po[b].x)+(po[a].y-po[b].y)*(po[a].y-po[b].y));\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&d);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&po[i].x,&po[i].y);\n\t\tpo[i].vis=0;\n\t}\n\tgetchar();\n\tinit(n);\n\tchar x;\n\tint k;\n\twhile(scanf(\"%c\",&x)!=EOF)\n\t{\n\t\tif(x=='O')\n\t\t{\n\t\t\tscanf(\"%d\",&k);\n\t\t\tpo[k].vis=1;\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tif(po[i].vis==1&&i!=k)\n\t\t\t\t{\n\t\t\t\t\tif(dis(k,i)<=d&&(!is_same(k,i)))\n\t\t\t\t\t{\n\t\t\t\t\t\t//printf(\"%d%d\\n\",k,i);\n\t\t\t\t\t\tto_union(k,i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tif(is_same(a,b))printf(\"SUCCESS\\n\");\n\t\t\telse printf(\"FAIL\\n\");\n\t\t}\n\t\tgetchar();\n\t}\n}\n```\n\n\n\n## 更新（心累的故事）\n\n![1564991288139](poj2236\\1564991288139.png)\n\n考虑了很久。。代码越来越长耗时越来越多。。（负优化实锤了）\n\n怎么想都感觉没啥更快的方法了。\n\n我又看了眼那个老哥：![](poj2236\\1565003068075.png)\n\n![TIM图片20190805190547](poj2236\\TIM图片20190805190547.jpg)嗯？？？？\n\n那我拿你的代码交交看。\n\n![1565003423379](poj2236\\1565003423379.png)\n\n![TIM图片20190805190547](poj2236\\TIM图片20190805190547.jpg)嗯？？？？！\n\n唉。。。\n\n然后看了看通过这题的人，确实是有1s左右过的，然后我就继续开始思考。\n\n有哪里不对。\n\n网上找了找别人的代码，交了几份，找到了一份932ms的。厉害啊老哥！\n\n代码风格跟我差不多，很棒，我一下子就读懂了。\n\n```c++\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct coordinate\n{\n    int x,y;\n}a[1010];\nint n,d;\n\nvector<int>father;\nvector<int>visit;\n//int father[1010];\n//int visit[1010];\n \nint find_it(int x)\n{\n    int tempx=x,t;\n    while(tempx!=father[tempx])\n        tempx=father[tempx];\n \n    while(x!=father[x])\n    {\n        t=father[x];\n        father[x]=tempx;\n        x=t;\n    }\n    return tempx;\n}\n \nbool calc(int p1,int p2)\n{\n    if(d*d>=((a[p1].x-a[p2].x)*(a[p1].x-a[p2].x)+(a[p1].y-a[p2].y)*(a[p1].y-a[p2].y)))\n        return true;\n    return false;\n}\n \nvoid unin(int x,int y)\n{\n    int tx=find_it(x);\n    int ty=find_it(y);\n \n    if(tx!=ty&&calc(x,y))\n        father[tx]=ty;\n}\n \nint main()\n{\n    scanf(\"%d%d\",&n,&d);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d\",&a[i].x,&a[i].y);\n    }\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfather.push_back(i);\n\t\tvisit.push_back(0);\n\t}\n    char ch[5];\n    int t1,t2;\n    int flag=1;\n    while(scanf(\"%s\",ch)!=EOF){\n        if(ch[0]=='O'){\n            scanf(\"%d\",&t1);\n            visit[t1]=1;\n            if(flag)\n                flag=0;\n            else{\n                for(int i=1;i<=n;i++)\n                    if(visit[i]&&i!=t1)\n                        unin(t1,i);\n            }\n        }\n        else{\n            scanf(\"%d%d\",&t1,&t2);\n            int temp1=find_it(t1);\n            int temp2=find_it(t2);\n            if(temp1==temp2)\n                puts(\"SUCCESS\");\n            else\n                puts(\"FAIL\");\n        }\n    }\n    return 0;\n}\n```\n\nemmm这代码跟我写的思路有啥区别？？？我俩写的不是一毛一样？！\n\n怀疑是我用了STL的问题，于是将他的数组改成了vector。\n\n他，900+，我3000+。\n\n![](poj2236/TIM%E5%9B%BE%E7%89%8720190805191700.gif)why？？？？？\n\n然后就是漫长的找不同时间。\n\n最恐怖的就是我把他的函数copy过来替换了我的函数，我还是3000+。\n\n居然是主函数里面的问题？\n\n最后锁定目标，换成注释里面的就变900+了。\n\n竟然是puts和printf的问题。。\n\n![TIM图片20190805190547](poj2236\\TIM图片20190805190547-1565004175371.jpg)这能差3倍的速度？？我懂了，以后能puts我就puts了。\n\nend.\n\n```c++\n\t\t\tscanf(\"%d%d\",&t1,&t2);\n\t\t\tint temp1,temp2;\n\t\t\ttemp1=find(t1);\n\t\t\ttemp2=find(t2); \n\t\t\tif(temp1==temp2)printf(\"SUCCESS\\n\");\n\t\t\telse printf(\"FAIL\\n\");\n//            scanf(\"%d%d\",&t1,&t2);\n//            int temp1=find(t1);\n//            int temp2=find(t2);\n//            if(temp1==temp2)\n//                puts(\"SUCCESS\");\n//            else\n//                puts(\"FAIL\");\n```\n\n最后是通过的代码，954ms\n\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#define maxn 1010\nusing namespace std;\nint n,d,k;\nvector<int> parent;\nvector<int> rank;\nvoid init()\n{\n\tfor (int i = 0; i <=n; ++i)\n\t\t{\n\t\t\tparent.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n}\n\nint find(int x)\n{\n    return x == parent[x] ? x : (parent[x] = find(parent[x]));\n}\n\nvoid to_union(int x1, int x2)\n{\n\tint f1 = find(x1);\n\tint f2 = find(x2);\n\tif (rank[f1] > rank[f2])\n\t\tparent[f2] = f1;\n    else\n        {\n            parent[f1] = f2;\n            if (rank[f1] == rank[f2])\n                ++rank[f2];\n        }\n}\n\nstruct point\n{\n\tint x,y,vis;\n}po[maxn]; \n\nbool dis(int a,int b)\n{\n\tif(d*d>=((po[a].x-po[b].x)*(po[a].x-po[b].x)+(po[a].y-po[b].y)*(po[a].y-po[b].y)))\n\treturn true;\n\telse return false;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&d);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d\",&po[i].x,&po[i].y);\n        po[i].vis=0;\n    }\n\tinit();\n    char ch[5];\n    int t1,t2;\n    int flag=1;\n    while(scanf(\"%s\",ch)!=EOF){\n        if(ch[0]=='O'){\n            scanf(\"%d\",&t1);\n            po[t1].vis=1;\n            if(flag)\n                flag=0;\n            else{\n                for(int i=1;i<=n;i++)\n                    if(po[i].vis&&i!=t1)\n                    {\n                    \tif(dis(t1,i))to_union(t1,i);\n\t\t\t\t\t}\n            }\n        }\n        else{\n\t\t\tscanf(\"%d%d\",&t1,&t2);\n\t\t\tif(find(t1)==find(t2))puts(\"SUCCESS\");\n\t\t\telse puts(\"FAIL\");\n//            scanf(\"%d%d\",&t1,&t2);\n//            int temp1=find(t1);\n//            int temp2=find(t2);\n//            if(temp1==temp2)\n//                puts(\"SUCCESS\");\n//            else\n//                puts(\"FAIL\");\n        }\n    }\n    return 0;\n}\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"hdu1232","url":"%2F2019%2F08%2F04%2Fhdu1232.html","content":"<p class=\"description\"></p>\nhdu1232,并查集板子题\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1232\n\n## 题意\n\nn个城镇，m条路\n\n提问最少再修多少条路，可以让所有城镇联通\n\n## 细节\n\n并查集模板题，最后城镇的集合数-1就是ans\n\n## 代码\n\n```c++\n#include <vector>\n#include <iostream>\n#include <cstdio>\nusing namespace std; \nvector<int> parent;\nvoid init(int max_size)\n{\n\t// 初始化每一个元素的根节点都为自身\n\tparent.clear();\n\tfor (int i = 0; i <=max_size; ++i)\n\t\tparent.push_back(i);\n}\nint find(int x)\n{\n\treturn parent[x] == x ? x : find(parent[x]);\n}\nvoid to_union(int x1, int x2)\n{\n\tparent[find(x1)] = find(x2);\n}\n    // 判断两个元素是否属于同一个集合\nbool is_same(int e1, int e2)\n{\n\treturn find(e1) == find(e2);\n}\n\nint main()\n{\n\tint n,m;\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tif(n==0)break;\n\t\tinit(n);\n\t\tscanf(\"%d\",&m);\n\t\twhile(m--)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tto_union(a,b);\n\t\t}\n\t\tint i,sum=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tif(find(i)==i)sum++;\n\t\t}\n\t\tprintf(\"%d\\n\",sum-1);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["hdu"]},{"title":"并查集","url":"%2F2019%2F08%2F04%2F%E5%B9%B6%E6%9F%A5%E9%9B%86.html","content":"<p class=\"description\"></p>\n## 并查集（Disjoint-set）\n\n代码简洁，功能强大。\n\n<!-- more -->\n\n## 什么是并查集\n\n对于一个集合S={a1, a2, ..., an-1, an}，我们还可以对集合S进一步划分: S1,S2,...,Sm-1,Sm，我们希望能够快速确定S中的两两元素是否属于S的同一子集。\n 举个栗子，S={0,1,2,3,4,5,6}，如果我们按照一定的规则对集合S进行划分,假设划分后为S1={1,2,4}, S2={3,6}，S3={0,5}，任意给定两个元素，我们如何确定它们是否属于同一子集？某些合并子集后，又如何确定两两关系？基于此类问题便出现了并查集这种数据结构。\n 并查集有两个基本操作：\n\n- Find: 查找元素所属子集\n- Union：合并两个子集为一个新的集合\n\n## 并查集的基本结构\n\n我们可以使用树这种数据结构来表示集合，不同的树就是不同的集合，并查集中包含了多棵树，表示并查集中不同的子集，树的集合是**森林**，所以并查集属于森林。\n若集合S={0, 1, 2, 3, 4, 5, 6}，最初每一个元素都是一棵树。\n\n![img](并查集\\5970830-e240c2c558867f5f.webp)\n\n对于`Union`操作，我们只需要将两棵树合并，例如合并0、1、2得到S1={0, 1, 2},合并3和4得到S2={3, 4}\n\n![img](并查集\\5970830-6e9c9c2aa9ae025d.webp)\n\n对于`Find`操作，我们只需要返回该元素所在树的根节点。所以，如果我们想要比较判断1和2是否在一个集合，只需要通过Find(1)和Find(2)返回各自的根节点比较是否相等便可。已知树中的一个节点，找到其根节点的时间复杂度为`O(D)`，D为节点的深度。\n我们可以使用数组来表示树，数组下标表示树的一个节点，该下表所对应的值表示树的父节点。例如`P[i]`表示元素`i`的父节点。对于图2中的集合，我们可以存储在下面的数组中（第二行为数组下标）\n\n|  0   |  0   |  0   |  3   |  3   |  5   |  6   |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  0   |  1   |  2   |  3   |  4   |  5   |  6   |\n\n**对于树的根节点，我们规定其元素值为其本身（即父节点为自己）。**\n\n## 代码\n\n我们使用一个parent数组存储树，先实现未经优化的版本。\n对于`Find`操作，代码非常简单\n\n```c++\nint find(int x)\n{\n    return parent[x] == x ? x : find(parent[x]);\n}\n```\n\n该代码比较元素x的父节点parent[x]是否等于x自身，如果是便说明找到了根节点（根节点的父节点是自身），直接返回；否则，把x的父节点parent[x]传入find，直到找到根节点。\n下面是`union`操作\n\n```c++\nvoid to_union(int x1, int x2) \n{\n    int p1 = find(x1);\n    int p2 = find(x2);\n    parent[p1] = p2;\n}\n```\n\n传入两个元素，分别找到根节点，使根节点p1的父节点为p2，即将p1为根节点的这棵树合并到p2为根节点的树上。\n下面是完整代码：(hdu1232)\n\n```c++\n#include <vector>\n#include <iostream>\n#include <cstdio>\nusing namespace std; \nvector<int> parent;\nvoid init(int max_size)\n{\n\t// 初始化每一个元素的根节点都为自身\n\tparent.clear();\n\tfor (int i = 0; i <=max_size; ++i)\n\t\tparent.push_back(i);\n}\nint find(int x)\n{\n\treturn parent[x] == x ? x : find(parent[x]);\n}\nvoid to_union(int x1, int x2)\n{\n\tparent[find(x1)] = find(x2);\n}\n    // 判断两个元素是否属于同一个集合\nbool is_same(int e1, int e2)\n{\n\treturn find(e1) == find(e2);\n}\n\nint main()\n{\n\tint n,m;\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tif(n==0)break;\n\t\tinit(n);\n\t\tscanf(\"%d\",&m);\n\t\twhile(m--)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tto_union(a,b);\n\t\t}\n\t\tint i,sum=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tif(find(i)==i)sum++;\n\t\t}\n\t\tprintf(\"%d\\n\",sum-1);\n\t}\n}\n```\n\n上面的实现，可以看出每一次Find操作的时间复杂度为`O(H)`，H为树的高度，由于我们没有对树做特殊处理，所以树的不断合并可能会使树严重不平衡，最坏情况每个节点都只有一个子节点，如下图3（第一个点为根节点）\n\n![img](并查集\\5970830-5e6d6e9f91b85c3b.webp)\n\n此时Find操作的时间复杂度为`O(n)`，这显然不是我们想要的。下面引入两个优化的方法。\n\n优化\n\n方法一\n\n\"按秩合并\"。实际上就是在合并两棵树时，将高度较小的树合并到高度较大的树上。这里我们使用“秩”(rank)代替高度，秩表示高度的上界，通常情况我们令只有一个节点的树的秩为0，严格来说，rank + 1才是高度的上界；两棵秩分别为r1、r2的树合并，如果秩不相等，我们将秩小的树合并到秩大的树上，这样就能保证新树秩不大于原来的任意一棵树。如果r1与r2相等，两棵树任意合并，并令新树的秩为r1 + 1。\n\n方法二\n\n“路径压缩”。在执行Find的过程中，将路径上的所有节点都直接连接到根节点上。\n\n![img](并查集\\5970830-44d64a584dd736e2.webp)\n\n下面是采用”按秩合并”与“路径压缩”两中优化算法的实现。\n\n```c++\n#include <vector>\n#include <iostream>\n#include <cstdio>\nusing namespace std; \nvector<int> parent;\nvector<int> rank;\nvoid init(int max_size)\n{\n\t// 初始化每一个元素的根节点都为自身\n\tparent.clear();\n\trank.clear();\n\tfor (int i = 0; i <=max_size; ++i)\n\t\t{\n\t\t\tparent.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n}\n\nint find(int x)\n{\n    return x == parent[x] ? x : (parent[x] = find(parent[x]));\n}\n\nvoid to_union(int x1, int x2)\n{\n\tint f1 = find(x1);\n\tint f2 = find(x2);\n\tif (rank[f1] > rank[f2])\n\t\tparent[f2] = f1;\n    else\n        {\n            parent[f1] = f2;\n            if (rank[f1] == rank[f2])\n                ++rank[f2];\n        }\n}\n\nbool is_same(int e1, int e2)\n{\n\treturn find(e1) == find(e2);\n}\n\nint main()\n{\n\tint n,m;\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tif(n==0)break;\n\t\tinit(n);\n\t\tscanf(\"%d\",&m);\n\t\twhile(m--)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tto_union(a,b);\n\t\t}\n\t\tint i,sum=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tif(find(i)==i)sum++;\n\t\t}\n\t\tprintf(\"%d\\n\",sum-1);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["并查集"],"categories":["algorithm"]},{"title":"Prim","url":"%2F2019%2F08%2F04%2FPrim.html","content":"<p class=\"description\"></p>\n## Prim算法\n\n最小生成树之Prim算法。\n\n**最小生成树(Minimum Cost Spanning Tree)** 即构造连通图的最小代价生成树\n\n思想与dijstra差不多，因此复杂度也一样。\n\n复杂度：O（N²）\n\n堆优化：O（ElogN）\n\n<!-- more -->\n\n待施工，觉得先写并查集更好\n\n<hr />\n","tags":["Prim"],"categories":["algorithm"]},{"title":"lightoj1074","url":"%2F2019%2F08%2F04%2Flightoj1074.html","content":"<p class=\"description\"></p>\nlightoj1074,SPFA求负环\n\n<!-- more -->\n\n## 题目链接\n\nhttps://vjudge.net/problem/LightOJ-1074\n\n## 题意\n\n有n个城市，每一个城市有一个拥挤度ai，从一个城市I到另一个城市J的时间为:(aJ-aI)^3，存在负环。问从第一个城市到达第k个城市所话的时间，如果不能到达，或者时间小于3输出？否则输出所花的时间\n\n## 细节\n\nspfa找出的所有的负环，把所有负环能到的点都标记一下\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <stack>\nusing namespace std;\nconst int N = 209;\nconst int INF = 0x3f3f3f3f;\nint n,re[N],m;\nstruct LT{\n    int to,nex;\n} L[N*N];\nint F[N],cnt;\nvoid add(int f,int t)\n{\n    L[cnt].nex = F[f];\n    L[cnt].to = t;\n    F[f] = cnt++;\n}\nint que[N*N];\nint coun[N],cir[N],dis[N],inque[N];\nint getdis(int i,int j)\n{\n    int t = re[j] - re[i];\n    return t*t*t;\n}\nvoid dfs(int k)\n{\n    cir[k] = 1;\n    for(int i=F[k];i;i=L[i].nex)\n    {\n        if(!cir[L[i].to])\n        dfs(L[i].to);\n    }\n}\nvoid solve()\n{\n    memset(coun,0,sizeof(coun));\n    memset(cir,0,sizeof(cir));\n    memset(inque,0,sizeof(inque));\n    int front = 0, rear = 0;\n    que[rear++] = 1;\n    memset(dis,INF,sizeof(dis));\n    dis[1] = 0;\n    while(rear>front)\n    {\n        int e = que[front++] ;\n        inque[e] = false;\n        coun[e]++;\n        if(coun[e]>=n)\n        {\n            dfs(e);\n        }\n        for(int i=F[e];i;i=L[i].nex)\n        {\n            int to = L[i].to;\n            if(cir[to]) continue;\n            int k = getdis(e,to);\n            if(dis[to]>dis[e]+k)\n            {\n                dis[to] = dis[e] + k;\n                if(!inque[to])\n                {\n                    if(coun[to]>(n>>1)&&front>0)\n                    que[--front] = to;\n                    else\n                    que[rear++] = to;\n                    inque[to] = true;\n                }\n            }\n        }\n    }\n    scanf(\"%d\",&m);\n    int a;\n    while(m--)\n    {\n        scanf(\"%d\",&a);\n        if(cir[a]||dis[a]<3||dis[a]==INF)\n        printf(\"?\\n\");\n        else printf(\"%d\\n\",dis[a]);\n    }\n}\nint main()\n{\n    int cas,T=1;\n    scanf(\"%d\",&cas);\n    while(cas--)\n    {\n        memset(F,0,sizeof(F));cnt = 1;\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++) scanf(\"%d\",&re[i]);\n        scanf(\"%d\",&m);\n        int a,b;\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            add(a,b);\n        }\n        printf(\"Case %d:\\n\",T++);\n        solve();\n    }\n    return 0;\n}\n```\n\n\n\n<hr />\n","tags":["lightoj"],"categories":["lightoj"]},{"title":"hdu4370","url":"%2F2019%2F08%2F03%2Fhdu4370.html","content":"<p class=\"description\"></p>\nhdu4370,建图转化 + 最短路径。\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4370\n\n## 题意\n\n给定一个 n*n 的矩阵 C，构造一个符合以下条件的矩阵 X：\n\n![1564895169459](hdu4370\\1564895169459.png)\n\n## 细节\n\n将条件转化为图论最短路径问题，Xij 转化为边 i→j 的权值，那么对应关系为：\n\n- 表示点 1 的出度为 1\n- 表示点 n 的入度为 1\n- 除了点 1 和点 n 外的其他点出入度相等\n\n求解的问题转化为点 1 到点 n 的一条最短路径。\n\n其实还有一种情况，那就是可以从点 1 出发到达其他点然后又回到点 1 形成一个环，同样也可以从点 n 出发回到点 n。这样也是符合条件的，答案为从 1 出发的最小权值环和从 n 出发的最小权值环之和。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <iostream>\n#define inf 1e9+5\n#define maxn 310\nusing namespace std;\n\nint dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint out[maxn];\nint k,n;\nint e[maxn][maxn];\n\nvoid spfa(int x)\n{\n\tmemset(vis,false,sizeof(vis));\n\tqueue <int>q;\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(i==x)dis[i]=inf;\n\t\telse \n\t\t{\n\t\t\tdis[i]=e[x][i];\n\t\t\tq.push(i);\n\t\t\tvis[i]=true;\n\t\t}\n\t}\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tif(dis[i]>dis[u]+e[u][i])\n\t\t\t\t{\n\t\t\t\t\tdis[i] = dis[u] + e[u][i];\n\t                if (!vis[i])\n\t                {\n\t                    vis[i] = true;\n\t                    q.push(i);\n\t                }\n\t\t\t\t}\n\t\t\t\tvis[u]=false;\n\t\t\t}\n\t}\n}\n\n\n\nvoid init()\n{\n\tk=1;\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\n\nint min(int x,int y)\n{\n\tif(x>y)return y;\n\telse return x;\n}\n\nint main()\n{\n\tint i,j,x,y,z;\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&z);\n\t\t\t\te[i][j]=z;\n\t\t\t}\n\t\t}\n\t\t//init();\n\t\tspfa(1);\n\t\tint ans = dis[n];\n\t\tint cir1 = dis[1]; // 简单最短路径，“环1”\n\t\t//init();\n\t    spfa(n);\n\t    int cirn = dis[n]; // \"环n\"\n\t    ans = min(ans, cir1 + cirn); // \"环1+环n\" 与简单最短路径最小值\n\t    printf(\"%d\\n\", ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["spfa"],"categories":["hdu"]},{"title":"poj3169","url":"%2F2019%2F08%2F03%2Fpoj3169.html","content":"<p class=\"description\"></p>\npoj3169,单源最短路，SPFA，差分约束\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3169\n\n## 题意\n\n一个农夫有n头牛，他希望将这些牛按照编号 1～n排成一条直线，允许有几头牛站在同一点，但是必须按照顺序，有一些牛关系比较好，希望站的距离不超过某个值，而有一些牛关系不太好，所以希望站的距离大于等于某个值，问1号牛和n号牛之间的最远距离是多少。\n\n## 细节\n\n差分约束的裸题，对于 d[v] - d[u] ≤ w 建立权值为 w 的单向边 e(u,v)，对于 d[v] - d[u]  ≥ w 建立权值为 -w 的单向边 e(v,u)，然后再根据牛必须按顺序排列建立权值为 0 的边 e(i+1,i)，然后最短路就行了。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <iostream>\n#define inf 1e9+5\n#define maxn 1000005\nusing namespace std;\n\nstruct node\n{\n\tint v,w,next;\n}edge[maxn];\n\nint dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint out[maxn];\nint k,n,m,s;\nvoid adde(int u,int v,int w)\n{\n\tedge[k].v=v;\n\tedge[k].w=w;\n\tedge[k].next=first[u];\n\tfirst[u]=k++;\n}\n\nvoid spfa(int x)\n{\n\tqueue <int>q;\n\tq.push(x);\n\tvis[x]=true;\n\tdis[x]=0;\n\tint i;\n\tint flag=0;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tout[u]++;\n\t\tif(out[u]>n)\n\t\t{\n\t\t\tflag=1;break;\n\t\t}\n\t\tq.pop();\n\t\tvis[u]=false;\n\t\tfor(i=first[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(dis[v]>dis[u]+w)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tif(!vis[v])\n\t\t\t\t{\n\t\t\t\t\tq.push(v);\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(flag==1)printf(\"-1\\n\");\n\telse if(dis[n]==inf)printf(\"-2\\n\");\n\telse printf(\"%d\",dis[n]);\n}\n\nvoid init()\n{\n\tk=1;\n\tmemset(first,0,sizeof(first));\n\tmemset(edge,0,sizeof(edge));\n\tmemset(out,0,sizeof(out));\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\n\nint main()\n{\n\tint i,j;\n\twhile(scanf(\"%d%d%d\",&n,&m,&s)!=EOF)\n\t{\n\t\tinit();\n\t\tint x,y,z;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tadde(x,y,z);\n\t\t}\n\t\tfor(i=1;i<=s;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tadde(y,x,-z);\n\t\t}\n\t\tspfa(1);\n\t}\n\t\t\n}\n```\n\n\n\n<hr />\n","tags":["spfa"],"categories":["poj"]},{"title":"poj1847","url":"%2F2019%2F08%2F03%2Fpoj1847.html","content":"<p class=\"description\"></p>\npoj1847，怪问题，最简单的最短路教做人，什么叫真正的自闭。\n\n\n\n![](http://pv35325dx.bkt.clouddn.com/8.3.2.png)\n\n\n\n<!-- more -->\n\n![](http://pv35325dx.bkt.clouddn.com/8.3.1.png)\n\n就这破题我debug了一个半小时！\n\n## 题目链接\n\nhttp://poj.org/problem?id=1847\n\n## 题意\n\n现在有一铁路网络，有n个交叉点，和一些开关。通过开关可以改变路线方向，使其能驶向其他交叉点。开关的初始状态已知，即（初始直接某两点直接相连）。问从出发点到目的地最少要动多少开关才能到达。\n\n```c++\n    3 2 1     3表示共有n个点，接下来有n行，2表示起点，1表示终点\n    2 2 3     第一个数2表示后面有2个数，因为这是第1行，所以后面两个数表示从1到2和从1到3的边\n    2 3 1     表示从2到3和从2到1的边\n    2 1 2     表示从3到1和从3到2的边\n```\n\n## 细节\n\n不用开关的边权值置0，用开关的边权值置1，问题迎刃而解。\n\n就随手写了个dijstra，想着N就100随便过了。然后提交，TLE？？？？思考了一下觉得可能是输入有问题，经过仔细读题，哦题目读错了不要紧（心态平静），然后重写了一下。\n\n然后就坠入WA的地狱了Orz......\n\n排查一个多小时，发现不在函数里输入就会WA（？？？why！！！！？？？？）\n\n心态大崩。\n\n## 代码\n\nWA的版本：\n\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#define inf 0x3f3f3f3f\nusing namespace std;\nint g[110][110];\nint dis[110];\nbool vis[110];\nint n,a,b;\nvoid dijstra()\n{\n//\tmemset(vis,false,sizeof(vis));\n//\tint i,j;\n//\tfor(i=1;i<=n;i++)\n//\t{\n//\t\tdis[i]=e[f][i];\n//\t}\n//\tvis[f]=true;\n//\t\n//\tfor(i=1;i<n;i++)\n//\t{\n//\t\tint min=inf;\n//\t\tint temp;\n//\t\tfor(j=1;j<=n;j++)\n//\t\t{\n//\t\t\tif(dis[j]<min&&!vis[j])\n//\t\t\t{\n//\t\t\t\ttemp=j;\n//\t\t\t\tmin=dis[j];\n//\t\t\t}\n//\t\t}\n//\t\tvis[temp]=true;\n//\t\tint v;\n//\t\tfor(v=1;v<=n;v++)\n//\t\t{\n//\t\t\tif(e[temp][v]<inf)\n//\t\t\t{\n//\t\t\t\tif(!vis[v]&&dis[temp]+e[temp][v]<dis[v])\n//\t\t\t\tdis[v]=dis[temp]+e[temp][v];\n//\t\t\t}\n//\t\t}\n//\t}\n\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tdis[i]=g[a][i];\n\t\t\tvis[i]=false;\n\t\t} \n\t    vis[a]=true;\n\t    for(int k=1;k<n;k++){\n\t        int mind=inf,j;\n\t        for(int i=1;i<=n;i++)\n\t            if(!vis[i] && dis[i]<mind) mind=dis[i],j=i;\n\t        vis[j]=1;\n\t        for(int i=1;i<=n;i++)\n\t            if(!vis[i] && dis[j]+g[j][i]<dis[i]) dis[i]=dis[j]+g[j][i];\n\t    }\n\tif(dis[b]<inf) cout<<dis[b]<<endl;\n    else cout<<-1<<endl;\n}\n\nint main()\n{\n//\tint i,j;\n//\tscanf(\"%d%d%d\",&n,&a,&b);\n//\tfor(i=0;i<=n;i++)\n//\t{\n//\t\tfor(j=0;j<=n;j++)\n//\t\t{\n//\t\t\te[i][j]=inf; \n//\t\t}\n//\t}\n\t\n//\tfor(i=1;i<=n;i++)\n//\t{\n//\t\tint k,m;\n//\t\tscanf(\"%d%d\",&k,&m);\n//\t\te[i][m]=0;\n//\t\tfor(j=1;j<k;j++)\n//\t\t{\n//\t\t\tscanf(\"%d\",&m);\n//\t\t\te[i][m]=1;\n//\t\t}\n//\t}\n\tcin>>n>>a>>b;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=n;j++)\n            g[i][j]=inf;\n    for(int i=1;i<=n;i++)\n\t{\n        int k,m;\n\t\tcin>>k>>m;g[i][m]=0;\n        for(int j=1;j<k;j++)\n\t\t{\n            cin>>m;\n\t\t\tg[i][m]=1;\n        }\n    }\n\tdijstra();\n}\n```\n\n\n\nAC版本：\n\n```c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n#define inf 0x3f3f3f3f\nint g[110][110];\nint d[110],vis[110];\nint n,a,b;\nvoid dij(){\n    cin>>n>>a>>b;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=n;j++)\n            g[i][j]=inf;\n    for(int i=1;i<=n;i++)\n\t{\n        int k,m;\n\t\tcin>>k>>m;g[i][m]=0;\n        for(int j=1;j<k;j++)\n\t\t{\n            cin>>m;\n\t\t\tg[i][m]=1;\n        }\n    }\n    for(int i=1;i<=n;i++)\n\t{\n\t\td[i]=g[a][i];\n\t\tvis[i]=false;\n\t} \n    vis[a]=true;\n    for(int k=1;k<n;k++){\n        int mind=inf,j;\n        for(int i=1;i<=n;i++)\n            if(!vis[i] && d[i]<mind) mind=d[i],j=i;\n        vis[j]=1;\n        for(int i=1;i<=n;i++)\n            if(!vis[i] && d[j]+g[j][i]<d[i]) d[i]=d[j]+g[j][i];\n    }\n    if(d[b]<inf) cout<<d[b]<<endl;\n    else cout<<-1<<endl;\n}\n/*struct edge{\n    int u,v,w;\n}e[10010];\nvoid bellford(){\n    cin>>n>>a>>b; a--; b--; int t=-1;\n    for(int i=0;i<n;i++){\n        int k,m; cin>>k>>m; e[++t].u=i; e[t].v=--m; e[t].w=0;\n        for(int j=1;j<k;j++){\n            cin>>m; e[++t].u=i; e[t].v=--m; e[t].w=1;\n        }\n    }\n    for(int i=0;i<n;i++) d[i]=inf;\n    d[a]=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<=t;j++){\n            if(d[ e[j].u ]+e[j].w < d[ e[j].v ]) d[ e[j].v ]=d[ e[j].u ]+e[j].w;\n        }\n    }\n    if(d[b]<inf) cout<<d[b]<<endl;\n    else cout<<-1<<endl;\n}*/\n#define N 110\n//struct Edge{\n//    int v,w;\n//}e[N*N];\n//int root[N];\n//int next[N*N];\n//void spfa(){\n//    queue<int> q;\n//    cin>>n>>a>>b; a--; b--; int m=-1;\n//    for(int i=0;i<n;i++) root[i]=-1;\n//    for(int i=0;i<n;i++){\n//        int k,y; cin>>k;\n//        for(int j=0;j<k;j++){\n//            cin>>y;\n//            e[++m].v=--y;\n//            e[m].w=(j||0);\n//            next[m]=root[i];\n//            root[i]=m;\n//        }\n//    }\n//    for(int i=0;i<n;i++) d[i]=inf,vis[i]=0;\n//    d[a]=0;\n//    q.push(a);\n//    while(!q.empty()){\n//        int t=q.front();\n//        q.pop(); vis[t]=0;\n//        for(int i=root[t]; i!=-1; i=next[i]){\n//            if( d[t]+e[i].w < d[ e[i].v ] ){\n//                d[ e[i].v ]=d[t]+e[i].w;\n//                if(!vis[ e[i].v ]){\n//                    q.push(e[i].v); vis[ e[i].v ]=1;\n//                }\n//            }\n//        }\n//    }\n//    if(d[b]<inf) cout<<d[b]<<endl;\n//    else cout<<-1<<endl;\n//}\nint main()\n{\n    dij();\n    //bellford();\n//    spfa();\n    return 0;\n}\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj2502","url":"%2F2019%2F08%2F02%2Fpoj2502.html","content":"<p class=\"description\"></p>\npoj2502,单源最短路，时间代替最短路\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2502\n\n## 题意\n\n第一行两个坐标分别是家的坐标和学校的坐标。\n\n接下来每行代表一条地铁线路。相邻两站是联通的。-1-1代表该线结束。\n\n各个坐标间也可以选择步行。步行10km/h，地铁40km/h。\n\n求从家到学校所花的最少分钟数。\n\n## 细节\n\n输入构图麻烦。地铁相邻两站才是联通的，所以地铁站边输入边构图。\n\n还需要注意小时换成分钟数。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#define maxn 500\n#define inf 99999999\nusing namespace std;\n\nstruct node\n{\n\tdouble x,y;\n}n[maxn];\n\ndouble e[maxn][maxn];\n\ndouble dis[maxn];\nbool vis[maxn];\nint sum;\nvoid dijstra(int x)\n{\n\tmemset(vis,false,sizeof(vis));\n\tint i,j,temp;\n\tfor(i=1;i<=sum;i++)\n\tdis[i]=e[1][i];\n\tvis[x]=true;\n\tfor(i=1;i<=sum-1;i++)\n\t{\n\t\tint min=inf;\n\t\tfor(j=1;j<=sum;j++)\n\t\t{\n\t\t\tif(vis[j]==false&&dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tvis[temp]=true;\n\t\tint v;\n\t\tfor(v=1;v<=sum;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[temp]+e[temp][v]<dis[v])\n\t\t\t\t\tdis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i,j,flag;\n\tfor(i=0;i<maxn;i++)\n\tfor(j=0;j<maxn;j++)\n\t\t{\n\t\t\te[i][j]=inf;\n\t\t\tif(i==j)e[i][j]=0;\n\t\t}\n\tscanf(\"%lf%lf\",&n[1].x,&n[1].y);\n\tscanf(\"%lf%lf\",&n[2].x,&n[2].y);\n\ti=3,flag=1;\n\twhile(scanf(\"%lf%lf\",&n[i].x,&n[i].y)!=EOF)\n\t{\n\t\tif(flag==1)\n\t\t{\n\t\t\ti++;\n\t\t\tflag=0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(n[i].x==-1&&n[i].y==-1)\n\t\t{\n\t\t\tflag=1;\n\t\t\tcontinue;\n\t\t}\n\t\te[i][i-1]=sqrt((n[i].x-n[i-1].x)*(n[i].x-n[i-1].x)+(n[i].y-n[i-1].y)*(n[i].y-n[i-1].y))/40000.0*60;\n\t\te[i-1][i]=e[i][i-1];\n\t\ti++;\n\t}\n\tsum=i-1;\n\tint k;\n\tfor(j=1;j<i;j++)\n\t{\n\t\tfor(k=j+1;k<i;k++)\n\t\t{\n\t\t\tif(e[j][k]==inf)\n\t\t\t{\n\t\t\t\te[j][k]=sqrt((n[k].x-n[j].x)*(n[k].x-n[j].x)+(n[k].y-n[j].y)*(n[k].y-n[j].y))/10000.0*60;\n\t\t\t\te[k][j]=e[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tdijstra(1);\n\tprintf(\"%d\",(int)(dis[2]+0.5));\n}\n\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj3159","url":"%2F2019%2F08%2F02%2Fpoj3159.html","content":"<p class=\"description\"></p>\npoj3159，差分约束，单源最短路，dijstra堆优化，前向星存图\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3159\n\n## 题意\n\nn个点，m条边\n\n接下来m行告诉你a，b，c\n\nb比a最多多c个糖果（b-a<=c）\n\n问n最多比1多多少个糖果\n\n## 细节\n\n就是普通的单源最短路，修改一下判断条件就好。\n\n看了眼别人的吐槽：用spfa+queue超时..得改用stack，用刘汝佳的紫书上的dijkstra+优先队列模板也会超时，要改用数组实现的邻接表可以过。\n\n得，直接上前向星堆优化dijstra。\n\n以后考虑用spfa再写一下看看。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define inf 1e10+5\n#define maxn 1000005\nusing namespace std;\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;\nstruct node\n{\n\tint v,w,next;\n}edge[maxn];\nlong long int dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint a[maxn],b[maxn],c[maxn];\nint k,n,m,s;\nvoid adde(int u,int v,int w)\n{\n\tedge[k].v=v;\n\tedge[k].w=w;\n\tedge[k].next=first[u];\n\tfirst[u]=k++;\n}\n\nvoid init()\n{\n\tk=1;\n\tmemset(first,0,sizeof(first));\n\tmemset(edge,0,sizeof(edge));\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\nlong long dijstra(int x)\n{\n\tint i;\n\tdis[x]=0;\n\tq.push(make_pair(dis[x],x));\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top().second;\n\t\tq.pop();\n\t\tif(vis[u]==true)continue;\n\t\tvis[u]=true;\n\t\tfor(i=first[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(!vis[v]&&dis[v]-dis[u]>w)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tq.push(make_pair(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tint i;\n\ts=1;\n\tinit();\n\tint x,y,z;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tadde(x,y,z);\n\t}\n\tdijstra(s);\n\tprintf(\"%d\",dis[n]);\n} \n```\n\n\n\n<hr />\n","tags":["spfa"],"categories":["poj"]},{"title":"P4779","url":"%2F2019%2F08%2F02%2FP4779.html","content":"<p class=\"description\"></p>\n洛谷P4779，单源最短路，dijstra堆优化\n\n标准dijstra堆优化模板\n\n<!-- more -->\n\n## 题目链接\n\nhttps://www.luogu.org/problem/P4779\n\n## 题意\n\n给定一个 N个点，M条有向边的带非负权图，请你计算从 S出发，到每个点的距离。\n\n输入：\n\n第一行为三个正整数N，M，S。 第二行起 M行，每行三个非负整数ui，vi，wi，表示从ui到vi有一条权值为 wi的边。\n\n## 细节\n\n看题目背景感觉小F好惨，以前一直觉得要是我参加过noi就好了，现在觉得打noi的孩子也是不容易。\n\n这题数据蛮大，用普通dijstra应该会TLE。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define inf 1e10+5\n#define maxn 1000005\nusing namespace std;\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;\nstruct node\n{\n\tint v,w,next;\n}edge[maxn];\nlong long int dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint a[maxn],b[maxn],c[maxn];\nint k,n,m,s;\nvoid adde(int u,int v,int w)\n{\n\tedge[k].v=v;\n\tedge[k].w=w;\n\tedge[k].next=first[u];\n\tfirst[u]=k++;\n}\n\nvoid init()\n{\n\tk=1;\n\tmemset(first,0,sizeof(first));\n\tmemset(edge,0,sizeof(edge));\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\nlong long dijstra(int x)\n{\n\tint i;\n\tdis[x]=0;\n\tq.push(make_pair(dis[x],x));\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top().second;\n\t\tq.pop();\n\t\tif(vis[u]==true)continue;\n\t\tvis[u]=true;\n\t\tfor(i=first[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(!vis[v]&&dis[v]>dis[u]+w)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tq.push(make_pair(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&s);\n\tint i;\n\tinit();\n\tint x,y,z;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tadde(x,y,z);\n\t}\n\tdijstra(s);\n\tfor(i=1;i<n;i++)\n\tprintf(\"%d \",dis[i]);\n\tprintf(\"%d\",dis[i]);\n} \n```\n\n\n\n<hr />\n","tags":["洛谷"],"categories":["洛谷"]},{"title":"priority_queue","url":"%2F2019%2F08%2F01%2Fpriority-queue.html","content":"<p class=\"description\"></p>\n## 优先队列（priority_queue）\n\n优先队列是什么呢？\n\n说白了，就是一种功能强大的队列。\n\n强大在于**自动排序**。\n\n原文：https://blog.csdn.net/c20182030/article/details/70757660 \n\n<!-- more -->\n\n优先队列也是队列，所以在头文件queue中。\n\n一个优先队列声明的基本格式是：\n\n**priority_queue<结构类型> 队列名;**\n\n例如：\n\n```c++\npriority_queue <int> i;\npriority_queue <double> d;\n```\n\n但是常用的是这样：\n\n```c++\npriority_queue <node> q;\n//node是一个结构体\n//结构体里重载了‘<’小于符号\npriority_queue <int,vector<int>,greater<int> > q;\n//不需要#include<vector>头文件\n//注意后面两个“>”不要写在一起，“>>”是右移运算符\npriority_queue <int,vector<int>,less<int> >q;\n```\n\n\n\n## 优先队列的基本操作\n\n与队列操作基本一致。\n\n以一个名为q的优先队列为例。\n\n```\nq.size();//返回q里元素个数\nq.empty();//返回q是否为空，空则返回1，否则返回0\nq.push(k);//在q的末尾插入k\nq.pop();//删掉q的第一个元素\nq.top();//返回q的第一个元素\n```\n\n\n\n## 优先队列的特性\n\n**自动排序**\n\n如何排？\n\n#### 默认优先队列（非结构体结构）\n\n```c++\npriority_queue <int> q;\n```\n\n```\n#include<cstdio>\n#include<queue>\nusing namespace std;\npriority_queue <int> q;\nint main()\n{\n\tq.push(10),q.push(8),q.push(12),q.push(14),q.push(6);\n\twhile(!q.empty())\n\t\tprintf(\"%d \",q.top()),q.pop();\n}\n```\n\n程序大意就是在这个优先队列里依次插入10、8、12、14、6，再输出。\n\n结果是什么呢？\n\n14 12 10 8 6\n\n也就是说默认是**从大到小**排序的。\n\n\n\n#### 默认的优先队列（结构体，重载小于）\n\n```c++\nstruct node\n{\n\tint x,y;\n\tbool operator < (const node & a) const\n\t{\n\t\treturn x<a.x;\n\t}\n};\n```\n\n这个node结构体有两个成员，x和y，它的小于规则是x小者小。\n\n验证程序：\n\n```c++\n#include<cstdio>\n#include<queue>\nusing namespace std;\nstruct node\n{\n\tint x,y;\n\tbool operator < (const node & a) const\n\t{\n\t\treturn x<a.x;\n\t}\n}k;\npriority_queue <node> q;\nint main()\n{\n\tk.x=10,k.y=100; q.push(k);\n\tk.x=12,k.y=60; q.push(k);\n\tk.x=14,k.y=40; q.push(k);\n\tk.x=6,k.y=80; q.push(k);\n\tk.x=8,k.y=20; q.push(k);\n\twhile(!q.empty())\n\t{\n\t\tnode m=q.top(); q.pop();\n\t\tprintf(\"(%d,%d) \",m.x,m.y);\n\t}\n}\n```\n\n程序大意就是插入(10,100),(12,60),(14,40),(6,20),(8,20)这五个node。\n\n输出为：\n\n(14,40) (12,60) (10,100) (8,20) (6,80)\n\n它也是按照**重载后的小于规则**，从大到小排序的。\n\n\n\n#### less和greater优先队列\n\n还是以int为例，先来声明：\n\n```c++\npriority_queue <int,vector<int>,less<int> > p;\npriority_queue <int,vector<int>,greater<int> > q;\n```\n\n再次强调：“`>`”不要两个拼在一起。\n\n验证程序：\n\n```\n#include<cstdio>\n#include<queue>\nusing namespace std;\npriority_queue <int,vector<int>,less<int> > p;\npriority_queue <int,vector<int>,greater<int> > q;\nint a[5]={10,12,14,6,8};\nint main()\n{\n\tfor(int i=0;i<5;i++)\n\t\tp.push(a[i]),q.push(a[i]);\n\t\t\n\tprintf(\"less<int>:\")；\n\twhile(!p.empty())\n\t\tprintf(\"%d \",p.top()),p.pop();\t\n\t\t\n\tprintf(\"\\ngreater<int>:\")；\n\twhile(!q.empty())\n\t\tprintf(\"%d \",q.top()),q.pop();\n}\n```\n\n结果：\n\nless<int>:14 12 10 8 6 \n\ngreater<int>:6 8 10 12 14\n\n所以从结果可以知道：**less是从大到小，greater是从小到大**。\n\n\n\n### 总结\n\n平时最好写：\n\n```c++\npriority_queue<int,vector<int>,less<int> >q;\npriority_queue<int,vector<int>,greater<int> >q;\n```\n\n这样两种写法都可以记住。\n\n\n\n### 拓展\n\n如果想把一个队列按不同的方式优先，就要：\n\n```c++\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n;\nstruct node\n{\n\tint fir,sec;\n\tvoid Read() {scanf(\"%d %d\",&fir,&sec);}\n}input;\n\nstruct cmp1\n{\n\tbool operator () (const node &x,const node &y) const\n\t{\n\t\treturn x.fir<y.fir;\n\t}\n};//当一个node x的fir值小于另一个node y的fir值时，称x<y\n\nstruct cmp2\n{\n\tbool operator () (const node &x,const node &y) const\n\t{\n\t\treturn x.sec<y.sec;  \n\t}\n};//当一个node x的sec值小于另一个node y的sec值时，称x<y\n\nstruct cmp3\n{\n\tbool operator () (const node &x,const node &y) const\n\t{\n\t\treturn x.fir+x.sec<y.fir+y.sec; \n\t}\n};//当一个node x的fri值和sec值的和小于另一个node y的fir值和sec值的和时，称x<y\n\npriority_queue<node,vector<node>,cmp1> q1;\npriority_queue<node,vector<node>,cmp2> q2;\npriority_queue<node,vector<node>,cmp3> q3;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) input.Read(),q1.push(input),q2.push(input),q3.push(input);\n\t\n\tprintf(\"\\ncmp1:\\n\");\n\twhile(!q1.empty()) printf(\"(%d,%d) \",q1.top().fir,q1.top().sec),q1.pop();\t\n\t\t\n\tprintf(\"\\n\\ncmp2:\\n\");\n\twhile(!q2.empty()) printf(\"(%d,%d) \",q2.top().fir,q2.top().sec),q2.pop();\t\n\t\t\n\tprintf(\"\\n\\ncmp3:\\n\");\n\twhile(!q3.empty()) printf(\"(%d,%d) \",q3.top().fir,q3.top().sec),q3.pop();\t\n}\n```\n\n读入：\n\n```c++\n7\n1 2\n2 1\n6 9\n9 6\n-100 100\n-500 20\n4000 -3000\n```\n\n输出：\n\n```c++\ncmp1:\n(4000,-3000) (9,6) (6,9) (2,1) (1,2) (-100,100) (-500,20)\n\ncmp2:\n(-100,100) (-500,20) (6,9) (9,6) (1,2) (2,1) (4000,-3000)\n\ncmp3:\n(4000,-3000) (6,9) (9,6) (1,2) (2,1) (-100,100) (-500,20)\n```\n\n\n\n<hr />\n","tags":["STL"],"categories":["STL"]},{"title":"poj1511","url":"%2F2019%2F07%2F31%2Fpoj1511.html","content":"<p class=\"description\"></p>\npoj1511，双向最短路，数据较大，需要SPFA或dijstra堆优化\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1511\n\n## 题意\n\nT组数据。\n\n每组第一行n,m代表有n个点，m条单向边\n\n之后m行告诉你每条边a到b的距离w。\n\n求1到其余各点的最短路径和+其余各点到1的最短路径和。\n\n## 细节\n\n数据很大，最后结果需要longlong存放。\n\n前向星存图。\n\nmemset不能初始化dis为inf。通常只能初始化为0或1。\n\n## 代码\n\n#### SPFA:1844ms\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <iostream>\n#define inf 1e10+5\n#define maxn 1000005\nusing namespace std;\n\nstruct node\n{\n\tint v,w,next;\n}edge[maxn];\n\nint dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint a[maxn],b[maxn],c[maxn];\nint k,n,m;\nvoid adde(int u,int v,int w)\n{\n\tedge[k].v=v;\n\tedge[k].w=w;\n\tedge[k].next=first[u];\n\tfirst[u]=k++;\n}\n\nlong long spfa(int x)\n{\n\tqueue <int>q;\n\tq.push(x);\n\tvis[x]=true;\n\tdis[x]=0;\n\tint i;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tvis[u]=false;\n\t\tfor(i=first[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(dis[v]>dis[u]+w)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tif(!vis[v])\n\t\t\t\t{\n\t\t\t\t\tq.push(v);\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tans=ans+dis[i];\n\t}\n\treturn ans;\n}\n\nvoid init()\n{\n\tk=1;\n\tmemset(first,0,sizeof(first));\n\tmemset(edge,0,sizeof(edge));\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\n\nint main()\n{\n\tint i,j;\n\tlong long ans=0;\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tans=0;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tinit();\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a[i],&b[i],&c[i]);\n\t\t\tadde(a[i],b[i],c[i]);\n\t\t}\n\t\tans=ans+spfa(1);\n\t\tinit();\n\t\tfor(i=1;i<=m;i++)\n\t\t\tadde(b[i],a[i],c[i]);\n\t\tans=ans+spfa(1);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n} \n```\n\n#### dijstra堆优化：2157ms\n\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <functional>\n#define inf 1e10+5\n#define maxn 1000005\nusing namespace std;\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;\nstruct node\n{\n\tint v,w,next;\n}edge[maxn];\nlong long int dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint a[maxn],b[maxn],c[maxn];\nint k,n,m;\nvoid adde(int u,int v,int w)\n{\n\tedge[k].v=v;\n\tedge[k].w=w;\n\tedge[k].next=first[u];\n\tfirst[u]=k++;\n}\n\nvoid init()\n{\n\tk=1;\n\tmemset(first,0,sizeof(first));\n\tmemset(edge,0,sizeof(edge));\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\n\nlong long dijstra(int x)\n{\n\tint i;\n\tdis[x]=0;\n\tq.push(make_pair(dis[x],x));\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top().second;\n\t\tq.pop();\n\t\tif(vis[u]==true)continue;\n\t\tvis[u]=true;\n\t\tfor(i=first[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(!vis[v]&&dis[v]>dis[u]+w)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tq.push(make_pair(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tans=ans+dis[i];\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j;\n\tlong long ans;\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tans=0;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tinit();\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a[i],&b[i],&c[i]);\n\t\t\tadde(a[i],b[i],c[i]);\n\t\t}\n\t\tans=ans+dijstra(1);\n\t\tinit();\n\t\tfor(i=1;i<=m;i++)\n\t\t\tadde(b[i],a[i],c[i]);\n\t\tans=ans+dijstra(1);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["spfa"],"categories":["poj"]},{"title":"spfa","url":"%2F2019%2F07%2F30%2Fspfa.html","content":"<p class=\"description\"></p>\n## SPFA算法（Shortest Path Faster Algorithm）\n\n复杂度：O（KE）\n\nk为所有顶点进队的平均次数，可以证明k一般小于等于2。\n\n计算单源最短路，图可带负权。玄学复杂度，比普通Dijstra和Floyd要低。\n\n可以判断是否有负环。\n\n<!-- more -->\n\n例：求a点到其余各点的最短路径。\n\n![img](spfa\\1_1.png)\n\n首先建立起始点a到其余各点的最短路径表格dis[]\n\n![img](spfa\\1.jpg)\n\n首先源点a入队，当队列非空时：队首元素（a）出队，对以a为起始点的所有边的终点依次进行松弛操作（此处有b,c,d三个点），此时路径表格状态为：\n\n![img](spfa\\2.jpg)\n\n在松弛时三个点的最短路径估值变小了，而这些点队列中都没有出现，这些点需要入队，此时，队列中新入队了三个结点b,c,d\n\n队首元素b点出队，对以b为起始点的所有边的终点依次进行松弛操作（此处只有e点），此时路径表格状态为：\n\n![img](spfa\\3.jpg)\n\n在最短路径表中，e的最短路径估值也变小了，e在队列中不存在，因此e也要入队，此时队列中的元素为c，d，e\n\n队首元素c点出队，对以c为起始点的所有边的终点依次进行松弛操作（此处有e,f两个点），此时路径表格状态为：\n\n![img](spfa\\4.jpg)\n\n在最短路径表中，e，f的最短路径估值变小了，e在队列中存在，f不存在。因此e不用入队了，f要入队，此时队列中的元素为d，e，f\n\n 队首元素d点出队，对以d为起始点的所有边的终点依次进行松弛操作（此处只有g这个点），此时路径表格状态为：\n\n![img](spfa\\5.jpg)\n\n在最短路径表中，g的最短路径估值没有变小（松弛不成功），没有新结点入队，队列中元素为f，g\n\n队首元素f点出队，对以f为起始点的所有边的终点依次进行松弛操作（此处有d，e，g三个点），此时路径表格状态为：\n\n![img](spfa\\6.jpg)\n\n在最短路径表中，e，g的最短路径估值又变小，队列中无e点，e入队，队列中存在g这个点，g不用入队，此时队列中元素为g，e\n\n队首元素g点出队，对以g为起始点的所有边的终点依次进行松弛操作（此处只有b点），此时路径表格状态为：\n\n![img](spfa\\7.jpg)\n\n在最短路径表中，b的最短路径估值又变小，队列中无b点，b入队，此时队列中元素为e，b队首元素e点出队，对以e为起始点的所有边的终点依次进行松弛操作（此处只有g这个点），此时路径表格状态为：\n\n![img](spfa\\8.jpg)\n\n在最短路径表中，g的最短路径估值没变化（松弛不成功），此时队列中元素为b\n\n队首元素b点出队，对以b为起始点的所有边的终点依次进行松弛操作（此处只有e这个点），此时路径表格状态为：\n\n![img](spfa\\9.jpg)\n\n在最短路径表中，e的最短路径估值没变化（松弛不成功），此时队列为空了。算法结束。\n\n最终dis[]即为a到各点最短路。\n\n若某个点进队了n次即图存在负环。\n\n## 总结\n\n1、创建一个队列，将源点放入。\n\n2、每次从队列中取出一个点X，遍历点X的所有与X相通的节点Y，比较dis[x]+e[x] [y]<dis[y];\n\n如果dis[x]+e[x] [y]<dis[y]，则说明需要更新操作。\n\ndis[y]=dis[x]+e[x] [y]//更新最短路径\n\n由于Y改变了最短路径长度，所以需要以Y开始往后更新，因此如果Y不在队列中，则将Y加入队列。\n\n（在此期间可以记录各个节点的入队次数，判断是否存在负环）\n\n3.循环2，直到队列为空。\n\n## 代码\n\n```c++\nvoid spfa(int x)\n{\n\tqueue <int>q;\n\tq.push(x);//将源点放入队列中\n\tvis[x]=true;//vis变true\n\tdis[x]=0;//源点距离为0，其余点为inf\n\tint i;\n\twhile(!q.empty())//直到队列为空\n\t{\n\t\tint u=q.front();//取出队列第一个元素\n\t\tq.pop();//弹出第一个元素\n\t\tvis[u]=false;//第一个元素因为出队了，所以vis变false\n\t\tfor(i=first[u];i;i=edge[i].next)//遍历第一个元素的所有出边\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(dis[v]>dis[u]+w)//判断能否通过第一个元素出边进行松弛\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tif(!vis[v])//可以松弛但不在队列中，那么就放入队列，vis变true\n\t\t\t\t{\n\t\t\t\t\tq.push(v);\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["spfa"],"categories":["algorithm"]},{"title":"Topological sort","url":"%2F2019%2F07%2F30%2FTopological-sort.html","content":"<p class=\"description\"></p>\n## 拓扑排序（Topological sort）\n\n拓扑排序是一个比较常用的图论算法，经常用于完成有依赖关系的任务的排序。\n\n时间复杂度：O（N+E）\n\n空间复杂度：O（N）\n\n<!-- more -->\n\n举个例子：\n\n有人想要制作一件工具，但是这个工具不是一次就可以完成的，分很多个步骤，而且这些步骤是有顺序的，也就是说，假设B的顺序在A的后面，那么你就必须要先完成A再完成B，但是也有些步骤不分顺序，意思是你先做哪一个都是可以的。\n\n面对这样的问题，我们可以把步骤建立成一张有向无环图，A指向B意思是A要在B前面完成，那么下面，我们就要找到一个顺序，来使答案符合题目要求。拓扑排序就是干这样的事情的。\n\n![topsort](Topological-sort\\20150507001759702)\n\n那么如何做呢？\n\n只需要遍历一边所有节点，然后找出没有入度的节点，将他们放到一个队列中。\n\n然后通过队列中的无入度的节点，弹出它，删掉这个节点的所有出边，会形成新的没有入度的节点。\n\n再将新的没有入读的节点放入队列，以此循环。\n\n直到队列为空。\n\n如果拓扑排序后的序列个数k小于图的节点数n，那么图中则存在环。环的节点数即为n-k。\n\n## 代码\n\n```c++\nqueue<int>q;\n//priority_queue<int,vector<int>,greater<int>>q;\n//优先队列的话，会按照数值大小有顺序的输出\n//此处为了理解，暂时就用简单队列\ninttopo()\n{\n    for(inti=1;i<=n;i++)\n    {\n        if(indegree[i]==0)\n        {\n            q.push(i);\n        }\n    }\n \n    int temp;\n    while(!q.empty())\n    {\n        temp=q.front();//如果是优先队列，这里可以是top()\n        printf(\"%d->\",temp);\n        q.pop();\n        for(inti=1;i<=n;i++)//遍历从temp出发的每一条边，入度--\n        {\n            if(map[temp][i])\n            {\n                indegree[i]--;\n                if(indegree[i]==0)q.push(i);\n            }\n        }\n    }\n}\n```\n\n\n\n<hr />\n","tags":["topsort"],"categories":["algorithm"]},{"title":"poj2240","url":"%2F2019%2F07%2F29%2Fpoj2240.html","content":"<p class=\"description\"></p>\npoj2240,bellman求正环，map使用\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2240\n\n## 题意\n\nT个国家，接下来T行每个国家的名字。\n\n再输入N，代表N个交换所。\n\n接下来N行，输入A C B\n\n表示A国到B国的汇率是C。\n\n## 细节\n\n用map解决输入问题之后做法就同poj1860\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <iostream>\n#include <map>\nusing namespace std;\nmap<string,int>name;\n\nstruct edge{\n\tint u,v;\n\tdouble w;\n}e[1010];\n\n\n\nint main()\n{\n\tint t,n;\n\tint i=0,j;\n\tstring s,u,v;\n\tdouble w,dis[40];\n\tint time=1;\n\twhile(scanf(\"%d\",&t)!=EOF)\n\t{\n\t\tif(t==0)break;\n\t\tint tt=t;\n\t\ti=0;\n\t\twhile(t--)\n\t\t{\n\t\t\ti++;\n\t\t\tcin >> s;\n\t\t\tname[s]=i;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\ti=1;\n\t\tint k=n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcin >> u >> w >> v ;\n\t\t\te[i].u=name[u];\n\t\t\te[i].v=name[v];\n\t\t\te[i].w=w;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tfor(i=1;i<=tt;i++)\n\t\tdis[i]=0;\n\t\t\n\t\tdis[1]=1;\n\t\t\n\t\tfor(i=1;i<=tt;i++)\n\t\t{\n\t\t\tfor(j=1;j<=k;j++)\n\t\t\t{\n\t\t\t\tif(dis[e[j].v]<dis[e[j].u]*e[j].w)\n\t\t\t\t\tdis[e[j].v]=dis[e[j].u]*e[j].w;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint flag=0;\n\t\tfor(j=1;j<=k;j++)\n\t\t\t{\n\t\t\t\tif(dis[e[j].v]<dis[e[j].u]*e[j].w)\n\t\t\t\t\tflag=1;\n\t\t\t}\n\t\t\t\n\t\tif(flag)printf(\"Case %d: Yes\\n\",time);\n\t\telse printf(\"Case %d: No\\n\",time);\n\t\ttime++;\n\t}\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj3660","url":"%2F2019%2F07%2F28%2Fpoj3660.html","content":"<p class=\"description\"></p>\npojj3660,floyd求有向图的传递闭包\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3660\n\n## 题意\n\nN头牛，给你M个两头牛的关系，即a可以打败b。\n\n问最多能确定几头牛的名次。\n\n即如果这头牛和其余的牛的关系是确定的，那么这个牛的排名就是确定的。\n\n## 细节\n\n传递闭包： 关系之间具有传递性（例如a> b, b> c, 那么a> c）\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999 \nint e[110][110];\nint main()\n{\n\tint n,m,a,b;\n\tscanf(\"%d%d\",&n,&m);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\te[i][j]=0;\n\t\t}\n\t\t\t\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te[a][b]=1;\n\t}\n\t\n\tint k;\n\tfor(k=1;k<=n;k++)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(e[i][k]&&e[k][j])\n\t\t\t\t\t\te[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\n\tint ans=0,flag;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tflag=1;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\telse if(e[i][j]==0&&e[j][i]==0)\n\t\t\t{\n\t\t\t\tflag=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==1)ans++;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj1502","url":"%2F2019%2F07%2F28%2Fpoj1502.html","content":"<p class=\"description\"></p>\npoj1502,单源最短路，坑爹题意，优雅使用sscanf\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1502\n\n## 题意\n\nN个点，之后给你半个邻接矩阵。由于自己到自己是0，所以也不给。\n\nx为无法到达。\n\n求最短路中的最大值。即dis[]中最大值。\n\n## 细节\n\ndijstra模板题。就是输入比较麻烦。\n\nsscanf(s,\"%d\",&e[i] [j]);\n\n这样输入就很简单了。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#define inf 99999999\nint e[110][110];\nint dis[110];\nint book[110];\nint main()\n{\n\tint n,i,j;\n\tscanf(\"%d\",&n);\n\t\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf;\n\t\t}\n\t\n\tchar s[100];\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<i;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%s\",s);\n\t\t\t\tif(s[0]=='x')continue;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsscanf(s,\"%d\",&e[i][j]);\n\t\t\t\t\te[j][i]=e[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\n\tfor(i=1;i<=n;i++)\n\t\tdis[i]=e[1][i];\n\t\n\t\n\tfor(i=1;i<=n;i++)\n\t\tbook[i]=0;\n\t\t\n\tbook[1]=1;\n\tdis[1]=0;\n\tint min,temp;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tmin=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dis[j]<min&&book[j]==0)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\t\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dis[temp]+e[temp][j]<dis[j])\n\t\t\t\tdis[j]=dis[temp]+e[temp][j];\n\t\t}\n\t}\n\t\n\tint max=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(max<dis[i])max=dis[i];\n\t}\n\tprintf(\"%d\\n\",max);\n} \n\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj3259","url":"%2F2019%2F07%2F28%2Fpoj3259.html","content":"<p class=\"description\"></p>\npoj3259,求负环\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3259\n\n## 题意\n\n有N个点，M条路，W个虫洞。路是双向的，虫洞是单向的。\n\n每次穿越虫洞将会时间回溯虫洞的权值。\n\n问能否通过虫洞回到过去？\n\n## 细节\n\nbellman求负环板子题\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999\nint dis[510];\nint u[6000],v[6000],w[6000];\nint main()\n{\n\tint t,n,m,w1,j;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d%d\",&n,&m,&w1);\n\t\tint i,a,b,c,k=1;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tu[k]=a;v[k]=b;w[k++]=c;\n\t\t\tu[k]=b;v[k]=a;w[k++]=c;\n\t\t}\n\t\tfor(i=1;i<=w1;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tu[k]=a;v[k]=b;w[k++]=-c;\n\t\t}\n\t\t\n\t\tfor(i=1;i<=n;i++)\n\t\tdis[i]=inf;\n\t\t\n\t\tdis[1]=0;\n\t\t\n\t\tfor(j=1;j<=n-1;j++)\n\t\t{\n\t\t\tfor(i=1;i<k;i++)\n\t\t\t{\n\t\t\t\tif(dis[v[i]]>dis[u[i]]+w[i])\n\t\t\t\tdis[v[i]]=dis[u[i]]+w[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint flag=0;\n\t\tfor(i=1;i<k;i++)\n\t\t\t{\n\t\t\t\tif(dis[v[i]]>dis[u[i]]+w[i])\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t\t\n\t\tif(flag==0)printf(\"NO\\n\");\n\t\telse printf(\"YES\\n\");\n\t}\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"bellman","url":"%2F2019%2F07%2F26%2Fbellman.html","content":"\n## Bellman算法\n\nDijstra只能求没有负权边的图，因为当所有边权为正时，不会存在一个路程更短的没有拓展过的点，所以这个点的路程永远不会再改变，从而保证了dijstra的正确性。\n\n那么有没有一个算法可以求带有负权边的指定顶点到其余各个顶点的最短路径算法呢？\n\n那就到Bellman-Ford出场了。\n\n复杂度：O(NM)\n\n优化后：<=O(NM)\n\n<!-- more -->\n\n求1号顶点到其余所有顶点的最短路径。\n\n![1564125629485](bellman\\1564125629485.png)\n\n依旧用dis[]存储1号顶点到所有顶点的距离。\n\n![1564125848909](bellman\\1564125848909.png)\n\n接下来根据边给出的顺序，先处理第一条边2-3  2。\n\n通过2-3这条边进行松弛。即判断dis[3]是否大于dis[2]+2。此时dis[3]是∞，dis[2]也是∞，那么dis[3]<dis[2]+2。所以通过2-3-2不能是dis[3]的值变小，松弛失败。\n\n继续处理第二条边1-2  -3。\n\n发现dis[2]>dis[1]+(-3)，通过这条边可以使dis[2]的值从∞变成-3。因此松弛成功。\n\n以此类推，用同样的方法处理剩下的每一条边。对所有的边松弛一便后的结果如下：\n\n![1564126314876](bellman\\1564126314876.png)\n\n可以发现，1-2和1-5的距离变短了。我们再对所有边进行一轮松弛操作。\n\n![1564126386305](bellman\\1564126386305.png)\n\n如果说floyd是每次只能经过一个点中转来求到达其余个点的最短路径长度，那bellman就是每次只能经过一条边来求到达其余个点的最短路径长度。\n\n如果进行k轮的话，那么就是从1号顶点最多经过k条边到达其余各顶点的最短路径长度。\n\n因为再含有n个顶点的图中，任意两点间的最短路径最多包含n-1条边。\n\n所以最多只需要进行n-1轮松弛即可求出最短路径。\n\n另外，最短路径可能包含回路。\n\n回路分为正权回路和负权回路。\n\n如果包含正权回路，那么去掉正权回路之后一定能找到更短的路径。\n\n如果包含负权回路，那么肯定没有最短路径。因为每多走一次负权回路就可以得到更短的路径。\n\n\n\n继续\n\n![1564127047514](bellman\\1564127047514.png)\n\n完工！\n\n## 总结\n\n对所有的边进行n-1次松弛操作。\n\n## 代码\n\n```c++\nfor(k=1;k<=n;k++)\n\t\tfor(i=1;i<=m;i++)\n\t\t\tif(dis[v[i]]>dis[u[i]]+w[i])\n\t\t\t\tdis[v[i]]=dis[u[i]]+w[i];\n```\n\n## 优化\n\n待施工~~~\n\n<hr />","tags":["bellman"],"categories":["algorithm"]},{"title":"poj1860","url":"%2F2019%2F07%2F26%2Fpoj1860.html","content":"<p class=\"description\"></p>\npoj1860，求图正环\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1860\n\n## 题意\n\n有多种汇币，汇币之间可以交换，这需要手续费，当你用100A币交换B币时，A到B的汇率是29.75，手续费是0.39，那么你可以得到(100 - 0.39) * 29.75 = 2963.3975 B币。问s币的金额经过交换最终得到的s币金额数能否增加。\n\n输入：\n\n第一行，N种货币，M个交换所，你手上拥有的货币种类s，你手上拥有的money；\n\n接下来m行，a币，b币，a到b的汇率，a到b的手续费，b到a的汇率，b到a的手续费。\n\n## 细节\n\nbellman算法求正环，只需要按所有边都松弛一边之后然后进行判断能否再次松弛即可。能继续松弛即为有正环。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999\nint main()\n{\n\tint u[220],v[220];\n\tdouble dis[110],wl[220],ws[220];\n\tint n,m,s,i;\n\tdouble money;\n\tscanf(\"%d%d%d%lf\",&n,&m,&s,&money);\n\ti=0;\n\tint k=m;\n\twhile(m--)\n\t{\n\t\tint a,b;\n\t\tdouble al,as,bl,bs;\n\t\tscanf(\"%d%d%lf%lf%lf%lf\",&a,&b,&al,&as,&bl,&bs);\n\t\tu[i]=a;v[i]=b;wl[i]=al;ws[i]=as;\n\t\ti++;\n\t\tu[i]=b;v[i]=a;wl[i]=bl;ws[i]=bs;\n\t\ti++;\n\t}\n\tint t,j;\n\t\n\tfor(t=0;t<=n;t++)\n\t{\n\t\tdis[t]=0;\n\t}\n\tdis[s]=money;\n\t\n\tfor(t=1;t<=k;t++)\n\t{\n\t\tfor(j=0;j<i;j++)\n\t\t{\n\t\t\tif(dis[v[j]]<(dis[u[j]]-ws[j])*wl[j])\n\t\t\t\tdis[v[j]]=(dis[u[j]]-ws[j])*wl[j];\n\t\t}\n\t}\n\t\n\tint flag=0;\n\tfor(j=0;j<i;j++)\n\t\t{\n\t\t\tif(dis[v[j]]<(dis[u[j]]-ws[j])*wl[j])\n\t\t\t{\n\t\t\t\tdis[v[j]]=(dis[u[j]]-ws[j])*wl[j];\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t\n\tif(flag==1)printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"floyd","url":"%2F2019%2F07%2F25%2Ffloyd.html","content":"<p class=\"description\"></p>\n## Floyed算法\n\n复杂度：O（n^3）\n\npoj又又又又炸了。写一下Floyd吧。核心代码五行，很简单。\n\n求一张图内任意两点间的距离。\n\n![=w=](http://pv35325dx.bkt.clouddn.com/guahua.gif)\n\n<!-- more -->\n\n例如：求任意两个点的最短路程。\n\n![1564051171338](floyd\\1564051171338.png)\n\n用矩阵存储图。\n\n![1564051237886](floyd\\1564051237886.png)\n\n首先我们知道两个点之间的距离了，接下来可以思考，有没有办法通过第三个点来进行中转来缩短路程呢？\n\n因此我们可以假设现在只允许通过1号点进行中转，来进行尝试缩短路程。\n\n只需要判断e[i] [1]+e[1] [j]是否比e[i] [j]小即可。\n\n代码如下：\n\n```c++\nfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[i][j]>e[i][1]+e[1][j])\n\t\t\t\te[i][j]=e[i][1]+e[1][j];\n\t\t}\n\t}\n```\n\n在只允许通过1号顶点的情况下，任意两点间的最短路径更新为：\n\n![1564052208614](floyd\\1564052208614.png)\n\n以此类推，然后考虑只允许通过2号点进行中转。\n\n```c++\nfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[i][j]>e[i][2]+e[2][j])\n\t\t\t\te[i][j]=e[i][2]+e[2][j];\n\t\t}\n\t}\n```\n\n几乎一毛一样，1变成2。\n\n更新：\n\n![1564052291135](floyd\\1564052291135.png)\n\n通过3号点中转更新：\n\n![1564052336765](floyd\\1564052336765.png)\n\n通过4号点中转更新：\n\n![1564052379218](floyd\\1564052379218.png)\n\n更新完毕。上图即为任意两点间最终的最短路程。\n\n## 总结\n\n简单来说就是遍历通过1-n个点的中转来缩短最短路程。\n\n## 代码\n\n```c++\nfor(k=1;k<=n;k++)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(e[i][j]>e[i][k]+e[k][j])\n\t\t\t\t\t\te[i][j]=e[i][k]+e[k][j];\n\t\t\t\t}\n\t\t}\n\t}\n```\n\n\n\n<hr />\n","tags":["floyd"],"categories":["algorithm"]},{"title":"poj3268","url":"%2F2019%2F07%2F25%2Fpoj3268.html","content":"<p class=\"description\"></p>\npoj3268,最短路变形，有向图，求来回距离\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3268\n\n## 题意\n\n给出n个点和m条边，接着是m条边，代表从牛a到牛b需要花费c时间，现在所有牛要到牛x那里去参加聚会，并且所有牛参加聚会后还要回来，给你牛x，除了牛x之外的牛，他们都有一个参加聚会并且回来的最短时间，从这些最短时间里找出一个最大值输出。\n\n## 细节\n\n首先可以想到，所有牛到X的最短距离，那么将X作为起点就可以通过dijstra知道X到其他点的距离。即返程的距离。\n\n只需要转置矩阵一下，就可以求出其他点到X的距离了。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999\nint e[1010][1010];\nint dis[1010];\nint book[1010];\nint sum[1010];\nint n,m,x;\nvoid dijstra()\n{\n\tint i,j;\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[x]=1;\n\tfor(i=1;i<=n;i++)dis[i]=e[x][i];\n\tdis[x]=0;\n\t\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf,temp,v;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0&&dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsum[i]=sum[i]+dis[i];\n\t}\n}\n\nint main()\n{\n\tint a,b,c,i,j;\n\tscanf(\"%d%d%d\",&n,&m,&x);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\te[i][j]=inf;\n\tfor(i=1;i<=n;i++)\n\t\tsum[i]=0;\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t}\n\tdijstra();\n\tint temp;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i;j<=n;j++)\n\t\t{\n\t\t\ttemp=e[i][j];\n\t\t\te[i][j]=e[j][i];\n\t\t\te[j][i]=temp;\n\t\t}\n\tdijstra();\n\tint max=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(i==x)continue;\n\t\telse if(sum[i]>max)max=sum[i];\n\t}\n\tprintf(\"%d\",max);\n} #include <stdio.h>\n#define inf 99999999\nint e[1010][1010];\nint dis[1010];\nint book[1010];\nint sum[1010];\nint n,m,x;\nvoid dijstra()\n{\n\tint i,j;\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[x]=1;\n\tfor(i=1;i<=n;i++)dis[i]=e[x][i];\n\tdis[x]=0;\n\t\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf,temp,v;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0&&dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsum[i]=sum[i]+dis[i];\n\t}\n}\n\nint main()\n{\n\tint a,b,c,i,j;\n\tscanf(\"%d%d%d\",&n,&m,&x);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\te[i][j]=inf;\n\tfor(i=1;i<=n;i++)\n\t\tsum[i]=0;\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t}\n\tdijstra();\n\tint temp;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i;j<=n;j++)\n\t\t{\n\t\t\ttemp=e[i][j];\n\t\t\te[i][j]=e[j][i];\n\t\t\te[j][i]=temp;\n\t\t}\n\tdijstra();\n\tint max=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(i==x)continue;\n\t\telse if(sum[i]>max)max=sum[i];\n\t}\n\tprintf(\"%d\",max);\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj1797","url":"%2F2019%2F07%2F24%2Fpoj1797.html","content":"<p class=\"description\"></p>\npoj1797,最短路变形\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1797\n\n## 题意\n\n青蛙那题的变形版本。\n\n输入T组，每组x个点，y条边。\n\n接下来y行分别是a到b的边的权重。\n\n求1到x的所有边中最大的最小边权重。（2333读懂题目就会了）\n\n形象一点理解就是权重为道路的载重量，这题求的就是一辆卡车从1开到x，卡车最多可以载重多少。当然取决于一条路上载重量最低的那条路。输出那条路的载重量。\n\n## 细节\n\n思路：反过来查找dis[]中最大的，那么就能确定1到那个点的最大权重了，然后进行。。松弛？\n\n## 代码\n\nDijstra变形：一开始读错题了导致代码写丑了。\n\n```c++\n#include <stdio.h>\n#include <math.h>\n#define inf 99999999\ndouble funmin(int a,int b)\n{\n\tif(a>b)return b;\n\telse return a;\n}\n\ndouble funmax(int a,int b)\n{\n\tif(a>b)return a;\n\telse return b;\n}\n\nint e[1010][1010],book[1010],dis[1010];\n\nint main()\n{\n\tint t,count=1;\n\tint i,j,x,y,a,b,c;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\tscanf(\"%d%d\",&x,&y);\n\t\n\tfor(i=1;i<=x;i++)\n\t\tfor(j=1;j<=x;j++)\n\t\t\t{\n\t\t\t\tif(i==j)e[i][j]=0;\n\t\t\t\te[i][j]=-inf;\n\t\t\t}\n\t\n\twhile(y--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t\te[b][a]=c;\n\t}\n\t\n\t\n\tfor(i=1;i<=x;i++)\n\t\t{\n\t\t\tdis[i]=e[1][i];\n\t\t\tbook[i]=0;\n\t\t}\n\tdis[1]=0;book[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<x;i++)\n\t{\n\t\tint max=-inf;\n\t\tfor(j=2;j<=x;j++)\n\t\t{\n\t\t\tif(dis[j]>max&&book[j]==0)\n\t\t\t{\n\t\t\t\tmax=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=2;v<=x;v++)\n\t\t{\n\t\t\tif(e[temp][v]>0&&book[v]==0)\n\t\t\t{\n\t\t\t\tdis[v]=funmax(dis[v],funmin(e[temp][v],dis[temp]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Scenario #%d:\\n%d\\n\\n\",count++,dis[x]);\n\t} \n}\n```\n\n\n\n<hr />","tags":["poj"],"categories":["poj"]},{"title":"poj2253","url":"%2F2019%2F07%2F24%2Fpoj2253.html","content":"<p class=\"description\"></p>\npoj2253,最短路变形\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2253\n\n## 题意\n\n第一行T，告诉你有T个点，下面T行是它们的坐标\n\n有两只青蛙，T的第一个是a青蛙坐标，第二个是b青蛙坐标\n\n求a青蛙到b青蛙那里的所有路中最短的 路径中最大的边\n\n\n\n![2253](poj2253\\2253.png)\n\n例：如图所示，1到3距离为1，2到3距离为1，1到2距离为2，那么根据题意，1-3-2最长的边是1，1-2最长的是2，所以输出1。\n\n## 细节\n\n输出有俩\\n\n\n## 代码\n\nDijstra改一改：\n\n```c++\n#include <stdio.h>\n#include <math.h>\n#define inf 99999999\ndouble funmin(double a,double b)\n{\n\tif(a>b)return b;\n\telse return a;\n}\n\ndouble funmax(double a,double b)\n{\n\tif(a>b)return a;\n\telse return b;\n}\n\nint main()\n{\n\tint t,count=1;\n\tint x[210],y[210],book[210];\n\tdouble e[210][210],dis[210];\n\tint i,j;\n\tscanf(\"%d\",&t);\n\twhile(t!=0)\n\t{\n\tfor(i=1;i<=t;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\n\tfor(i=1;i<=t;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\te[i][j]=inf;\n\t\t\t\n\tfor(i=1;i<t;i++)\n\t\tfor(j=i+1;j<=t;j++)\n\t\t{\n\t\t\te[i][j]=e[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t\n\tfor(i=1;i<=t;i++)\n\t\t{\n\t\t\tdis[i]=e[1][i];\n\t\t\tbook[i]=0;\n\t\t}\n\tdis[1]=0;book[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<t;i++)\n\t{\n\t\tdouble min=inf;\n\t\tfor(j=1;j<=t;j++)\n\t\t{\n\t\t\tif(dis[j]<min&&book[j]==0)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=1;v<=t;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tdis[v]=funmin(dis[v],funmax(e[temp][v],dis[temp]));//比较经过temp点松弛后的路线中最长跳跃距离和dis[v]的距离\n\t\t\t\t//if(e[temp][v]+dis[temp]<dis[v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Scenario #%d\\nFrog Distance = %.3lf\\n\\n\",count++,dis[2]);\n\tscanf(\"%d\",&t);\n\t} \n}\n```\n\n\n\n<hr />","tags":["poj"],"categories":["poj"]},{"title":"poj2387","url":"%2F2019%2F07%2F24%2Fpoj2387.html","content":"<p class=\"description\"></p>\n板子题，最短路，poj2387\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2387\n\n## 题意\n\n第一行T组数据，N个顶点\n\n之后T行告诉你a到b的距离c\n\n求到n的最短路径\n\n## 细节\n\n有重边 \\ \\两点之间的路未必只有一条\n\n## 代码\n\nDijstra：\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#define inf 99999999\nint e[1010][1010],dis[1010],book[1010];\n\nint main()\n{\n\tint n,t,a,b,c,i,j;\n\tscanf(\"%d%d\",&t,&n);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf; \n\t\t}\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tif(e[a][b]>c)\n\t\t{\n\t\t\te[a][b]=c;\n\t\t\te[b][a]=c;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tdis[i]=e[1][i];\n\t\tbook[i]=0;\n\t}\n\tdis[1]=0;\n\tbook[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dis[j]<min&&book[j]==0)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",dis[n]);\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"dijstra","url":"%2F2019%2F07%2F23%2Fdijstra.html","content":"## Dijstra算法\n\n博客初建，先记录一个基础的单源最短路算法，Dijstra。\n\n复杂度：O（N²）\n\n![lalala](http://pv35325dx.bkt.clouddn.com/lalala.gif)\n\n<!-- more -->\n\n例如求1到各个顶点的最短路径。\n\n![1](http://pv35325dx.bkt.clouddn.com/1563866213798.png)\n\n首先考虑图的存储问题，使用二维数组e来进行存储各个点之间的边的长度。\n\n![2](http://pv35325dx.bkt.clouddn.com/1563862729194.png)\n\n然后创建一个一维数组dis来存储1号顶点到其余各个顶点的初始路程。\n\n![3](http://pv35325dx.bkt.clouddn.com/1563862773804.png)\n\n此时dis数组中的值称为最短路程的“估计值”。\n\n既然是找最短路，那么根据dis可以寻找到离点1最近的顶点是2。\n\n那么dis[2]的值就变成了“确定值”。即点1到点2的最短距离就是dis[2]的值。\n\n既然选择了2号顶点，那就继续看2号顶点的几条出边。有2-3和2-4这两条，先讨论2-3能否让1号顶点到3号顶点的路程变短，即比较dis[3]和dis[2]+e[2] [3]的大小。\n\ndis[3]=12,dis[2]+e[2] [3]=10,dis[3]>dis[2]+e[2] [3],所以可以通过1-2-3这样缩短1-3的距离，因此dis[3]更新为10。这个过程专业点称为“松弛”。\n\n同理，dis[2]+e[2] [4]<dis[4],dis[4]的值可以松弛为4。\n\n这样2号顶点的所有出边就都松弛完了。松弛之后的dis数组为：\n\n![5](http://pv35325dx.bkt.clouddn.com/1563863527940.png)\n\n接下来以此类推，在剩下的3，4，5，6号顶点中选出离1最近的顶点。\n\n通过dis数组可以发现最近的顶点是4。\n\ndis[4]的值变成“确定值”。\n\n然后继续对4号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![6](http://pv35325dx.bkt.clouddn.com/1563863664903.png)\n\n以此类推，在剩下的3，5，6号顶点中，选出离1号最近的顶点。这次选择3号顶点。\n\ndis[3]的值变成“确定值”。\n\n对3号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![7](http://pv35325dx.bkt.clouddn.com/1563863742582.png)\n\n在剩下的5，6号顶点中，选出离1号最近的顶点。选择5号。\n\ndis[5]的值变成“确定值”。\n\n对5号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![8](http://pv35325dx.bkt.clouddn.com/1563863819140.png)\n\n最后选择6号。\n\ndis[6]的值变成“确定值”。\n\n最后对6号顶点的所有出边进行松弛。因为此例6号没有出边，因此不用处理。\n\n至此，dis数组中所有的值都已经从“估计值”变成了“确定值”。\n\n最终dis数组如下，这便是1号顶点到各个顶点的最短路径。\n\n![10](http://pv35325dx.bkt.clouddn.com/1563863951516.png)\n\n## 总结\n\n算法基本思想：每次都找离源点最近的顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define MAXN 101 //最大顶点数 \nint main()\n{\n\tint e[MAXN][MAXN],dis[MAXN];\n\tint temp,v,i,j,a,b,c,n,m,min;\n\tint inf=99999999;//存储一个认为正无穷的值\n\tscanf(\"%d%d\",&n,&m);//n个顶点，m条边\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf;\n\t//初始化 \n\t \n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t} \n\t//读入边\n\t\n\tfor(i=1;i<=n;i++)\n\t\tdis[i]=e[1][i];\n\t//初始化dis数组\n\t\n\tint book[MAXN];//在代码中，需要用一个book数组进行标记估计值还是确定值\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[1]=1;\n\t\n\t//Dijstra算法核心语句\n\tfor(i=1;i<=n-1;i++)\n\t{\n\t\tmin=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0 && dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;//记录最小的顶点号 \n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;//dis[temp]变成确定值\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)//进行松弛 \n\t\t\t{\n\t\t\t\tif(dis[temp]+e[temp][v]<dis[v])\n\t\t\t\t\tdis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(i=1;i<=n;i++)\n\t\tprintf(\"%d \",dis[i]);//输出结果 \n\n} \n```\n\n","tags":["dijstra"],"categories":["algorithm"]},{"title":"my first blog","url":"%2F2019%2F07%2F22%2Fmy-first.html","content":"<p class=\"description\"></p>\n![first](http://pv35325dx.bkt.clouddn.com/first.jpg)\n\n<!-- more -->\n\n经过两天的搭建，终于好像搭好了！安装上了node,git,hexo.然后扔GitHub然后买了个域名。编辑md软件用的Typora，蛮好用。\n\n域名yuanfang.tech，既有远方，又有远芳的意思，还可以记成元芳，给别人记应该很好记23333（没办法lmf太贵了）。本来还想起个英文的，但算了，中文更写意。tech很有dalao的感觉。\n\n计划以后写题啊算法啥的都往上放。\n\n就先这样，功能慢慢加，日后完善。\n\n<hr />\n","tags":["test"],"categories":["somethings"]}]