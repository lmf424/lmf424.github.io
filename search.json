[{"title":"hdu1875","url":"%2F2019%2F08%2F22%2Fhdu1875.html","content":"<p class=\"description\"></p>\nhdu1875,建图求最小生成树\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1875\n\n## 题意\n\nt组数据\n\nn个点，接下来n行是每个点的坐标\n\n小于10和大于1000的距离不符合要求\n\n输出最小生成树\n\n## 细节\n\n最后结果要乘100\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int maxn=110;\nstruct point{\n\tdouble x,y; \n}p[maxn];\nstruct edge{\n\tint u,v;\n\tdouble w;\n}e[maxn*maxn];\nint parent[maxn];\nint n;\nbool cmp(edge a,edge b)\n{\n\treturn a.w<b.w;\n}\nvoid set()\n{\n\tint i;\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tparent[i]=i;\n\t}\n}\nint find_set(int x){\n    int k, i, r = x;\n    while(parent[r] != r) {\n        r = parent[r];\n    }\n    k = x;\n    while(k != r) {\n        i = parent[k];\n        parent[k] = r;\n        k = i;\n    }\n    return r;\n}\nint cou;\nvoid kruskal()\n{\n\tset();\n\tint i,j,cnt=0;\n\tdouble sum=0;\n\tfor(i=0;i<cou&&cnt<n-1;i++)\n\t{\n\t\tint x=find_set(e[i].u);\n\t\tint y=find_set(e[i].v);\n\t\tif(x!=y)\n\t\t{\n\t\t\tparent[x]=parent[y];\n\t\t\tcnt++;\n\t\t\tsum=sum+e[i].w;\n\t\t}\n\t}\n\tif(cnt==n-1)printf(\"%.1lf\\n\",sum*100);\n\telse printf(\"oh!\\n\");\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tint i,j;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t\t}\n\t\tdouble f;\n\t\tcou=0;\n\t\tfor(i=1;i<n;i++)\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tf=sqrt((p[i].x-p[j].x)*(p[i].x-p[j].x)+(p[i].y-p[j].y)*(p[i].y-p[j].y));\n\t\t\t\tif(f>=10&&f<=1000)\n\t\t\t\t{\n\t\t\t\t\te[cou].w=f;\n\t\t\t\t\te[cou].u=i;\n\t\t\t\t\te[cou].v=j;\n\t\t\t\t\tcou++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(e,e+cou,cmp);\n\t\tkruskal();\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"hdu1301","url":"%2F2019%2F08%2F22%2Fhdu1301.html","content":"<p class=\"description\"></p>\nhdu1301,最小生成树，水\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1301\n\n## 题意\n\nT个城镇\n\n城镇名a、与城镇连接的城镇数n、接下来n组是与a连接的城镇名和距离\n\n求最小生成树\n\n## 细节\n\n(ˉ▽ˉ；)...输入有点麻烦，用cin比较方便\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int maxn=10010;\nstruct edge{\n\tint u,v,w;\n}e[maxn];\n\nint parent[maxn];\nbool cmp(edge a,edge b)\n{\n\treturn a.w<b.w;\n}\n\nint t;\nvoid set()\n{\n\tint i;\n\tfor(i=0;i<=t;i++)\n\t{\n\t\tparent[i]=i;\n\t}\n}\nint find_set(int x){\n    int k, i, r = x;\n    while(parent[r] != r) {\n        r = parent[r];\n    }\n    k = x;\n    while(k != r) {\n        i = parent[k];\n        parent[k] = r;\n        k = i;\n    }\n    return r;\n}\nint m;\nvoid kruskal()\n{\n\tset();\n\tint i,j,cnt=0,sum=0;\n\tfor(i=0;i<m&&cnt<t-1;i++)\n\t{\n\t\tint x=find_set(e[i].u);\n\t\tint y=find_set(e[i].v);\n\t\tif(x!=y)\n\t\t{\n\t\t\tparent[x]=parent[y];\n\t\t\tcnt++;\n\t\t\tsum=sum+e[i].w;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sum);\n}\n\nint main()\n{\n\twhile(scanf(\"%d\",&t),t)\n\t{\n\t\tchar a;\n\t\tint n,i=0;\n\t\tint j;\n\t\tfor(j=1;j<t;j++)\n\t\t{\n\t\t\tcin>>a>>n;\n\t\t\twhile(n--)\n\t\t\t{\n\t\t\t\tchar b;int c;\n\t\t\t\tcin>>b>>c;\n\t\t\t\te[i].u=a-'A'+1;\n\t\t\t\te[i].v=b-'A'+1;\n\t\t\t\te[i].w=c;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tm=i;\n\t\tsort(e,e+m,cmp);\n\t\tkruskal();\n\t}\n\t\n}\n```\n\n\n\n<hr />\n","tags":["kruskal"]},{"title":"hdu1233","url":"%2F2019%2F08%2F22%2Fhdu1233.html","content":"<p class=\"description\"></p>\nhdu1233,标准最小生成树\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1233\n\n## 题意\n\n某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。\n\n省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。\n\n请计算最小的公路总长度。\n\n## 细节\n\n(ˉ▽ˉ；)...\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn=10010;\nstruct edge{\n\tint u,v,w;\n}e[maxn];\nint n,k;\nint parent[maxn];\nbool cmp(edge a,edge b)\n{\n\treturn a.w<b.w;\n}\nvoid set()\n{\n\tint i;\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tparent[i]=i;\n\t}\n}\nint find_set(int x){\n    int k, i, r = x;\n    while(parent[r] != r) {\n        r = parent[r];\n    }\n    k = x;\n    while(k != r) {\n        i = parent[k];\n        parent[k] = r;\n        k = i;\n    }\n    return r;\n}\n\nvoid kruskal()\n{\n\tset();\n\tint i,j,cnt=0,sum=0;\n\tfor(i=0;i<k&&cnt<n-1;i++)\n\t{\n\t\tint x=find_set(e[i].u);\n\t\tint y=find_set(e[i].v);\n\t\tif(x!=y)\n\t\t{\n\t\t\tparent[x]=parent[y];\n\t\t\tcnt++;\n\t\t\tsum=sum+e[i].w;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sum);\n}\nint main()\n{\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tint i;\n\t\tk=n*(n-1)/2;\n\t\tfor(i=0;i<k;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&e[i].u,&e[i].v,&e[i].w);\n\t\t}\n\t\tsort(e,e+k,cmp);\n\t\tkruskal();\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["kruskal"]},{"title":"poj1679","url":"%2F2019%2F08%2F22%2Fpoj1679.html","content":"<p class=\"description\"></p>\npoj1679,次小生成树\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1679\n\n## 题意\n\n判断求出的最小生成树唯不唯一，唯一输出最小的权值，否者输出Not unique!\n\n## 细节\n\n用Kruskal 算出最小生成树的值，并记录每一条边，然后枚举去掉这些边\n\n看其是否也能构成最小生成树且值相同。\n\n注意 **在删边后，可能图构不成一棵树，得判断一下**\n\ndebug了很久，最后发现是数据开小了= =\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn=11000;\nconst int inf=0x3f3f3f3f;\nint parent[maxn];\nstruct edge{\n\tint u,v,w;\n}e[maxn];\nint n,m;\nbool cmp(edge a,edge b)\n{\n\treturn a.w<b.w;\n}\n\nvoid set() {\n    for(int i = 0; i <= n; i++)\n        parent[i] = i;\n}\n\nint find_set(int x){\n    int k, i, r = x;\n    while(parent[r] != r) {\n        r = parent[r];\n    }\n    k = x;\n    while(k != r) {\n        i = parent[k];\n        parent[k] = r;\n        k = i;\n    }\n    return r;\n}\n\nint kruskal(int n) {\n    int i, x, y,cnt = 0;\n    int sum;\n    set();\n    int b[maxn];\n    for(sum = 0, i = 0; i < m&&cnt<n-1; i++) {\n        x = find_set(e[i].u);\n        y = find_set(e[i].v);\n        if(x == y)continue;\n        parent[x] = parent[y]; ++cnt;\n        sum=sum+e[i].w;\n\t\tb[cnt]=i;\n    }\n    int j;\n    int k,ans=sum;\n    k=cnt;\n    for(j=1;j<=k;j++)\n    {\n    \tcnt=0;\n    \tset();\n    \tfor(sum = 0, i = 0; i < m&&cnt<n-1; i++) {\n    \tif(b[j]==i)continue;\n        x = find_set(e[i].u);\n        y = find_set(e[i].v);\n        if(x == y)continue;\n        parent[x] = parent[y]; ++cnt;\n        sum=sum+e[i].w;\n\t\t}\n\t\tif(cnt==n-1&&sum==ans)return -1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tint i;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&e[i].u,&e[i].v,&e[i].w);\n\t\t}\n\t\tsort(e,e+m,cmp);\n\t\tint ans=kruskal(n);\n\t\tif(ans==-1)printf(\"Not Unique!\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj3087","url":"%2F2019%2F08%2F16%2Fpoj3087.html","content":"<p class=\"description\"></p>\npoj3087,模拟\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3087\n\n## 题意\n\n已知两堆牌s1和s2的初始状态， 其牌数均为c，按给定规则能将他们相互交叉组合成一堆牌s12，再将s12的最底下的c块牌归为s1，最顶的c块牌归为s2，依此循环下去。\n\n 现在输入s1和s2的初始状态 以及 预想的最终状态s12\n\n问s1 s2经过多少次洗牌之后，最终能达到状态s12，若永远不可能相同，则输出\"-1\"。\n\n## 细节\n\n直接模拟就可以了，关键在于状态记录，然后判重\n\n若s1和s2在洗牌后的状态，是前面洗牌时已经出现过的一个状态，且这个状态不是预想的状态S12，就说明无论怎样再洗牌都不可能达到S12了，因为这个洗牌操作已经陷入了一个“环”\n\n如果状态没有重复过，则一直模拟洗牌，直至s12出现\n\n记录状态可以用map<string,bool>vist\n\n**Map的缺省值为0**\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <map>\nusing namespace std;\nconst int maxn=210;\nint main()\n{\n\tint test,t,n,i;\n\tscanf(\"%d\",&test);\n\tfor(t=1;t<=test;t++)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tgetchar();\n\t\tchar s1[maxn],s2[maxn],s12[maxn*2];\n\t\tgets(s1);\n\t\tgets(s2);\n\t\tgets(s12);\n\t\tmap<string,bool>vis;\n\t\tvis[s12]=true;\n\t\tint ans=0;\n\t\twhile(true)\n\t\t{\n\t\t\tchar s[maxn*2];\n\t\t\tint k=0;\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\ts[k++]=s2[i];\n\t\t\t\ts[k++]=s1[i];\n\t\t\t}\n\t\t\ts[k]='\\0';\n\t\t\tans++;\n\t\t\tif(!strcmp(s,s12))\n\t\t\t{\n\t\t\t\tprintf(\"%d %d\\n\",t,ans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(vis[s]&&strcmp(s,s12))\n\t\t\t{\n\t\t\t\tprintf(\"%d -1\\n\",t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvis[s]=true;\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\ts1[i]=s[i];\n\t\t\t}s1[i]='\\0';\n\t\t\tfor(k=0;i<2*n;i++)\n\t\t\t{\n\t\t\t\ts2[k++]=s[i];\n\t\t\t}\n\t\t\ts2[i]='\\0';\n\t\t}\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["模拟"],"categories":["poj"]},{"title":"poj3126","url":"%2F2019%2F08%2F16%2Fpoj3126.html","content":"<p class=\"description\"></p>\npoj3126,素数判断+bfs\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3126\n\n## 题意\n\n给出n，m两个四位素数，n一次只能变换一位\n\n问n最少变换几次可以变成m\n\n## 细节\n\n因为只有四位素数，因此先给四位素数打个表\n\n然后bfs\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <cmath>\nusing namespace std;\nbool prime[10010];\nbool isprime(int n)\n{\n    if(n == 0 || n == 1) return false;\n    if(n == 2 || n == 3) return true;\n    if(n%6 != 1 && n%6 != 5) return false;\n    int t = sqrt(n);\n    for(int i = 5; i <= t; i+=6)\n    {\n        if(n%i == 0 || n%(i+2) == 0)\n            return false;\n    }\n    return true;\n}\nstruct node\n{\n\tint x,s;\n}f;\nint n,m;\nbool vis[10010];\nqueue <node>q;\nvoid bfs()\n{\n\tint i;\n\tq.push(f);\n\tvis[f.x]=true;\n\twhile(!q.empty())\n\t{\n\t\tnode u=q.front();\n\t\t//printf(\"%d\\n\",u.x);\n\t\tif(u.x==m)\n\t\t{\n\t\t\tprintf(\"%d\\n\",u.s);\n\t\t\treturn ;\n\t\t} \n\t\tq.pop();\n\t\tnode k;\n\t\tfor(i=0;i<10;i++)\n\t\t{\n\t\t\tk.x=u.x/10*10;\n\t\t\tif(i%2==1)\n\t\t\t{\n\t\t\t\tif(prime[k.x+i]&&k.x+i!=u.x&&vis[k.x+i]!=true)\n\t\t\t\t{\n\t\t\t\t\tk.x=k.x+i;\n\t\t\t\t\tk.s=u.s+1;\n\t\t\t\t\tq.push(k);\n\t\t\t\t\tvis[k.x]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<10;i++)\n\t\t{\n\t\t\tk.x=u.x/100*100+u.x%10;\n\t\t\tif(prime[k.x+i*10]&&k.x+i*10!=u.x&&vis[k.x+i*10]!=true)\n\t\t\t\t{\n\t\t\t\t\tk.x=k.x+i*10;\n\t\t\t\t\tk.s=u.s+1;\n\t\t\t\t\tq.push(k);\n\t\t\t\t\tvis[k.x]=true;\n\t\t\t\t}\n\t\t}\n\t\tfor(i=0;i<10;i++)\n\t\t{\n\t\t\tk.x=u.x/1000*1000+(u.x%1000)%100;\n\t\t\tif(prime[k.x+i*100]&&k.x+i*100!=u.x&&vis[k.x+i*100]!=true)\n\t\t\t\t{\n\t\t\t\t\tk.x=k.x+i*100;\n\t\t\t\t\tk.s=u.s+1;\n\t\t\t\t\tq.push(k);\n\t\t\t\t\tvis[k.x]=true;\n\t\t\t\t}\n\t\t}\n\t\tfor(i=1;i<10;i++)\n\t\t{\n\t\t\tk.x=u.x%1000;\n\t\t\tif(prime[k.x+i*1000]&&k.x+i*1000!=u.x&&vis[k.x+i*1000]!=true)\n\t\t\t\t{\n\t\t\t\t\tk.x=k.x+i*1000;\n\t\t\t\t\tk.s=u.s+1;\n\t\t\t\t\tq.push(k);\n\t\t\t\t\tvis[k.x]=true;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i,t;\n\tmemset(prime,false,sizeof(prime));\n\tfor(i=1000;i<=9999;i++)\n\t{\n\t\tif(isprime(i))prime[i]=true;\n\t}\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\twhile(!q.empty())q.pop();\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tf.x=n;\n\t\tf.s=0;\n\t\tbfs();\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["bfs"],"categories":["poj"]},{"title":"朴素的素数判断","url":"%2F2019%2F08%2F16%2F%E6%9C%B4%E7%B4%A0%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD.html","content":"<p class=\"description\"></p>\n## 朴素的素数判断\n\n适用范围：n<=1e9\n\n大数见:[Miller-Rabin](/2019/08/16/Miller-Rabin.html)\n\n![](https://lmf424.oss-cn-beijing.aliyuncs.com/xiangcai.gif)\n\n<!-- more -->\n\n## 普通版：O(sqrt(n))\n\n i  从 2 到 sqrt（n） ，一个一个 判断，是不是 n 的因数，\n\n稍微优化一下，当 i > 2 时，只需要判断 i 是奇数的情况。\n\n```c++\n\nbool isprime(int n)\n{\n    int t = sqrt(n);\n    if(n == 2 || n == 3) return true;\n    for(int i = 2; i <= t; i++)\n    {\n        if(i > 2 && (i&1) == 0) continue;\n        if(n%i == 0) return false;\n    }\n    return true;\n}\n```\n\n\n\n## 豪华版 ：O(sqrt(n) / 3)\n\n实际做题的话要更快\n\n经过观察，**所有的素数都分布在 6 的倍数 两侧 （2 ，3 除外）。**\n\n所以 （n % 6 ！= 1） &&（ n % 6 ！= 5） 的 一定不是素数。\n\n当然满足条件的也**可能不是素数**\n\n```c++\n\nbool isprime(int n)\n{\n    if(n == 0 || n == 1) return false;\n    if(n == 2 || n == 3) return true;\n    if(n%6 != 1 && n%6 != 5) return false;\n    int t = sqrt(n);\n    for(int i = 5; i <= t; i+=6)\n    {\n        if(n%i == 0 || n%(i+2) == 0)\n            return false;\n    }\n    return true;\n}\n```\n\n\n\n## 欧拉筛打表 O( n )\n\n注意这里的 O（ n ） ,的 n 是打表的长度，比如，找出 1~n 的 所有素数，\n\n显然，n 为 1e9 的话是不可能打表的，就算能也是会超时的，\n\n如果用欧拉筛来判断一个 1e9 的数是否是素数，只需要大概打表到 `3e4` 就可以了！！！！！！！\n\n因为：\n\n任意一个数 n 都可以表示成若干质数的乘积，所以对于一个 1e9 的数 n ，先求出1~sqrt( 1e9 ) 的所有质数\n\n（ sqrt( 1e9 ) = 31628 ）\n\n再用 n 一个一个与这些质数比较 ， 如果这些质数中没有 n 的因数， 那么 n 一定是一个质数！\n\n因为 1~sqrt（n） 中没有 n 的质因数的话，> sqrt(n) 中一定没有 n 的因数。\n\n```c++\ntypedef long long LL;\nconst int MAXN = 31628; \nint prm[MAXN+1],vis[MAXN+1], cnt = 0;\n \nvoid init()\n{\n    for(int i = 2; i <= MAXN; i++)\n    {\n        if(!vis[i]) prm[cnt++] = i; // 没有被标记的就是素数\n        for(int j = 0; j < cnt; j++)\n        {\n            LL t = i*prm[j];\n            if(t > MAXN) break;\n            vis[t] = 1;   \n            if(i%prm[j] == 0) break;\n        }\n    }\n    return ;\n}\n \nbool isprime(int n)\n{\n    if(n <= MAXN)\n    {\n        if(vis[n] == 0) return true;\n        return false;\n    }\n    else\n    {\n        for(int i = 0; i < cnt; i++)\n            if(n%prm[i] == 0)\n                return false;\n    }\n    return true;\n}\n```\n\n上面的if(i % prim[j] == 0 ) break;   是完成上面要求的重要条件\n\n我们首先知道一个合数一定可以表示成素数的乘积，那么也一定可以表示成他的最小质因数乘以另外一个数，已知prim数组中的素数是依次递增的，\n\n当i满足i%prim[j] ==  0的时候，\n\n假如我们继续执行，那么下一个要判断为不是质数的数为：prim[j+1]*i  \n\n但是我们发现这个数的最小质因数一定是prim[j] ，因为这里的i满足i%prim[j] == 0 ，prim[j]是他的最小质因数，所以这里就和我们上面的要求有矛盾，\n\n当我们遇到后面x满足：prim[j] * x = prim[j+1]*i时，又会重新判断一次这个数字\n\n<hr />\n","tags":["prime"],"categories":["algorithm"]},{"title":"Miller-Rabin","url":"%2F2019%2F08%2F16%2FMiller-Rabin.html","content":"<p class=\"description\"></p>\n## Miller-Rabin素数测试算法\n\n有时候我们想快速的知道一个数是不是素数，而这个数又特别的大导致 O （√n）的算法不能通过，这时候我们可以对其进行 Miller-Rabin 素数测试，可以**大概率**测出其是否为素数。\n\n转载自forever_dreamsd大佬:[Miller-Rabin素数测试算法](https://blog.csdn.net/forever_dreams/article/details/82314237)\n\n<!-- more -->\n\n## 基础理论\n\n![1565940377100](Miller-Rabin\\1565940377100.png)\n\n[^Carmichael数]: 每个Carmichael至少是三个不同素数的乘积。如561=3* 11 *17。前3个Carmichael数是561,1105,1729。Carmichael数是非常少的。在1~100000000范围内的整数中，只有255个Carmichael数。\n\n## 基础理论证明\n\n![img](Miller-Rabin\\20180902152616155.jfif)\n\n## 算法流程\n\n![1565941020088](Miller-Rabin\\1565941020088.png)\n\n## 备注\n\n![1565941050512](Miller-Rabin\\1565941050512.png)\n\n## 代码\n\n```c++\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint prime[10]={2,3,5,7,11,13,17,19,23,29};\nint Quick_Multiply(int a,int b,int c)  //快速积（和快速幂差不多） \n{\n    long long ans=0,res=a;\n    while(b)\n    {\n        if(b&1)\n          ans=(ans+res)%c;\n        res=(res+res)%c;\n        b>>=1;\n    }\n    return (int)ans;\n}\nint Quick_Power(int a,int b,int c)     //快速幂，这里就不赘述了 \n{\n    int ans=1,res=a;\n    while(b)\n    {\n        if(b&1)\n          ans=Quick_Multiply(ans,res,c);\n        res=Quick_Multiply(res,res,c);\n        b>>=1;\n    }\n    return ans;\n}\nbool Miller_Rabin(int x)     //判断素数 \n{\n    int i,j,k;\n    int s=0,t=x-1;\n    if(x==2)  return true;   //2是素数 \n    if(x<2||!(x&1))  return false;     //如果x是偶数或者是0,1，那它不是素数 \n    while(!(t&1))  //将x分解成(2^s)*t的样子 \n    {\n        s++;\n        t>>=1;\n    }\n    for(i=0;i<10&&prime[i]<x;++i)      //随便选一个素数进行测试 \n    {\n        int a=prime[i];\n        int b=Quick_Power(a,t,x);      //先算出a^t\n        for(j=1;j<=s;++j)    //然后进行s次平方 \n        {\n            k=Quick_Multiply(b,b,x);   //求b的平方 \n            if(k==1&&b!=1&&b!=x-1)     //用二次探测判断 \n              return false;\n            b=k;\n        }\n        if(b!=1)  return false;   //用费马小定律判断 \n    }\n    return true;   //如果进行多次测试都是对的，那么x就很有可能是素数 \n}\nint main()\n{\n    int x;\n    scanf(\"%d\",&x);\n    if(Miller_Rabin(x))  printf(\"Yes\");\n    else  printf(\"No\");\n    return 0;\n}\n```\n\n\n\n<hr />\n","tags":["Miller-Rabin"],"categories":["algorithm"]},{"title":"poj1426","url":"%2F2019%2F08%2F16%2Fpoj1426.html","content":"<p class=\"description\"></p>\npoj1426,bfs/dfs/bfs+同余模定理\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1426\n\n## 题意\n\n给出一个整数n，(1 <= n <= 200)。求出任意一个它的倍数m，要求m必须只由十进制的'0'或'1'组成。\n\n## 细节\n\n基础是1，入口为x10和x10+1\n\nbfs:360ms\n\ndfs:141ms\n\ndfs+同余模定理:32ms(大佬tql)\n\n详解：https://blog.csdn.net/lyy289065406/article/details/6647917\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <queue>\nusing namespace std;\nint n;\nint flag;\nvoid dfs(unsigned long long t,int k)\n{\n\tif(flag==1)return ;\n\tif(t%n==0)\n\t{\n\t\tflag=1;\n\t\tprintf(\"%llu\\n\",t);\n\t\treturn ;\n\t}\n\tif(k==19)return ;\n\tdfs(t*10,k+1);\n\tdfs(t*10+1,k+1);\n}\n\nqueue<unsigned long long int>q;\nunsigned long long int k;\n\nvoid bfs(int x)\n{\n\twhile(!q.empty())q.pop();\n\t\tq.push(1);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tk=q.front();\n\t\t\tq.pop();\n\t\t\tif(k%n==0)\n\t\t\t{\n\t\t\t\tprintf(\"%llu\\n\",k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tif(k*10<=1e19)\n\t\t\t\tq.push(k*10);\n\t\t\t\tq.push(k*10+1);\n\t\t\t}\n\t\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d\",&n)!=EOF&&n)\n\t{\n\t\t//dfs(1,0);\n\t\tbfs(n);\n\t}\n}\n```\n\n\n\ndalao的代码:\n\n```c++\n#include<iostream>\nusing namespace std;\n \nint mod[524286];  //保存每次mod n的余数\n                  //由于198的余数序列是最长的\n                  //经过反复二分验证，436905是能存储198余数序列的最少空间\n                  //但POJ肯定又越界测试了...524286是AC的最低下限，不然铁定RE\n \nint main(int i)\n{\n\tint n;\n\twhile(cin>>n)\n\t{\n\t\tif(!n)\n\t\t\tbreak;\n \n\t\tmod[1]=1%n;  //初始化，n倍数的最高位必是1\n \n\t\tfor(i=2;mod[i-1]!=0;i++)  //利用同余模定理，从前一步的余数mod[i/2]得到下一步的余数mod[i]\n\t\t\tmod[i]=(mod[i/2]*10+i%2)%n;\n\t\t             //mod[i/2]*10+i%2模拟了BFS的双入口搜索\n\t\t             //当i为偶数时，+0，即取当前位数字为0  。为奇数时，则+1,即取当前位数字为1\n \n\t\ti--;\n\t\tint pm=0;\n\t\twhile(i)\n\t\t{\n\t\t\tmod[pm++]=i%2;   //把*10操作转化为%2操作，逆向求倍数的每一位数字\n\t\t\ti/=2;\n\t\t}\n\t\twhile(pm)\n\t\t\tcout<<mod[--pm];  //倒序输出\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n<hr />\n","tags":["dfs"],"categories":["poj"]},{"title":"poj3279","url":"%2F2019%2F08%2F16%2Fpoj3279.html","content":"<p class=\"description\"></p>\npoj3279,二进制搜索\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3279\n\n## 题意\n\n有一个m*n的棋盘，每个格子上是0或1，每次可以对一个格子做一次翻转操作，将被操作的格子和上下左右4个格子的0/1翻转。\n\n问最少做多少次翻转可以将所有格子翻转成0，输出翻转方案。没有方案时输出“IMPOSSIBLE”。\n\n## 细节\n\n啊以前写过的题目= =再写一遍给我wa成了傻子\n\n棋盘的每一行都会影响到下一行的反转，因此只需要穷举第一排所有的反转方式就好了\n\n然后判断下最后一排是不是全翻转成0了就好\n\n要输出最少的翻转次数，所以要记录一下最小翻转次数（就是这里）\n\n弄了好久才发现= =\n\n```c++\n//官方数据：\n7 8\n0 0 0 0 1 0 1 0\n0 0 0 0 0 0 1 0\n1 0 0 0 1 0 0 1\n0 1 0 1 1 0 0 1\n0 0 0 1 1 0 1 1\n0 0 0 1 0 0 0 0\n0 1 0 0 0 0 0 0\n//它的答案是：（26步）\n1 1 1 0 1 1 0 0\n0 1 0 0 1 0 0 0\n0 0 0 1 0 0 1 0\n1 1 1 1 1 1 1 0\n0 0 1 1 0 1 1 0\n1 0 1 0 0 1 0 0\n1 0 0 1 1 0 0 0\n\n//一开始我只按照字典序就算了个这个答案= =（30步）\n0 0 1 1 0 1 1 1 \n0 1 0 0 1 0 0 0 \n1 1 0 0 1 0 0 1 \n1 1 1 1 1 1 1 0 \n1 1 1 0 1 1 0 1 \n1 0 1 0 0 1 0 0 \n0 1 0 0 0 0 1 1 \n```\n\n## 代码\n\n```c++\n#include <cstdio>\nusing namespace std;\nint map[20][20];\nint e[20][20];\nint ans[20][20];\nint n,m;\nint finalans[20][20];\nconst int inf=0x3f3f3f3f;\nint fun(int x)\n{\n\tif(x==1)return 0;\n\telse return 1;\n}\n\nvoid init()\n{\n\tint i,j;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tmap[i][j]=e[i][j];\n\t\t\tans[i][j]=0;\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tint i,j;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tfinalans[i][j]=ans[i][j];\n\t\t}\n\t}\n}\n\nvoid pr()\n{\n\tint i,j;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tfor(j=1;j<n;j++)\n\t\t{\n\t\t\tprintf(\"%d \",finalans[i][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",finalans[i][j]);\n\t}\n}\n\nint f2(int x)\n{\n\tint i,ans=1;\n\tfor(i=1;i<=x;i++)\n\t{\n\t\tans=ans*2;\n\t}\n\treturn ans;\n}\n\nint min,count;\n\nint main()\n{\n\tint i,j,t,k,flag;\n\tbool find=false;\n\tscanf(\"%d%d\",&m,&n);\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&e[i][j]);\n\t\t}\n\t}\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tfinalans[i][j]=0;\n\t\t}\n\t}\n\tmin=inf;\n\tfor(i=0;i<f2(n);i++)\n\t{\n\t\tcount=0;\n\t\tt=i;\n\t\tinit();\n\t\tfor(j=n;j>=1;j--)\n\t\t{\n\t\t\tif(t%2==1)\n\t\t\t{\n\t\t\t\tans[1][j]=1;\n\t\t\t\tcount++;\n\t\t\t\tmap[1][j]=fun(map[1][j]);\n\t\t\t\tmap[1][j-1]=fun(map[1][j-1]);\n\t\t\t\tmap[1][j+1]=fun(map[1][j+1]);\n\t\t\t\tmap[2][j]=fun(map[2][j]);\n\t\t\t}\n\t\t\tt=t/2;\n\t\t}\n\t\tfor(j=2;j<=m;j++)\n\t\t{\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(map[j-1][k]==1)\n\t\t\t\t{\n\t\t\t\t\tans[j][k]=1;\n\t\t\t\t\tcount++;\n\t\t\t\t\tmap[j][k]=fun(map[j][k]);\n\t\t\t\t\tmap[j][k-1]=fun(map[j][k-1]);\n\t\t\t\t\tmap[j][k+1]=fun(map[j][k+1]);\n\t\t\t\t\tmap[j+1][k]=fun(map[j+1][k]);\n\t\t\t\t\tmap[j-1][k]=fun(map[j-1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tflag=0;\n\t\tfor(k=1;k<=n;k++)\n\t\t{\n\t\t\tif(map[m][k]==1)\n\t\t\t{\n\t\t\t\tflag=1;break;\n\t\t\t}\n\t\t}\n\t\tif(flag==0)\n\t\t{\n\t\t\tif(count<min)\n\t\t\t{\n\t\t\t\tmin=count;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t\tfind=true;\n\t\t}\n\t}\n\tif(find)pr();\n\telse printf(\"IMPOSSIBLE\\n\");\n}\n```\n\n\n\n<hr />\n","tags":["dfs"]},{"title":"poj3278","url":"%2F2019%2F08%2F16%2Fpoj3278.html","content":"<p class=\"description\"></p>\npoj3278,标准bfs\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3278\n\n## 题意\n\n输入n，m\n\nn可以进行+1，-1，*2三种操作\n\n问最少进行多少次操作，n变成m\n\n## 细节\n\nvis记录一下访问防止重复入队\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\nstruct node\n{\n\tint x,t;\n};\n\nqueue<node> q;\nbool vis[200010];\n\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tnode start;\n\tstart.x=n;\n\tstart.t=0;\n\tq.push(start);\n\tvis[n]=true;\n\tmemset(vis,false,sizeof(vis));\n\twhile(!q.empty())\n\t{\n\t\tnode x,next;\n\t\tx=q.front();\n\t\tq.pop();\n\t\tif(x.x==m)\n\t\t{\n\t\t\tprintf(\"%d\\n\",x.t);\n\t\t\tbreak;\n\t\t}\n\t\tif(vis[x.x*2]==false&&x.x*2<100010)\n\t\t{\n\t\t\tnext.x=x.x*2;\n\t\t\tnext.t=x.t+1;\n\t\t\tq.push(next);\n\t\t\tvis[x.x*2]=true;\n\t\t}\n\t\tif(vis[x.x-1]==false&&x.x-1>=0)\n\t\t{\n\t\t\tnext.x=x.x-1;\n\t\t\tnext.t=x.t+1;\n\t\t\tq.push(next);\n\t\t\tvis[x.x-1]=true;\n\t\t}\n\t\tif(vis[x.x+1]==false&&x.x+1<100010)\n\t\t{\n\t\t\tnext.x=x.x+1;\n\t\t\tnext.t=x.t+1;\n\t\t\tq.push(next);\n\t\t\tvis[x.x+1]=true;\n\t\t}\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["bfs"],"categories":["poj"]},{"title":"poj2251","url":"%2F2019%2F08%2F16%2Fpoj2251.html","content":"<p class=\"description\"></p>\npoj2251,三维bfs\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2251\n\n## 题意\n\n给出一三维空间的地牢,要求求出由字符'S'到字符'E'的最短路径移动方向可以是上，下，左，右，前，后，六个方向，每移动一次就耗费一分钟，要求输出最快的走出时间。不同L层的地图，相同RC坐标处是连通的，“#”不可通过，“.”可走。\n\n## 细节\n\n标准bfs\n\n## 代码\n\n```c++\n#include <iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\nbool visit[35][35][35];\nchar map[35][35][35];\nint dir[6][3]={0,0,1,0,1,0,1,0,0,-1,0,0,0,-1,0,0,0,-1};\nint flag;\nint l,r,c;\nstruct node\n{\n\tint x,y,z;\n\tint s;\n};\nqueue<node> q;\nvoid init()\n{\n\twhile(!q.empty())q.pop();\n\tmemset(visit,false,sizeof(visit));\n\tmemset(map,'.',sizeof(map));\n\tflag=0;\n}\nint check(int x,int y,int z)\n{\n    if(x<0 || y<0 || z<0 || x>=l || y>=r || z>=c)\n        return 1;\n    else if(map[x][y][z] == '#')\n        return 1;\n    else if(visit[x][y][z])\n        return 1;\n    return 0;\n}\nint main()\n{\n\tint i,j,k;\n\tchar ch;\n\twhile(scanf(\"%d%d%d\",&l,&r,&c)&&(l||r||c))\n\t{\n\t\tinit();\n\t\tgetchar();//吃回车\n\t\tnode start;\n\t\tfor(i=0;i<l;i++)\n\t\t{\n\t\t\tfor(j=0;j<r;j++)\n\t\t\t{\n\t\t\t\tfor(k=0;k<c;k++)//三维的输入\n\t\t\t\t{\n\t\t\t\tcin>>ch;\n\t\t\t\tmap[i][j][k]=ch;\n\t\t\t\t\tif(ch=='S')\t//记录起点位置\n\t\t\t\t\t{\n\t\t\t\t\t\tstart.x=i;\n\t\t\t\t\t\tstart.y=j;\n\t\t\t\t\t\tstart.z=k;\n\t\t\t\t\t\tstart.s=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tgetchar();\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tq.push(start);\n\t\tvisit[start.x][start.y][start.z]=1;//标记\n\t\twhile(!q.empty())\n\t\t{\n\t\tnode m=q.front();\n\t\tq.pop();\n\t\tif(map[m.x][m.y][m.z]=='E')\n\t\t\t{\n\t\t\t\tprintf(\"Escaped in %d minute(s).\\n\",m.s);\n\t\t\t\tflag=1;//已经找到\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t\tnode next;\n\t\t\tfor(i=0;i<6;i++)\n\t\t\t{\n\t\t\t\tnext=m;\n\t\t\t\tnext.x=next.x+dir[i][0];\n\t\t\t\tnext.y=next.y+dir[i][1];\n\t\t\t\tnext.z=next.z+dir[i][2];\n\t\t\t\tif(check(next.x,next.y,next.z))continue;\n\t\t\t\tvisit[next.x][next.y][next.z]=true;\n\t\t\t\tnext.s=m.s+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tif(!flag)\n\t\tputs(\"Trapped!\");\n\t}\n\treturn 0;\n}\n```\n\n\n\n<hr />\n"},{"title":"poj1321","url":"%2F2019%2F08%2F15%2Fpoj1321.html","content":"<p class=\"description\"></p>\npoj1321,简单dfs\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1321\n\n## 题意\n\n在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。\n\n要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列\n\n请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。\n\n## 细节\n\n简单dfs，回溯之后记得更改标记\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint n,m;\nchar map[10][10];\nbool vis[10];\nint ans,k;\nvoid dfs(int x)\n{\n\tif(m==k)\n\t{\n\t\tans++;\n\t\treturn ;\n\t}\n\tif(x>n)\n\t{\n\t\treturn ;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(vis[i]==0&&map[x][i]=='#')//判断条件 \n\t\t{\n\t\t\tvis[i]=true;//标记可用 \n\t\t\tk++;\n\t\t\tdfs(x+1);//下一行 \n\t\t\tvis[i]=false;//回溯之后改回来方便下一列的判断 \n\t\t\tk--;\n\t\t}\n\t}\n\tdfs(x+1);//下一行 \n}\nint main()\n{\n\tint i,j;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF&&n!=-1&&k!=-1)\n\t{\n\t\tans=0;\n\t\tk=0;\n\t\tgetchar();\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tgets(map[i]);\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tdfs(1);//开始的行数\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["dfs"],"categories":["poj"]},{"title":"poj1258","url":"%2F2019%2F08%2F13%2Fpoj1258.html","content":"<p class=\"description\"></p>\npoj1258,最小生成树，水\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1258\n\n## 题意\n\n给你N*N矩阵，表示N个村庄之间的距离。FJ要把N个村庄全都连接起来，求连接的最短距离。\n\n## 细节\n\n多组输入，记得sum清空\n\n## 代码\n\n```c++\n#include <cstdio>\nusing namespace std;\nint e[110][110];\nconst int inf=0x3f3f3f3f;\nint lowcost[110];\n\nint sum=0,n;\nvoid prim()\n{\n\tsum=0;\n\tint i,j;\n\tlowcost[1]=0;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tlowcost[i]=e[1][i];\n\t}\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint max=inf;\n\t\tint temp;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(lowcost[j]!=0&&lowcost[j]<max)\n\t\t\t{\n\t\t\t\tmax=lowcost[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tsum=sum+lowcost[temp];\n\t\tlowcost[temp]=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[temp][j]<lowcost[j])\n\t\t\t{\n\t\t\t\tlowcost[j]=e[temp][j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tint i,j;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&e[i][j]);\n\t\t\t}\n\t\tprim();\n\t\tprintf(\"%d\\n\",sum);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["prim"],"categories":["poj"]},{"title":"poj1751","url":"%2F2019%2F08%2F13%2Fpoj1751.html","content":"<p class=\"description\"></p>\npoj1751,kruskal\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1751\n\n## 题意\n\n有一个N个城市M条路的无向图\n\n给你N个城市的坐标,现在该无向图已经有M条边了\n\n问你还需要添加总长为多少的边能使得该无向图连通\n\n输出需要添加边的两端点编号即可\n\n## 细节\n\n计算每个城市间的距离，已经有的边权值置0，kruskal中加入的边如果权值不是0那么就是需要加的边，输出即可\n\n## 代码\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int N = 760;\nint n,m,k;\nstruct point\n{\n\tdouble x,y;\n}po[N];\n\nstruct EDG {\n    int v;\n    int u;\n    double w;\n}edg[600010];\n\nint parent[N];\n\nbool cmp(EDG a, EDG b) {\n    return a.w < b.w;\n}\n\nvoid set() {\n    for(int i = 0; i <= m; i++)\n        parent[i] = i;\n}\n\nint find_set(int x){\n    int k, i, r = x;\n    while(parent[r] != r) {\n        r = parent[r];\n    }\n    k = x;\n    while(k != r) {\n        i = parent[k];\n        parent[k] = r;\n        k = i;\n    }\n    return r;\n}\ndouble ans[N];\nint flag;\nvoid kruskal(int n) {\n    int i, x, y,cnt = 0;\n    double sum;\n    set();\n    int tt=0;\n    for(sum = 0, i = 0; i < k && cnt < n-1; i++) {\n        x = find_set(edg[i].u);\n        y = find_set(edg[i].v);\n        if(x == y)    continue;\n        parent[x] = parent[y]; ++cnt;\n        if(edg[i].w!=0)printf(\"%d %d\\n\",edg[i].u,edg[i].v);\n    }\n}\n\nint main()\n{\n\t\tscanf(\"%d\",&m);\n\t\tint i,j;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&po[i].x,&po[i].y); \n\t\t}\n\t\tk=0;\n\t\tscanf(\"%d\",&n);\n\t\tflag=n;\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d\",&edg[k].u,&edg[k].v);\n\t\t\tedg[k].w=0;\n\t\t\tk++;\n\t\t}\n\t\tfor(i=1;i<=m;i++)\n\t\t\t{\n\t\t\t\tfor(j=i+1;j<=m;j++)\n\t\t\t\t{\n\t\t\t\t\tedg[k].u=i;\n\t\t\t\t\tedg[k].v=j;\n\t\t\t\t\tedg[k].w=(po[i].x-po[j].x)*(po[i].x-po[j].x)+(po[i].y-po[j].y)*(po[i].y-po[j].y);\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\tsort(edg, edg+k, cmp);\n\t\tkruskal(m);\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj2349","url":"%2F2019%2F08%2F13%2Fpoj2349.html","content":"<p class=\"description\"></p>\npoj2349,kruskal\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2349\n\n## 题意\n\n有两种不同的通信技术，有卫星通信的两个城市之间可以任意联络，但用无线电通信的城市只能和距离不超过D的城市联系。无线电的能力越高（即传输距离D越大），花费就越大。已知无线电的数目m，让求最小的D。\n\n## 细节\n\n本质上求的就是最小生成树中的第（城市数量-卫星数量-1）的边的权值\n\n## 代码\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int N = 510;\nint n,m,k;\nstruct point\n{\n\tdouble x,y;\n}po[N];\n\nstruct EDG {\n    int v;\n    int u;\n    double w;\n}edg[500050];\n\nint parent[N];\n\nbool cmp(EDG a, EDG b) {\n    return a.w < b.w;\n}\n\nvoid set() {\n    for(int i = 0; i <= m; i++)\n        parent[i] = i;\n}\n\nint find_set(int x){\n    int k, i, r = x;\n    while(parent[r] != r) {\n        r = parent[r];\n    }\n    k = x;\n    while(k != r) {\n        i = parent[k];\n        parent[k] = r;\n        k = i;\n    }\n    return r;\n}\ndouble ans[N];\nvoid kruskal(int n) {\n    int i, x, y,cnt = 0;\n    double sum;\n    set();\n    int tt=0;\n    for(sum = 0, i = 0; i < k && cnt < n-1; i++) {//一开始让我wa的头皮发麻的地方\n        //判断条件我写的i<n，后面仔细思考了下总共有k条边\n        x = find_set(edg[i].u);\n        y = find_set(edg[i].v);\n        if(x == y)    continue;\n        parent[x] = parent[y]; ++cnt;\n        ans[tt++]=edg[i].w;\n    }\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tint i,j;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&po[i].x,&po[i].y); \n\t\t}\n\t\tk=0;\n\t\tfor(i=1;i<=m;i++)\n\t\t\t{\n\t\t\t\tfor(j=i+1;j<=m;j++)\n\t\t\t\t{\n\t\t\t\t\tedg[k].u=i;\n\t\t\t\t\tedg[k].v=j;\n\t\t\t\t\tedg[k].w=sqrt((po[i].x-po[j].x)*(po[i].x-po[j].x)+(po[i].y-po[j].y)*(po[i].y-po[j].y));\n\t\t\t\t\tk++;\n\t\t\t\t\tedg[k].u=edg[k-1].v;\n\t\t\t\t\tedg[k].v=edg[k-1].u;\n\t\t\t\t\tedg[k].w=edg[k-1].w;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\tsort(edg, edg+k, cmp);\n\t\tkruskal(m);\n\t\tprintf(\"%.2f\\n\",ans[m-n-1]);\n\t}\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"kruskal","url":"%2F2019%2F08%2F13%2Fkruskal.html","content":"<p class=\"description\"></p>\n## kruskal算法\n\n最小生成树之kruskal算法\n\n复杂度：O(|Elog|E|)\n\n<!-- more -->\n\n## 具体流程\n\n(1)将图`G`看做一个森林，每个顶点为一棵独立的树\n\n(2)将所有的边加入集合`S`，即一开始`S = E`\n\n(3)从`S`中拿出一条最短的边`(u,v)`，如果`(u,v)`不在同一棵树内，则连接`u`,`v`合并这两棵树，同时将`(u,v)`加入生成树的边集`E'`\n\n(4)重复(3)直到所有点属于同一棵树，边集`E'`就是一棵最小生成树\n\n## 图解\n\n![img](kruskal\\20150816105532486.jfif)\n\n首先，我们将所有的边都进行从小到大的排序。排序之后根据贪心准则，我们选取最小边`(A,D)`。我们发现顶点`A`,`D`不在一棵树上，所以合并顶点`A`,`D`所在的树，并将边`(A,D)`加入边集`E'`。\n\n![img](kruskal\\20150816111905267.jfif)\n\n我们接着在剩下的边中查找权值最小的边，于是我们找到的`(C,E)`。我们可以发现，顶点`C`,`E`仍然不在一棵树上，所以我们合并顶点`C`，`E`所在的树，并将边`(C,E)`加入边集`E'`\n\n![img](kruskal\\20150816112526131.jfif)\n\n不断重复上述的过程，于是我们就找到了无向图B的最小生成树，如下图所示：\n\n![img](kruskal\\20150816113249128.jfif)\n\n## 代码\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1000;\n\nstruct EDG {\n    int v;\n    int u;\n    int w;\n}edg[N];\n\nint parent[N];\n\nbool cmp(EDG a, EDG b) {\n    return a.w < b.w;\n}\n\nvoid set() {\n    for(int i = 0; i < N; i++)\n        parent[i] = i;\n}\n\nint find_set(int n){\n    int k, i, r = n;\n    while(parent[r] != r) {\n        r = parent[r];\n    }\n    k = n;\n    while(k != r) {\n        i = parent[k];\n        parent[k] = r;\n        k = i;\n    }\n    return r;\n}\n\nint kruskal(int n) {\n    int i, x, y, sum, cnt = 0;\n    set();\n    for(sum = 0, i = 0; i < n && cnt < n-1; i++) {\n        x = find_set(edg[i].u);\n        y = find_set(edg[i].v);\n        if(x == y)    continue;\n        parent[x] = parent[y]; ++cnt;\n        sum += edg[i].w;\n    }\n    return sum;\n}\n\nint main() {\n    int n, m, i, u, v, w;\n    cin >> m >> n;\n    for(i = 0; i < n; i++)  {\n        scanf(\"%d%d%d\", &u, &v, &w);\n        edg[i].v = v;\n        edg[i].u = u;\n        edg[i].w = w;\n    }\n    sort(edg, edg+n, cmp);\n    cout << kruskal(n) << endl;\n    return 0;\n}\n```\n\n\n\n<hr />\n","tags":["kruskal"],"categories":["algorithm"]},{"title":"poj1789","url":"%2F2019%2F08%2F13%2Fpoj1789.html","content":"<p class=\"description\"></p>\npoj1789，最小生成树，水= =\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1789\n\n## 题意\n\nn个车牌号，刚开始只有一个车牌，其他车牌都是由一个车牌直接或间接产生\n\n一个车牌到另一个车牌的产生权值是它们之间的数字不同的个数\n\n输出最小生成树边权和倒数\n\n## 细节\n\n水！\n\n## 代码\n\n```c++\n#include <cstdio>\nusing namespace std;\nchar s[2010][10];\nint e[2010][2010];\nint n;\nconst int inf=0x3f3f3f3f;\nint lowcost[2010];\nint prim()\n{\n\tint ans=0;\n\tint i;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tlowcost[i]=e[1][i];\n\t}\n\tlowcost[1]=-1;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tint j,min=inf,temp;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(lowcost[j]!=-1&&lowcost[j]<min)\n\t\t\t{\n\t\t\t\tmin=lowcost[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tans=ans+lowcost[temp];\n\t\tlowcost[temp]=-1;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[temp][j]<lowcost[j])\n\t\t\t{\n\t\t\t\tlowcost[j]=e[temp][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tint i,j,k,sum;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%s\",s[i]);\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=i;j<=n;j++)\n\t\t\t{\n\t\t\t\te[i][j]=inf;\n\t\t\t\tif(i==j)e[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=i;j<=n;j++)\n\t\t\t{\n\t\t\t\tsum=0;\n\t\t\t\tfor(k=0;k<7;k++)\n\t\t\t\t{\n\t\t\t\t\tif(s[i][k]!=s[j][k])sum++;\n\t\t\t\t}\n\t\t\t\te[i][j]=sum;\n\t\t\t\te[j][i]=sum;\n\t\t\t}\n\t\t}\n\t\tprintf(\"The highest possible quality is 1/%d.\\n\" ,prim()) ;\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["prim"],"categories":["poj"]},{"title":"快速输入","url":"%2F2019%2F08%2F12%2F%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5.html","content":"<p class=\"description\"></p>\n终极蛇皮之求求你做个人吧偷鸡过TLE之快速输入\n\n![](https://lmf424.oss-cn-beijing.aliyuncs.com/shua.gif)\n\ncin 没有 scanf 快，那么还有比 scanf还快的输入吗？那就是getchar()，它比scanf快多了，输入挂就是根据它写的，具体代码（代码是看大牛的）如下：\n\n<!-- more -->\n\n### int：\n\n```c++\ninline bool scan_d(int &num)  \n{\n        char in;bool IsN=false;\n        in=getchar();\n        if(in==EOF) return false;\n        while(in!='-'&&(in<'0'||in>'9')) in=getchar();\n        if(in=='-'){ IsN=true;num=0;}\n        else num=in-'0';\n        while(in=getchar(),in>='0'&&in<='9'){\n                num*=10,num+=in-'0';\n        }\n        if(IsN) num=-num;\n        return true;\n}\n```\n\n### double：\n\n```c++\ninline bool scan_lf(double &num)  \n{\n        char in;double Dec=0.1;\n        bool IsN=false,IsD=false;\n        in=getchar();\n        if(in==EOF) return false;\n        while(in!='-'&&in!='.'&&(in<'0'||in>'9'))\n                in=getchar();\n        if(in=='-'){IsN=true;num=0;}\n        else if(in=='.'){IsD=true;num=0;}\n        else num=in-'0';\n        if(!IsD){\n                while(in=getchar(),in>='0'&&in<='9'){\n                        num*=10;num+=in-'0';}\n        }\n        if(in!='.'){\n                if(IsN) num=-num;\n                return true;\n        }else{\n                while(in=getchar(),in>='0'&&in<='9'){\n                        num+=Dec*(in-'0');Dec*=0.1;\n                }\n        }\n        if(IsN) num=-num;\n        return true;\n}\n```\n\n### 求求你做个人吧终极版本：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n// *Copyright by i.Pear Works*\n//本IO模块的用途是方便地读写大量整数\n//若题目整数不多 请改用关闭同步锁的cin(因为本模块不支持关闭同步锁)或scanf\nnamespace FastIO{\n \n//不支持while(qin>>x)的多组数据输入方法\n//任何情况下请不要关闭sync_with_stdio同步锁!!\n//如果您选择关闭同步锁以获得更高的cin/cout速度 使用此模块会导致不可预期的后果\n \n//此处为负数读取功能开关\n//若程序不会读入负数 请去除下方注释符号 以获得30%的输入提速\n//#define DisableNegative true\n \n//此处为兼容性模式开关 若程序IO存在 *任何* *int/ll/char[]/string/char(包括空格回车)* 之外的类型\n//请去除下方注释符号 降低一半的速度以获得兼容性\n//#define EnableCompatibility true\n \n    class Scanner{\n        char cht;\n        bool ifNegative;\n        char stringBuf[10000];\n#ifndef EnableCompatibility\n#define BUF_SIZE 524288\n        char nc(){\n            static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;\n            if(p1==pend){\n                p1=buf;\n                pend=buf+fread(buf,1,BUF_SIZE,stdin);\n                if(pend==p1)return ' ';\n            }\n#ifndef DisableNegative\n            if(*p1=='-'){\n                ifNegative=true;\n                p1++;\n                return nc();\n            }\n#endif\n            return *p1++;\n        }\n#else\n        inline char nc(){\n            return getchar();\n        }\n#endif\n        inline bool blank(char ch){\n            return ch=='\\r'||ch=='\\n'||ch==' '||ch=='\\t';\n        }\n    public:\n        Scanner operator>>(int&x){\n#ifndef DisableNegative\n            ifNegative=false;\n#endif\n            while(blank(cht=nc()));\n            for(x=cht-'0';(cht=nc())>='0'&&cht<='9';x=x*10+cht-'0');\n#ifndef DisableNegative\n            if(ifNegative)x*=-1;\n#endif\n            return *this;\n        }\n        Scanner operator>>(long long int&x){\n#ifndef DisableNegative\n            ifNegative=false;\n#endif\n            while(blank(cht=nc()));\n            for(x=cht-'0';(cht=nc())>='0'&&cht<='9';x=x*10+cht-'0');\n#ifndef DisableNegative\n            if(ifNegative)x*=-1;\n#endif\n            return *this;\n        }\n        Scanner operator>>(string&str){\n            int p=0;\n            while(blank(cht=nc()));\n            for(stringBuf[p++]=cht;!blank(cht=nc());stringBuf[p++]=cht);\n            stringBuf[p]='\\0';\n            str=stringBuf;\n            return *this;\n        }\n        Scanner operator>>(char str[]){\n            int p=0;\n            while(blank(cht=nc()));\n            for(str[p++]=cht;!blank(cht=nc());str[p++]=cht);\n            str[p]='\\0';\n            return *this;\n        }\n        template<typename F>\n        inline Scanner operator>>(F&f){\n            cin>>f;\n            return *this;\n        }\n    };\n \n    class Printer{\n        int num;\n        char chr[21];\n    public:\n        Printer operator<<(int x){\n            if(x==0){\n                putchar('0');\n                return *this;\n            }\n            if(x<0)x*=-1,putchar('-');\n            num=0;\n            while(x) chr[++num]=(x%10)+48,x/=10;\n            while(num) putchar(chr[num--]);\n            return *this;\n        }\n        Printer operator<<(long long int x){\n            if(x==0){\n                putchar('0');\n                return *this;\n            }\n            if(x<0)x*=-1,putchar('-');\n            num=0;\n            while(x) chr[++num]=(x%10)+48,x/=10;\n            while(num) putchar(chr[num--]);\n            return *this;\n        }\n        inline Printer operator<<(char x){\n            putchar(x);\n            return *this;\n        }\n        Printer operator<<(const char str[]){\n            int p=0;\n            while(str[p]!='\\0'){\n                putchar(str[p++]);\n            }\n            return *this;\n        }\n        inline Printer operator<<(string&x){\n            for(string::iterator i=x.begin();i<x.end();i++)putchar(*i);\n            return *this;\n        }\n        template<typename F>\n        inline Printer operator<<(F&f){\n            cout<<f;\n            return *this;\n        }\n    };\n    Scanner qin;\n    Printer qout;\n#define endl '\\n'\n}\nusing namespace FastIO;\n \n//-----------------模板到此结束 以下是测试代码--------------------\n \nint main(){\n    //test\n    freopen(\"D:\\\\1.txt\",\"r\",stdin);\n    long long int arr[10];\n    for(int i=1;i<10;i++){\n        qin>>arr[i];\n    }\n    for(int i=1;i<10;i++){\n        qout<<arr[i]<<endl;\n    }\n}\n \nint main2(){\n    // !!run this test with \"EnableCompatibility\" mode on\n    freopen(\"D:\\\\1.txt\",\"r\",stdin);\n    long long int a;\n    long long int b;\n    int c;\n    double d;\n    string e;\n    float f;\n \n    qin>>a>>b>>c>>d>>e>>f;\n    qout<<a<<\" \"<<b<<endl<<c<<\" \"<<d<<endl<<e<<\" \"<<f;\n}\n```\n\n上面的“兼容性模式”是不再建立缓冲区而用疯狂getchar替代 这样不会把后面不是整数的数据也存进缓冲区\n\n实验证明这样速度会慢一半 但是也比scanf快得多\n\n如果不需要读取负数 可以打开上面DisableNegative的开关 编译时会少几个判断 效率也有一些提升\n\n在不开启兼容性+DisableNegative的模式下 和原模板的速度没有区别\n\n \n\n**简述一下用法：**只要把这段代码粘贴到您代码的最上方 然后使用qin,qout（q是quick的意思）代替cin,cout就可以了\n\n所有的输入输出都使用运算符<<,>>来进行\n\n经过测速 虽然用了大量的反复重载和类 速度并未改变 但从使用上来说也许会更方便一些\n\n \n\n**已知的一些问题：**\n\n1.qout不能正确的输出-9223372036854775808这个数（ll的最小值）因为去掉符号会溢出\n\n但只有这一个数不能用 实际需要输出这个数的场合也不多见  就不为了它降低整体效率了\n\n2.快速写部分对于绝大多数类型都有加速作用 但是快读只对整数类型起作用\n\n**如果数据中不是含有大量的整数 请慎用此模板（因为与sync_with_stdio不共存）**\n\n\n\n<hr />\n","tags":["xiu"],"categories":["xiu"]},{"title":"zoj1586","url":"%2F2019%2F08%2F12%2Fzoj1586.html","content":"<p class=\"description\"></p>\nzoj1586，最小生成树\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1586\n\n## 题意\n\nt组数据\n\nn个人\n\n每个人的路由器的价格\n\n每个人连线到其他人的价格\n\n输出最少多少钱可以所有人联通\n\n两个人联通的价格=a路由器价格+b路由器价格+两人连线的价格\n\n## 细节\n\n存权值的时候加上两个人的路由器价格，然后跑一边prim就好\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <iostream>\nusing namespace std;\nint n,m;\nconst int inf=0xfffffff;\nint e[1010][1010];\nint lowcost[1010];\nint wifi[1010];\nint prim()\n{\n\tint ans=0;\n\tint i;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tlowcost[i]=e[1][i];\n\t}\n\tlowcost[1]=-1;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tint j,min=inf,temp;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(lowcost[j]!=-1&&lowcost[j]<min)\n\t\t\t{\n\t\t\t\tmin=lowcost[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tans=ans+lowcost[temp];\n\t\tlowcost[temp]=-1;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[temp][j]<lowcost[j])\n\t\t\t{\n\t\t\t\tlowcost[j]=e[temp][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tint i,j;\n\t\tint a,b,c;\n\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&wifi[i]);\n\t\t\t}\n\t\tint d;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&d);\n\t\t\t\te[i][j]=wifi[i]+wifi[j]+d;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",prim());\n\t}\n} \n```\n\n\n\n<hr />\n","tags":["zoj"],"categories":["zoj"]},{"title":"poj2421","url":"%2F2019%2F08%2F12%2Fpoj2421.html","content":"<p class=\"description\"></p>\npoj2421,带条件的最小生成树\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2421\n\n## 题意\n\nn个村庄，接下来n行\n\n告诉你到别的村庄的距离\n\n然后m条路，表示a，b两个村庄已经是联通的了\n\n问最少再修多长的路就可以把所有村庄联通\n\n## 细节\n\n已经有路的村庄距离设为0即可\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <iostream>\nusing namespace std;\nint n,m;\nconst int inf=0xfffffff;\nint e[110][110];\nint lowcost[110];\nint prim()\n{\n\tint ans=0;\n\tint i;\n\tfor(i=1;i<=n;i++)\n\tlowcost[i]=e[1][i];\n\tlowcost[1]=-1;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tint j,min=inf,temp;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(lowcost[j]!=-1&&lowcost[j]<min)\n\t\t\t{\n\t\t\t\tmin=lowcost[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tans=ans+lowcost[temp];\n\t\tlowcost[temp]=-1;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[temp][j]<lowcost[j])\n\t\t\t{\n\t\t\t\tlowcost[j]=e[temp][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint i,j;\n\tint a,b,c;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&e[i][j]);\n\t\t\t}\n\t\t}\n\tscanf(\"%d\",&m);\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\te[a][b]=0;\n\t\t\te[b][a]=0;\n\t\t}\n\tprintf(\"%d\\n\",prim());\n} \n```\n\n\n\n<hr />\n","tags":["prim"],"categories":["poj"]},{"title":"poj2031","url":"%2F2019%2F08%2F12%2Fpoj2031.html","content":"<p class=\"description\"></p>\npoj2031,三维坐标+最小生成树\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2031\n\n## 题意\n\n在一个三维坐标系上又n个球体\n\n告诉你他们的x，y，z坐标和他们的半径\n\n求他们距离的最小生成树\n\n## 细节\n\n两个球可能会有相交的地方（dis<=0）\n\n所以就给相交的球距离置0\n\nlowcost数组就把加入树中的点标记为-1\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <iostream>\n#include <cmath>\nusing namespace std;\nint n,m;\nconst int inf=0xfffffff;\nstruct piont\n{\n\tdouble x,y,z,r;\n}e[110];\ndouble map[110][110];\ndouble lowcost[110];\n\ndouble prim()\n{\n\tdouble ans=0;\n\tint i;\n\tfor(i=1;i<=n;i++)\n\tlowcost[i]=map[1][i];\n\tlowcost[1]=-1;\n\tfor(i=2;i<=n;i++)\n\t{\n//\t\tint d;\n//\t\tfor(d=1;d<=n;d++)\n//\t\tprintf(\"%lf   \",lowcost[d]);\n//\t\tprintf(\"\\n\"); \n\t\tint j,temp;\n\t\tdouble min=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(lowcost[j]!=-1&&lowcost[j]<min)\n\t\t\t{\n\t\t\t\tmin=lowcost[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tans=ans+lowcost[temp];\n\t\tlowcost[temp]=-1;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(map[temp][j]<lowcost[j])\n\t\t\t{\n\t\t\t\tlowcost[j]=map[temp][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tif(n==0)break;\n\t\tint i,j;\n\t\tdouble a,b,c,d;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf%lf%lf\",&a,&b,&c,&d);\n\t\t\te[i].x=a;\n\t\t\te[i].y=b;\n\t\t\te[i].z=c;\n\t\t\te[i].r=d;\n\t\t}\n\t\tfor(i=0;i<=n;i++)\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tmap[i][j]=inf;\n\t\t\t\tif(i==j)map[i][j]=0;\t\n\t\t\t}\n\t\tfor(i=1;i<n;i++)\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tdouble dis=sqrt((e[i].x-e[j].x)*(e[i].x-e[j].x)+(e[i].y-e[j].y)*(e[i].y-e[j].y)+(e[i].z-e[j].z)*(e[i].z-e[j].z));\n//\t\t\t\tprintf(\"%lf  %lf  %d %d\\n\",e[i].r,e[j].r,i,j);\n\t\t\t\tdis=dis-e[i].r-e[j].r;\n\t\t\t\tif(dis<0)\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\tmap[j][i]=0;\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=dis;\n\t\t\t\t\tmap[j][i]=dis;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3lf\\n\",prim());\n\t}\n} \n```\n\n\n\n<hr />\n","tags":["prim"],"categories":["poj"]},{"title":"poj1287","url":"%2F2019%2F08%2F12%2Fpoj1287.html","content":"<p class=\"description\"></p>\npoj1287，最小生成树模板题\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1287\n\n## 题意\n\nn个点m条边\n\nm行a到b的距离\n\n求最小生成树大小\n\n## 细节\n\n= =水\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <iostream>\nusing namespace std;\nint n,m;\nconst int inf=0xfffffff;\nint e[60][60];\nint lowcost[60];\nint prim()\n{\n\tint ans=0;\n\tint i;\n\tfor(i=1;i<=n;i++)\n\tlowcost[i]=e[1][i];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tint j,min=inf,temp;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(lowcost[j]!=0&&lowcost[j]<min)\n\t\t\t{\n\t\t\t\tmin=lowcost[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tans=ans+lowcost[temp];\n\t\tlowcost[temp]=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[temp][j]<lowcost[j])\n\t\t\t{\n\t\t\t\tlowcost[j]=e[temp][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tif(n==0)break;\n\t\tscanf(\"%d\",&m);\n\t\tint i,j;\n\t\tfor(i=0;i<=n;i++)\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\te[i][j]=inf;\n\t\t\t\tif(i==j)e[i][j]=0;\t\n\t\t\t}\t\n\t\tint a,b,c;\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tif(c<e[a][b])\n\t\t\t{\n\t\t\t\te[a][b]=c;\n\t\t\t\te[b][a]=c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",prim());\n\t\t\n\t}\n} \n```\n\n\n\n<hr />\n","tags":["prim"],"categories":["poj"]},{"title":"poj1251","url":"%2F2019%2F08%2F11%2Fpoj1251.html","content":"<p class=\"description\"></p>\npoj1251,最小生成树，prim，剧毒输入\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1251\n\n## 题意\n\n首先给你一个图，需要你求出最小生成树，输入N个节点，用大写字母表示了节点，然后节点与节点之间有权值。\n比如有9个节点，然后接下来有n-1行表示了边的情况，拿第一行举例\nA 2 B 12 I 25\n表示A有两个邻点，B和I，AB权值是12，AI权值是25\n\n## 细节\n\npoj的奇妙评测机，也可能是数据有毒，scanf会tle\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int maxn=27;\nconst int inf=0xfffffff;\nint e[maxn][maxn];\nint n;\nint ans;\nvoid prim()\n{\n\tint min,i,j,k;\n\tint lowcost[maxn];\n\tint adj[maxn];\n\tlowcost[1]=0;\n\tadj[1]=0;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tlowcost[i]=e[1][i];\n\t\tadj[i]=1;\n\t}\n\tfor(i=2;i<=n;i++)\n\t{\n//\t\tint d;\n//\t\tfor(d=1;d<=n;d++)\n//\t\t{\n//\t\t\tprintf(\"%d %d  \",d,lowcost[d]);\n//\t\t}\n//\t\tprintf(\"\\n\");\n\t\tmin=inf;\n\t\tj=1;k=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(lowcost[j]!=0&&lowcost[j]<min)\n\t\t\t{\n\t\t\t\tmin=lowcost[j];\n\t\t\t\tk=j;\n\t\t\t} \n\t\t//printf(\"(%d, %d)\\n\",adj[k], k);\n\t\tans=ans+lowcost[k];\n\t\tlowcost[k]=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(lowcost[j]!=0&&e[k][j]<lowcost[j])\n\t\t\t{\n\t\t\t\tlowcost[j]=e[k][j];\n\t\t\t\tadj[j]=k;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tchar u;\n\tint t;\n\twhile(cin>>n,n)\n\t{\n\t\tans=0;\n\t\tif(n==0)break;\n\t\tint i,j;\n\t\tfor(i=0;i<27;i++)\n\t\t\tfor(j=0;j<27;j++)\n\t\t\t{\n\t\t\t\te[i][j]=inf;\n\t\t\t\tif(i==j)e[i][j]=0;\n\t\t\t}\n\t\tfor(i=1;i<n;i++)\n\t\t{\n\t\t\tcin>>u;\n\t\t\tcin>>t;\n\t\t\tchar v;\n\t\t\tint w;\n\t\t\twhile(t--)\n\t\t\t{\n\t\t\t\tcin>>v;\n\t\t\t\tcin>>w;\n\t\t\t\tif(w<e[u-'A'+1][v-'A'+1])\n\t\t\t\t{\n\t\t\t\t\te[u-'A'+1][v-'A'+1]=w;e[v-'A'+1][u-'A'+1]=w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprim();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["prim"],"categories":["poj"]},{"title":"poj1135","url":"%2F2019%2F08%2F10%2Fpoj1135.html","content":"<p class=\"description\"></p>\npoj1135,比较有意思的最短路\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1135\n\n## 题意\n\n多米诺骨牌游戏。\n\n计算最后倒下的是哪一张多米诺骨牌，在什么时间倒下。\n\n多米诺骨牌包含一些关键牌，他们之间由一些普通骨牌来进行连接。\n\n当一张关键牌倒下时，连接这张关键牌的所有行都开始倒下。\n\n当倒下的行达到其他还没有倒下的关键牌时，则这些关键牌也开始倒下，同样连接它的所有行开始倒下。每一行骨牌可以从两个端点中任何一张关键牌开始倒下，甚至两个端点的关键牌可以分别倒下，在这种情形下，该行最后倒下的骨牌为中间的某张骨牌。\n\n假定骨牌倒下的速度一致。\n\n输入第一行n，m，表示n张骨牌，共有m行骨牌\n\n接下来m行是a关键牌倒向b关键牌所需要的时间。\n\n## 细节\n\n关键牌抽象成点，关键牌之间抽象为边。时间为权值。\n\n1、计算每一张关键牌倒下的time[i]，然后去time[]的最大值，设为maxtime1；\n\n2、计算每一行完全倒下的时间。设每一行的两端的关键牌为i和j，则这一行完全倒下的时间为\n\n(time[i]+time[j]+e[i] [j])/2.0。取所有行完全倒下时间的最大值，设为maxtime2；\n\n3、如果maxtime2>maxtime1，则是第二种情形（即最后倒下的骨牌位于两张关键牌之间），否则是第一种情形。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int maxn=510;\nconst int inf=0xffffff;\nint n,m,k;\nint dis[maxn];\nbool vis[maxn];\nint e[maxn][maxn];\n\nvoid init()\n{\n\tmemset(vis,false,sizeof(vis));\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(i==j)e[i][j]=0;\n\t\t\t\telse e[i][j]=inf;\n\t\t\t}\n\t}\n\t\n}\n\nvoid dijstra(int x)\n{\n\tint i,j,v;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tdis[i]=e[x][i];\n\t}\n\tdis[x]=0;\n\tvis[x]=true;\n\tfor(i=1;i<=n-1;i++)\n\t{\n\t\tint min=inf;\n\t\tint temp;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(vis[j]==0 && dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tvis[temp]=true;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[temp]+e[temp][v]<dis[v])\n\t\t\t\t\tdis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n\nint main()\n{\n\tint kase=0;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF)\n\t{\n\t\tif(n==0&&m==0)break;\n\t\tint a,b,c;\n\t\tinit();\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\te[a][b]=c;\n\t\t\te[b][a]=c;\n\t\t}\n\t\tdijstra(1);\n\t\tdouble mtime1,mtime2;\n\t\tdouble max=-1;\n\t\tint i,ans1i,j;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tif(dis[i]>max)\n\t\t\t{\n\t\t\t\tmax=dis[i];\n\t\t\t\tans1i=i;\n\t\t\t}\n\t\t}\n\t\tmtime1=max;\n\t\tmax=-1;\n\t\tint ansi,ansj;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tdouble k;\n\t\t\t\tif(e[i][j]<inf)\n\t\t\t\t{\n\t\t\t\t\tk=(dis[i]+dis[j]+e[i][j])/2.0;\n\t\t\t\t\tif(k>max)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax=k;\n\t\t\t\t\t\tansi=i;\n\t\t\t\t\t\tansj=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmtime2=max;\n\t\tif(ansi>ansj)\n\t\t{\n\t\t\tint temp;\n\t\t\ttemp=ansi;\n\t\t\tansi=ansj;\n\t\t\tansj=temp;\n\t\t}\n\t\tprintf(\"System #%d\\n\",++kase);\n\t\tif(n==1&&m==0)\n        {\n            printf(\"The last domino falls after 0.0 seconds, at key domino 1.\\n\\n\");\n            continue;\n        }\n\t\telse if(mtime1>=mtime2)\n\t\t{\n\t\t\tprintf(\"The last domino falls after %.1f seconds, at key domino %d.\\n\\n\",mtime1,ans1i);\n\t\t}\n\t\telse printf(\"The last domino falls after %.1f seconds, between key dominoes %d and %d.\\n\\n\",mtime2,ansi,ansj);\n\t}\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"hdu3038","url":"%2F2019%2F08%2F10%2Fhdu3038.html","content":"<p class=\"description\"></p>\nhdu3038,加权并查集，需要理解\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3038\n\n## 题意\n\n求在有n个数中，有m次询问，每次询问在这给定的区间和这区间里数的和为s，求每次给出的是不是正确的和s。也就是和前面的矛盾不矛盾。\n\n## 细节\n\n用一个sum[]来记录当前端点到父亲节点的距离。\n\n若输入的a，b的父亲节点相同时，进行判断。\n\n否则更新父亲节点，同时更新点的sum[]。\n\n## 代码\n\n```c++\n#include <cstdio>\n#define maxn 200010\nusing namespace std;\nint sum[maxn],pr[maxn];//pr存父亲节点，sum存父亲节点到当前节点的距离 \nint n,m,ans;\nvoid init()\n{\n\tint i;\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tpr[i]=i;\n\t\tsum[i]=0;\n\t}\n\tans=0;\n}\n\nint find(int x)\n{\n\tif(x==pr[x])return x;\n\telse \n\t{\n\t\tint k=pr[x];\n\t\tpr[x]=find(pr[x]);\n\t\tsum[x]=sum[x]+sum[k];\n\t\treturn pr[x];\n\t}\n}\n\nvoid to_union(int a,int b,int c)\n{\n\tint x,y;\n\tx=find(a);\n\ty=find(b);\n\tif(x==y)\n\t{\n\t\tif(sum[a]+c!=sum[b])\n\t\t{\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t}\n\telse if(x<y)\n\t{\n\t\tpr[y]=x;\n\t\tsum[y]=sum[a]+c-sum[b];\n\t}\n\telse\n\t{\n\t\tpr[x]=y;\n\t\tsum[x]=sum[b]-sum[a]-c;\n\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF)\n\t{\n\t\tint a,b,c;\n\t\tinit();\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tto_union(a-1,b,c);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["hdu"]},{"title":"hdu1213","url":"%2F2019%2F08%2F09%2Fhdu1213.html","content":"<p class=\"description\"></p>\nhdu1213，并查集水题\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1213\n\n## 题意\n\n输入t组，n个人，m组关系。\n\na认识b，b认识c，那么a也等于认识c。\n\n认识的人可以坐一张桌子上，求最少要多少张桌子。\n\n## 细节\n\n假设一开始有n张桌子，每有一个人并到集合中去，就减少一张桌子\n\n代码\n\n```c++\n#include <vector>\n#include <iostream>\n#include <cstdio>\nusing namespace std; \nvector<int> parent;\nvoid init(int max_size)\n{\n\t// 初始化每一个元素的根节点都为自身\n\tparent.clear();\n\tfor (int i = 0; i <=max_size; ++i)\n\t\tparent.push_back(i);\n}\nint find(int x)\n{\n\treturn parent[x] == x ? x : find(parent[x]);\n}\nvoid to_union(int x1, int x2)\n{\n\tparent[find(x1)] = find(x2);\n}\nint main()\n{\n\tint t,n,m,i,a,b;\n\tint vis[1010];\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tinit(n);\n\t\tint ans=n;\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t{\n\t\t\t\tif(find(a)!=find(b))\n\t\t\t\t{\n\t\t\t\t\tans--;\n\t\t\t\t\tto_union(a,b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["hdu"]},{"title":"七夕","url":"%2F2019%2F08%2F07%2F%E4%B8%83%E5%A4%95.html","content":"<p class=\"description\"></p>\n一看居然七夕了。\n\n![](https://lmf424.oss-cn-beijing.aliyuncs.com/56884409_p0.jpg)\n\n<!-- more -->\n\n我是对这个节日不怎么感冒的。\n\n当然，我相信爱情，而且是很单纯的那种。我相信美好的爱情。\n\n我甚至有时候感觉我自己长情到可怕。一个名字刻在心里十几年，我才活了多少岁。只是随着时间时间流逝，多年未见，已经与她没有任何交集了。我甚至开始怀疑，也许那只是我还小，不懂得爱慕和喜欢的区别。\n\n我也觉得我不适合爱人。我懂啥，我啥也不懂。我能给予什么，我什么也给不了。我甚至为未来而迷茫。\n\n爱乐之城真的很棒，梦想会一直伴随着你，爱人也许不会。\n\n所以我觉得更应该去努力提升自己。\n\n今天又是wrong answer了一个下午，日常自闭。但我很满足，很充实，我能感受到我在做有意义的事情。\n\n就算是平庸如我，渺小如我，世间辽阔，也只一个。\n\n这心头热火，唇间冰河，悉数无关我。\n\n词不达意。\n\n\n\n<hr />\n","categories":["somethings"]},{"title":"poj1611","url":"%2F2019%2F08%2F07%2Fpoj1611.html","content":"<p class=\"description\"></p>\npoj1611,并查集水题\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1611\n\n## 题意\n\n0号学生得了流感，跟他一组的就会受到感染，间接的也会。\n\n第一行告诉你有n个学生，m组。\n\n接下来m行告诉你每组有t个人，接下来是t个人的编号。\n\n输出有多少个学生被感染了。\n\n## 细节\n\n水水水。。。每组跟第一个人to_union一下就好。\n\n最后查一下跟0号parent一样的就ans++\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define maxn 30010\nusing namespace std;\nint parent[maxn];\nint rank[maxn];\nint sets[maxn];\nint n,m;\nint find(int x)\n{\n    return x == parent[x] ? x : (parent[x] = find(parent[x]));\n}\n\nvoid to_union(int x1, int x2)\n{\n\tint f1 = find(x1);\n\tint f2 = find(x2);\n\tif (rank[f1] > rank[f2])\n\t\tparent[f2] = f1;\n    else\n        {\n            parent[f1] = f2;\n            if (rank[f1] == rank[f2])\n                ++rank[f2];\n        }\n}\n\nvoid init()\n{\n\tint i;\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tparent[i]=i;\n\t\trank[i]=0;\n\t}\n}\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&m))\n\t{\n\t\tif(n==0&&m==0)break;\n\t\tinit();\n\t\tint i,j;\n\t\twhile(m--)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(i=0;i<t;i++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&sets[i]);\n\t\t\t}\n\t\t\tfor(i=1;i<t;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tto_union(sets[0],sets[i]);\n\t\t\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(find(i)==find(0))ans++;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj2236","url":"%2F2019%2F08%2F04%2Fpoj2236.html","content":"<p class=\"description\"></p>\npoj2236,并查集\n\n**能用puts就别用printf！！！**\n\nimportant！！![](https://lmf424.oss-cn-beijing.aliyuncs.com/%E5%BC%9F%E5%BC%9F.jpeg)\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2236\n\n## 题意\n\n有n台计算机, 已知每台计算机的坐标, 初始时所有计算机都是坏的, 然后修复其中一些计算机, 已修复的计算机距离不超过distance的可以联网(若a, b之间可以联网, b, c之间可以联网, 则a, c之间可以联网),询问x, y之间可否联网;\n\n第一行输入n, distance, 表示有n台计算机, 联网的两台计算机距离不能超过distance;\n\n接下来n分别表示n台计算机的坐标;\n\n再接下来到输入结束, 输入格式为: O, x 的表示修复第x台计算机, 输入格式为S, x, y 的表示询问x, y之间能否联网, 若能输出 SUCCESS, 不能则输出 FAIL;\n\n## 细节\n\n并查集，修好的机器就跟别的机器尝试连接一下，满足条件就放入一个集合\n\n## 代码\n\n3032ms，看到有1000+ms就过了的，晚点看看人家是怎么做的\n\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#define maxn 1010\nusing namespace std;\nint n,d,k;\nvector<int> parent;\nvector<int> rank;\nvoid init(int max_size)\n{\n\t// 初始化每一个元素的根节点都为自身\n\tparent.clear();\n\trank.clear();\n\tfor (int i = 0; i <=max_size; ++i)\n\t\t{\n\t\t\tparent.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n}\n\nint find(int x)\n{\n    return x == parent[x] ? x : (parent[x] = find(parent[x]));\n}\n\nvoid to_union(int x1, int x2)\n{\n\tint f1 = find(x1);\n\tint f2 = find(x2);\n\tif (rank[f1] > rank[f2])\n\t\tparent[f2] = f1;\n    else\n        {\n            parent[f1] = f2;\n            if (rank[f1] == rank[f2])\n                ++rank[f2];\n        }\n}\n\nbool is_same(int e1, int e2)\n{\n\treturn find(e1) == find(e2);\n}\n\nstruct point\n{\n\tint x,y,vis;\n}po[maxn]; \n\ndouble dis(int a,int b)\n{\n\treturn sqrt((po[a].x-po[b].x)*(po[a].x-po[b].x)+(po[a].y-po[b].y)*(po[a].y-po[b].y));\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&d);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&po[i].x,&po[i].y);\n\t\tpo[i].vis=0;\n\t}\n\tgetchar();\n\tinit(n);\n\tchar x;\n\tint k;\n\twhile(scanf(\"%c\",&x)!=EOF)\n\t{\n\t\tif(x=='O')\n\t\t{\n\t\t\tscanf(\"%d\",&k);\n\t\t\tpo[k].vis=1;\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tif(po[i].vis==1&&i!=k)\n\t\t\t\t{\n\t\t\t\t\tif(dis(k,i)<=d&&(!is_same(k,i)))\n\t\t\t\t\t{\n\t\t\t\t\t\t//printf(\"%d%d\\n\",k,i);\n\t\t\t\t\t\tto_union(k,i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tif(is_same(a,b))printf(\"SUCCESS\\n\");\n\t\t\telse printf(\"FAIL\\n\");\n\t\t}\n\t\tgetchar();\n\t}\n}\n```\n\n\n\n## 更新（心累的故事）\n\n![1564991288139](poj2236\\1564991288139.png)\n\n考虑了很久。。代码越来越长耗时越来越多。。（负优化实锤了）\n\n怎么想都感觉没啥更快的方法了。\n\n我又看了眼那个老哥：![](poj2236\\1565003068075.png)\n\n![TIM图片20190805190547](poj2236\\TIM图片20190805190547.jpg)嗯？？？？\n\n那我拿你的代码交交看。\n\n![1565003423379](poj2236\\1565003423379.png)\n\n![TIM图片20190805190547](poj2236\\TIM图片20190805190547.jpg)嗯？？？？！\n\n唉。。。\n\n然后看了看通过这题的人，确实是有1s左右过的，然后我就继续开始思考。\n\n有哪里不对。\n\n网上找了找别人的代码，交了几份，找到了一份932ms的。厉害啊老哥！\n\n代码风格跟我差不多，很棒，我一下子就读懂了。\n\n```c++\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct coordinate\n{\n    int x,y;\n}a[1010];\nint n,d;\n\nvector<int>father;\nvector<int>visit;\n//int father[1010];\n//int visit[1010];\n \nint find_it(int x)\n{\n    int tempx=x,t;\n    while(tempx!=father[tempx])\n        tempx=father[tempx];\n \n    while(x!=father[x])\n    {\n        t=father[x];\n        father[x]=tempx;\n        x=t;\n    }\n    return tempx;\n}\n \nbool calc(int p1,int p2)\n{\n    if(d*d>=((a[p1].x-a[p2].x)*(a[p1].x-a[p2].x)+(a[p1].y-a[p2].y)*(a[p1].y-a[p2].y)))\n        return true;\n    return false;\n}\n \nvoid unin(int x,int y)\n{\n    int tx=find_it(x);\n    int ty=find_it(y);\n \n    if(tx!=ty&&calc(x,y))\n        father[tx]=ty;\n}\n \nint main()\n{\n    scanf(\"%d%d\",&n,&d);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d\",&a[i].x,&a[i].y);\n    }\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfather.push_back(i);\n\t\tvisit.push_back(0);\n\t}\n    char ch[5];\n    int t1,t2;\n    int flag=1;\n    while(scanf(\"%s\",ch)!=EOF){\n        if(ch[0]=='O'){\n            scanf(\"%d\",&t1);\n            visit[t1]=1;\n            if(flag)\n                flag=0;\n            else{\n                for(int i=1;i<=n;i++)\n                    if(visit[i]&&i!=t1)\n                        unin(t1,i);\n            }\n        }\n        else{\n            scanf(\"%d%d\",&t1,&t2);\n            int temp1=find_it(t1);\n            int temp2=find_it(t2);\n            if(temp1==temp2)\n                puts(\"SUCCESS\");\n            else\n                puts(\"FAIL\");\n        }\n    }\n    return 0;\n}\n```\n\nemmm这代码跟我写的思路有啥区别？？？我俩写的不是一毛一样？！\n\n怀疑是我用了STL的问题，于是将他的数组改成了vector。\n\n他，900+，我3000+。\n\n![](poj2236/TIM%E5%9B%BE%E7%89%8720190805191700.gif)why？？？？？\n\n然后就是漫长的找不同时间。\n\n最恐怖的就是我把他的函数copy过来替换了我的函数，我还是3000+。\n\n居然是主函数里面的问题？\n\n最后锁定目标，换成注释里面的就变900+了。\n\n竟然是puts和printf的问题。。\n\n![TIM图片20190805190547](poj2236\\TIM图片20190805190547-1565004175371.jpg)这能差3倍的速度？？我懂了，以后能puts我就puts了。\n\nend.\n\n```c++\n\t\t\tscanf(\"%d%d\",&t1,&t2);\n\t\t\tint temp1,temp2;\n\t\t\ttemp1=find(t1);\n\t\t\ttemp2=find(t2); \n\t\t\tif(temp1==temp2)printf(\"SUCCESS\\n\");\n\t\t\telse printf(\"FAIL\\n\");\n//            scanf(\"%d%d\",&t1,&t2);\n//            int temp1=find(t1);\n//            int temp2=find(t2);\n//            if(temp1==temp2)\n//                puts(\"SUCCESS\");\n//            else\n//                puts(\"FAIL\");\n```\n\n最后是通过的代码，954ms\n\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#define maxn 1010\nusing namespace std;\nint n,d,k;\nvector<int> parent;\nvector<int> rank;\nvoid init()\n{\n\tfor (int i = 0; i <=n; ++i)\n\t\t{\n\t\t\tparent.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n}\n\nint find(int x)\n{\n    return x == parent[x] ? x : (parent[x] = find(parent[x]));\n}\n\nvoid to_union(int x1, int x2)\n{\n\tint f1 = find(x1);\n\tint f2 = find(x2);\n\tif (rank[f1] > rank[f2])\n\t\tparent[f2] = f1;\n    else\n        {\n            parent[f1] = f2;\n            if (rank[f1] == rank[f2])\n                ++rank[f2];\n        }\n}\n\nstruct point\n{\n\tint x,y,vis;\n}po[maxn]; \n\nbool dis(int a,int b)\n{\n\tif(d*d>=((po[a].x-po[b].x)*(po[a].x-po[b].x)+(po[a].y-po[b].y)*(po[a].y-po[b].y)))\n\treturn true;\n\telse return false;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&d);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d\",&po[i].x,&po[i].y);\n        po[i].vis=0;\n    }\n\tinit();\n    char ch[5];\n    int t1,t2;\n    int flag=1;\n    while(scanf(\"%s\",ch)!=EOF){\n        if(ch[0]=='O'){\n            scanf(\"%d\",&t1);\n            po[t1].vis=1;\n            if(flag)\n                flag=0;\n            else{\n                for(int i=1;i<=n;i++)\n                    if(po[i].vis&&i!=t1)\n                    {\n                    \tif(dis(t1,i))to_union(t1,i);\n\t\t\t\t\t}\n            }\n        }\n        else{\n\t\t\tscanf(\"%d%d\",&t1,&t2);\n\t\t\tif(find(t1)==find(t2))puts(\"SUCCESS\");\n\t\t\telse puts(\"FAIL\");\n//            scanf(\"%d%d\",&t1,&t2);\n//            int temp1=find(t1);\n//            int temp2=find(t2);\n//            if(temp1==temp2)\n//                puts(\"SUCCESS\");\n//            else\n//                puts(\"FAIL\");\n        }\n    }\n    return 0;\n}\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"hdu1232","url":"%2F2019%2F08%2F04%2Fhdu1232.html","content":"<p class=\"description\"></p>\nhdu1232,并查集板子题\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1232\n\n## 题意\n\nn个城镇，m条路\n\n提问最少再修多少条路，可以让所有城镇联通\n\n## 细节\n\n并查集模板题，最后城镇的集合数-1就是ans\n\n## 代码\n\n```c++\n#include <vector>\n#include <iostream>\n#include <cstdio>\nusing namespace std; \nvector<int> parent;\nvoid init(int max_size)\n{\n\t// 初始化每一个元素的根节点都为自身\n\tparent.clear();\n\tfor (int i = 0; i <=max_size; ++i)\n\t\tparent.push_back(i);\n}\nint find(int x)\n{\n\treturn parent[x] == x ? x : find(parent[x]);\n}\nvoid to_union(int x1, int x2)\n{\n\tparent[find(x1)] = find(x2);\n}\n    // 判断两个元素是否属于同一个集合\nbool is_same(int e1, int e2)\n{\n\treturn find(e1) == find(e2);\n}\n\nint main()\n{\n\tint n,m;\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tif(n==0)break;\n\t\tinit(n);\n\t\tscanf(\"%d\",&m);\n\t\twhile(m--)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tto_union(a,b);\n\t\t}\n\t\tint i,sum=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tif(find(i)==i)sum++;\n\t\t}\n\t\tprintf(\"%d\\n\",sum-1);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["hdu"]},{"title":"并查集","url":"%2F2019%2F08%2F04%2F%E5%B9%B6%E6%9F%A5%E9%9B%86.html","content":"<p class=\"description\"></p>\n## 并查集（Disjoint-set）\n\n代码简洁，功能强大。\n\n<!-- more -->\n\n## 什么是并查集\n\n对于一个集合S={a1, a2, ..., an-1, an}，我们还可以对集合S进一步划分: S1,S2,...,Sm-1,Sm，我们希望能够快速确定S中的两两元素是否属于S的同一子集。\n 举个栗子，S={0,1,2,3,4,5,6}，如果我们按照一定的规则对集合S进行划分,假设划分后为S1={1,2,4}, S2={3,6}，S3={0,5}，任意给定两个元素，我们如何确定它们是否属于同一子集？某些合并子集后，又如何确定两两关系？基于此类问题便出现了并查集这种数据结构。\n 并查集有两个基本操作：\n\n- Find: 查找元素所属子集\n- Union：合并两个子集为一个新的集合\n\n## 并查集的基本结构\n\n我们可以使用树这种数据结构来表示集合，不同的树就是不同的集合，并查集中包含了多棵树，表示并查集中不同的子集，树的集合是**森林**，所以并查集属于森林。\n若集合S={0, 1, 2, 3, 4, 5, 6}，最初每一个元素都是一棵树。\n\n![img](并查集\\5970830-e240c2c558867f5f.webp)\n\n对于`Union`操作，我们只需要将两棵树合并，例如合并0、1、2得到S1={0, 1, 2},合并3和4得到S2={3, 4}\n\n![img](并查集\\5970830-6e9c9c2aa9ae025d.webp)\n\n对于`Find`操作，我们只需要返回该元素所在树的根节点。所以，如果我们想要比较判断1和2是否在一个集合，只需要通过Find(1)和Find(2)返回各自的根节点比较是否相等便可。已知树中的一个节点，找到其根节点的时间复杂度为`O(D)`，D为节点的深度。\n我们可以使用数组来表示树，数组下标表示树的一个节点，该下表所对应的值表示树的父节点。例如`P[i]`表示元素`i`的父节点。对于图2中的集合，我们可以存储在下面的数组中（第二行为数组下标）\n\n|  0   |  0   |  0   |  3   |  3   |  5   |  6   |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  0   |  1   |  2   |  3   |  4   |  5   |  6   |\n\n**对于树的根节点，我们规定其元素值为其本身（即父节点为自己）。**\n\n## 代码\n\n我们使用一个parent数组存储树，先实现未经优化的版本。\n对于`Find`操作，代码非常简单\n\n```c++\nint find(int x)\n{\n    return parent[x] == x ? x : find(parent[x]);\n}\n```\n\n该代码比较元素x的父节点parent[x]是否等于x自身，如果是便说明找到了根节点（根节点的父节点是自身），直接返回；否则，把x的父节点parent[x]传入find，直到找到根节点。\n下面是`union`操作\n\n```c++\nvoid to_union(int x1, int x2) \n{\n    int p1 = find(x1);\n    int p2 = find(x2);\n    parent[p1] = p2;\n}\n```\n\n传入两个元素，分别找到根节点，使根节点p1的父节点为p2，即将p1为根节点的这棵树合并到p2为根节点的树上。\n下面是完整代码：(hdu1232)\n\n```c++\n#include <vector>\n#include <iostream>\n#include <cstdio>\nusing namespace std; \nvector<int> parent;\nvoid init(int max_size)\n{\n\t// 初始化每一个元素的根节点都为自身\n\tparent.clear();\n\tfor (int i = 0; i <=max_size; ++i)\n\t\tparent.push_back(i);\n}\nint find(int x)\n{\n\treturn parent[x] == x ? x : find(parent[x]);\n}\nvoid to_union(int x1, int x2)\n{\n\tparent[find(x1)] = find(x2);\n}\n    // 判断两个元素是否属于同一个集合\nbool is_same(int e1, int e2)\n{\n\treturn find(e1) == find(e2);\n}\n\nint main()\n{\n\tint n,m;\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tif(n==0)break;\n\t\tinit(n);\n\t\tscanf(\"%d\",&m);\n\t\twhile(m--)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tto_union(a,b);\n\t\t}\n\t\tint i,sum=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tif(find(i)==i)sum++;\n\t\t}\n\t\tprintf(\"%d\\n\",sum-1);\n\t}\n}\n```\n\n上面的实现，可以看出每一次Find操作的时间复杂度为`O(H)`，H为树的高度，由于我们没有对树做特殊处理，所以树的不断合并可能会使树严重不平衡，最坏情况每个节点都只有一个子节点，如下图3（第一个点为根节点）\n\n![img](并查集\\5970830-5e6d6e9f91b85c3b.webp)\n\n此时Find操作的时间复杂度为`O(n)`，这显然不是我们想要的。下面引入两个优化的方法。\n\n优化\n\n方法一\n\n\"按秩合并\"。实际上就是在合并两棵树时，将高度较小的树合并到高度较大的树上。这里我们使用“秩”(rank)代替高度，秩表示高度的上界，通常情况我们令只有一个节点的树的秩为0，严格来说，rank + 1才是高度的上界；两棵秩分别为r1、r2的树合并，如果秩不相等，我们将秩小的树合并到秩大的树上，这样就能保证新树秩不大于原来的任意一棵树。如果r1与r2相等，两棵树任意合并，并令新树的秩为r1 + 1。\n\n方法二\n\n“路径压缩”。在执行Find的过程中，将路径上的所有节点都直接连接到根节点上。\n\n![img](并查集\\5970830-44d64a584dd736e2.webp)\n\n下面是采用”按秩合并”与“路径压缩”两中优化算法的实现。\n\n```c++\n#include <vector>\n#include <iostream>\n#include <cstdio>\nusing namespace std; \nvector<int> parent;\nvector<int> rank;\nvoid init(int max_size)\n{\n\t// 初始化每一个元素的根节点都为自身\n\tparent.clear();\n\trank.clear();\n\tfor (int i = 0; i <=max_size; ++i)\n\t\t{\n\t\t\tparent.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n}\n\nint find(int x)\n{\n    return x == parent[x] ? x : (parent[x] = find(parent[x]));\n}\n\nvoid to_union(int x1, int x2)\n{\n\tint f1 = find(x1);\n\tint f2 = find(x2);\n\tif (rank[f1] > rank[f2])\n\t\tparent[f2] = f1;\n    else\n        {\n            parent[f1] = f2;\n            if (rank[f1] == rank[f2])\n                ++rank[f2];\n        }\n}\n\nbool is_same(int e1, int e2)\n{\n\treturn find(e1) == find(e2);\n}\n\nint main()\n{\n\tint n,m;\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tif(n==0)break;\n\t\tinit(n);\n\t\tscanf(\"%d\",&m);\n\t\twhile(m--)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tto_union(a,b);\n\t\t}\n\t\tint i,sum=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tif(find(i)==i)sum++;\n\t\t}\n\t\tprintf(\"%d\\n\",sum-1);\n\t}\n}\n```\n\n\n\n上面时采用递归的方式压缩路径，但是递归压缩路径可能会造成溢出栈，下面时非递归方式进行的路径压缩：\n\n```c++\nint find(int x)\n{\n    int k, j, r;\n    r = x;\n    while(r != parent[r])     //查找跟节点\n        r = parent[r];      //找到跟节点，用r记录下\n    k = x;        \n    while(k != r)             //非递归路径压缩操作\n    {\n        j = parent[k];         //用j暂存parent[k]的父节点\n        parent[k] = r;        //parent[x]指向跟节点\n        k = j;                    //k移到父节点\n    }\n    return r;         //返回根节点的值            \n}\n```\n\n\n\n<hr />\n","tags":["并查集"],"categories":["algorithm"]},{"title":"Prim","url":"%2F2019%2F08%2F04%2FPrim.html","content":"<p class=\"description\"></p>\n## Prim算法\n\n最小生成树之Prim算法。\n\n**最小生成树(Minimum Cost Spanning Tree)** 即构造连通图的最小代价生成树\n\n思想与dijstra差不多，因此复杂度也一样。\n\n复杂度：O（N²）\n\n堆优化：O（ElogN）\n\n<!-- more -->\n\n## 基本思想\n\n对于图`G`而言，`V`是所有顶点的集合。现在设置两个新的集合`U`和`T`， 其中`U`用于存放`G`的最小生成树中的顶点，`T`存放`G`的最小生成树中的边。从所有`u∈U`,`v∈(V−U)`，（`V-U`表示除去`U`的所有顶点)的边中选取权值最小的边`(u, v)`， 将顶点`v`加入集合`U`中，将边`(u, v)`加入集合`T`中，如此不断重复，直到`U = V`为止，最小生成树构造完毕，这时集合`T`中包含了最小生成树的所有边。\n\n## 图解\n\n![img](Prim\\20180528101859978.jfif)\n\n以上图`G4`为例，对`Prim`算法进行模拟演示（假定选择`A`顶点为起始点）\n\n![Graph_prim_G4_details](Prim\\20180528101912444.jfif)\n\n**初始状态**： `V`是所有顶点集合，即V={A,B,C,D,E,F,G}\n\n**第一步**：`A`为起始点，将`A`加入到顶点集合`U`中\n\nU={A},V−U={B,C,D,E,F,G}\n\n**第二步**：从`U`集合所有顶点的边集中，遍历到`(A, B)`的权值最小，故将`B`加入到顶点集合`U`中\n\nU={A,B},V−U={C,D,E,F,G}\n\n**第三步**：从`U`集合所有顶点的边集中，遍历到`(B, F)`的权值最小，故将`F`加入到顶点集合`U`中\n\n U={A,B,F},V−U={C,D,E,G}\n\n**第四步**：从`U`集合所有顶点的边集中，遍历到`(F, E)`的权值最小，故将`E`加入到顶点集合`U`中\n\n U={A,B,F,E},V−U={C,D,G}\n\n**第五步**：从`U`集合所有顶点的边集中，遍历到`(E, D)`的权值最小，故将`D`加入到顶点集合`U`中\n\nU={A,B,F,E,D},V−U={C,G}\n\n**第六步**：从`U`集合所有顶点的边集中，遍历到`(D, C)`的权值最小，故将`C`加入到顶点集合`U`中\n\nU={A,B,F,E,D,C},V−U={G}\n\n**第七步**：从`U`集合所有顶点的边集中，遍历到(F, G)的权值最小，故将G加入到顶点集合`U`中\n\nU={A,B,F,E,D,C,G},V−U={} , 此时 U=V\n\n此时，最小生成树构造完成，其顶点依次为`A, B, F, E, D, C, G`\n\n## 代码\n\n```c++\n#define MAXVER 10\ntypedef char VertexType;\n\ntypedef struct \n{\n    VertexType vexs[MAXVER];\n    int arc[MAXVER][MAXVER];\n    int numVertexes, numEdges;\n}MGraph;\n\nvoid MiniSpanTree_Prim(MGraph G)\n{\n    int min, i, j, k;  // min 为当前权值最小值\n    int lowcost[MAXVEX];  /* 保存顶点间边的权值 */\n    int adjvex[MAXVEX];   /* 保存相关顶点的下标，即下标与其值所连边为当前最小权值边 */\n    lowcost[0] = 0;  /* 选取第一个顶点为起始点， 即 v0 加入树， lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */\n    adjvex[0] = 0;   /* 初始化第一个顶点下标为0 */\n    for(i = 1; i < G.numVertexes; i++)  /* 循环除下标为 0 外的全部顶点 */\n    {\n        lowcost[i] = G.arc[0][i];  /* 将与 v0 顶点有边的权值存入数组 */\n        adjvex[i] = 0;  /* 将其他所有顶点的值初始化为 v0 的下标 */\n    }\n    for(i = 1; i < G.numVertexes; i++)\n    {\n        min = INF;   /* 初始化最小权值为 无穷大 */\n        j = 1, k = 0;\n        while(j < G.numVertexes)  /* 循环全部顶点，寻找当前最小生成树顶点集合中最小权值的边 */\n        {\n            if(lowcost[j] != 0 && lowcost[j] < min)  /* 如果权值不为 0(即不在树中), 且权值小于 min */\n            {\n                min = lowcost[j];  /* 则让当前权值成为最小值 */\n                k = j;             /* 将当前最小值的下标存入k */\n            }\n            j++;\n        }\n        lowcost[k] = 0;  /* 将当前顶点的权值设置为0, 表示此顶点已加入树的顶点集合 */\n        printf(\"(%d, %d)\", adjvex[k], k);  /* 打印当前顶点边中权值最小的边 */\n        for(j = 1; j < G.numVertexes; j++)  /* 循环所有顶点 */\n        {\n            /* 如果下标为 k 的顶点边集中权值小于已存在的权值, 比如 (v0, v6)权值为INF, 而(v1, v6)权值为 16， 更新*/\n            if(lowcost[j] != 0 && G.arc[k][j] < lowcost[j])\n            {\n                lowcost[j] = G.arc[k][j];  /* 将较小的权值存入 lowcost 相应位置 */\n                adjvex[j] = k;   /* 将下标为 k 的顶点存入 adjvex */\n            }\n        }\n    }\n}\n```\n\n\n\n<hr />\n","tags":["Prim"],"categories":["algorithm"]},{"title":"lightoj1074","url":"%2F2019%2F08%2F04%2Flightoj1074.html","content":"<p class=\"description\"></p>\nlightoj1074,SPFA求负环\n\n<!-- more -->\n\n## 题目链接\n\nhttps://vjudge.net/problem/LightOJ-1074\n\n## 题意\n\n有n个城市，每一个城市有一个拥挤度ai，从一个城市I到另一个城市J的时间为:(aJ-aI)^3，存在负环。问从第一个城市到达第k个城市所话的时间，如果不能到达，或者时间小于3输出？否则输出所花的时间\n\n## 细节\n\nspfa找出的所有的负环，把所有负环能到的点都标记一下\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <stack>\nusing namespace std;\nconst int N = 209;\nconst int INF = 0x3f3f3f3f;\nint n,re[N],m;\nstruct LT{\n    int to,nex;\n} L[N*N];\nint F[N],cnt;\nvoid add(int f,int t)\n{\n    L[cnt].nex = F[f];\n    L[cnt].to = t;\n    F[f] = cnt++;\n}\nint que[N*N];\nint coun[N],cir[N],dis[N],inque[N];\nint getdis(int i,int j)\n{\n    int t = re[j] - re[i];\n    return t*t*t;\n}\nvoid dfs(int k)\n{\n    cir[k] = 1;\n    for(int i=F[k];i;i=L[i].nex)\n    {\n        if(!cir[L[i].to])\n        dfs(L[i].to);\n    }\n}\nvoid solve()\n{\n    memset(coun,0,sizeof(coun));\n    memset(cir,0,sizeof(cir));\n    memset(inque,0,sizeof(inque));\n    int front = 0, rear = 0;\n    que[rear++] = 1;\n    memset(dis,INF,sizeof(dis));\n    dis[1] = 0;\n    while(rear>front)\n    {\n        int e = que[front++] ;\n        inque[e] = false;\n        coun[e]++;\n        if(coun[e]>=n)\n        {\n            dfs(e);\n        }\n        for(int i=F[e];i;i=L[i].nex)\n        {\n            int to = L[i].to;\n            if(cir[to]) continue;\n            int k = getdis(e,to);\n            if(dis[to]>dis[e]+k)\n            {\n                dis[to] = dis[e] + k;\n                if(!inque[to])\n                {\n                    if(coun[to]>(n>>1)&&front>0)\n                    que[--front] = to;\n                    else\n                    que[rear++] = to;\n                    inque[to] = true;\n                }\n            }\n        }\n    }\n    scanf(\"%d\",&m);\n    int a;\n    while(m--)\n    {\n        scanf(\"%d\",&a);\n        if(cir[a]||dis[a]<3||dis[a]==INF)\n        printf(\"?\\n\");\n        else printf(\"%d\\n\",dis[a]);\n    }\n}\nint main()\n{\n    int cas,T=1;\n    scanf(\"%d\",&cas);\n    while(cas--)\n    {\n        memset(F,0,sizeof(F));cnt = 1;\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++) scanf(\"%d\",&re[i]);\n        scanf(\"%d\",&m);\n        int a,b;\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            add(a,b);\n        }\n        printf(\"Case %d:\\n\",T++);\n        solve();\n    }\n    return 0;\n}\n```\n\n\n\n<hr />\n","tags":["lightoj"],"categories":["lightoj"]},{"title":"hdu4370","url":"%2F2019%2F08%2F03%2Fhdu4370.html","content":"<p class=\"description\"></p>\nhdu4370,建图转化 + 最短路径。\n\n<!-- more -->\n\n## 题目链接\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4370\n\n## 题意\n\n给定一个 n*n 的矩阵 C，构造一个符合以下条件的矩阵 X：\n\n![1564895169459](hdu4370\\1564895169459.png)\n\n## 细节\n\n将条件转化为图论最短路径问题，Xij 转化为边 i→j 的权值，那么对应关系为：\n\n- 表示点 1 的出度为 1\n- 表示点 n 的入度为 1\n- 除了点 1 和点 n 外的其他点出入度相等\n\n求解的问题转化为点 1 到点 n 的一条最短路径。\n\n其实还有一种情况，那就是可以从点 1 出发到达其他点然后又回到点 1 形成一个环，同样也可以从点 n 出发回到点 n。这样也是符合条件的，答案为从 1 出发的最小权值环和从 n 出发的最小权值环之和。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <iostream>\n#define inf 1e9+5\n#define maxn 310\nusing namespace std;\n\nint dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint out[maxn];\nint k,n;\nint e[maxn][maxn];\n\nvoid spfa(int x)\n{\n\tmemset(vis,false,sizeof(vis));\n\tqueue <int>q;\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(i==x)dis[i]=inf;\n\t\telse \n\t\t{\n\t\t\tdis[i]=e[x][i];\n\t\t\tq.push(i);\n\t\t\tvis[i]=true;\n\t\t}\n\t}\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tif(dis[i]>dis[u]+e[u][i])\n\t\t\t\t{\n\t\t\t\t\tdis[i] = dis[u] + e[u][i];\n\t                if (!vis[i])\n\t                {\n\t                    vis[i] = true;\n\t                    q.push(i);\n\t                }\n\t\t\t\t}\n\t\t\t\tvis[u]=false;\n\t\t\t}\n\t}\n}\n\n\n\nvoid init()\n{\n\tk=1;\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\n\nint min(int x,int y)\n{\n\tif(x>y)return y;\n\telse return x;\n}\n\nint main()\n{\n\tint i,j,x,y,z;\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&z);\n\t\t\t\te[i][j]=z;\n\t\t\t}\n\t\t}\n\t\t//init();\n\t\tspfa(1);\n\t\tint ans = dis[n];\n\t\tint cir1 = dis[1]; // 简单最短路径，“环1”\n\t\t//init();\n\t    spfa(n);\n\t    int cirn = dis[n]; // \"环n\"\n\t    ans = min(ans, cir1 + cirn); // \"环1+环n\" 与简单最短路径最小值\n\t    printf(\"%d\\n\", ans);\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["spfa"],"categories":["hdu"]},{"title":"poj3169","url":"%2F2019%2F08%2F03%2Fpoj3169.html","content":"<p class=\"description\"></p>\npoj3169,单源最短路，SPFA，差分约束\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3169\n\n## 题意\n\n一个农夫有n头牛，他希望将这些牛按照编号 1～n排成一条直线，允许有几头牛站在同一点，但是必须按照顺序，有一些牛关系比较好，希望站的距离不超过某个值，而有一些牛关系不太好，所以希望站的距离大于等于某个值，问1号牛和n号牛之间的最远距离是多少。\n\n## 细节\n\n差分约束的裸题，对于 d[v] - d[u] ≤ w 建立权值为 w 的单向边 e(u,v)，对于 d[v] - d[u]  ≥ w 建立权值为 -w 的单向边 e(v,u)，然后再根据牛必须按顺序排列建立权值为 0 的边 e(i+1,i)，然后最短路就行了。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <iostream>\n#define inf 1e9+5\n#define maxn 1000005\nusing namespace std;\n\nstruct node\n{\n\tint v,w,next;\n}edge[maxn];\n\nint dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint out[maxn];\nint k,n,m,s;\nvoid adde(int u,int v,int w)\n{\n\tedge[k].v=v;\n\tedge[k].w=w;\n\tedge[k].next=first[u];\n\tfirst[u]=k++;\n}\n\nvoid spfa(int x)\n{\n\tqueue <int>q;\n\tq.push(x);\n\tvis[x]=true;\n\tdis[x]=0;\n\tint i;\n\tint flag=0;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tout[u]++;\n\t\tif(out[u]>n)\n\t\t{\n\t\t\tflag=1;break;\n\t\t}\n\t\tq.pop();\n\t\tvis[u]=false;\n\t\tfor(i=first[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(dis[v]>dis[u]+w)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tif(!vis[v])\n\t\t\t\t{\n\t\t\t\t\tq.push(v);\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(flag==1)printf(\"-1\\n\");\n\telse if(dis[n]==inf)printf(\"-2\\n\");\n\telse printf(\"%d\",dis[n]);\n}\n\nvoid init()\n{\n\tk=1;\n\tmemset(first,0,sizeof(first));\n\tmemset(edge,0,sizeof(edge));\n\tmemset(out,0,sizeof(out));\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\n\nint main()\n{\n\tint i,j;\n\twhile(scanf(\"%d%d%d\",&n,&m,&s)!=EOF)\n\t{\n\t\tinit();\n\t\tint x,y,z;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tadde(x,y,z);\n\t\t}\n\t\tfor(i=1;i<=s;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tadde(y,x,-z);\n\t\t}\n\t\tspfa(1);\n\t}\n\t\t\n}\n```\n\n\n\n<hr />\n","tags":["spfa"],"categories":["poj"]},{"title":"poj1847","url":"%2F2019%2F08%2F03%2Fpoj1847.html","content":"<p class=\"description\"></p>\npoj1847，怪问题，最简单的最短路教做人，什么叫真正的自闭。\n\n\n\n![](https://lmf424.oss-cn-beijing.aliyuncs.com/8.3.2%20%281%29.png)\n\n\n\n<!-- more -->\n\n![](poj1847/8.3.1.png)\n\n就这破题我debug了一个半小时！\n\n## 题目链接\n\nhttp://poj.org/problem?id=1847\n\n## 题意\n\n现在有一铁路网络，有n个交叉点，和一些开关。通过开关可以改变路线方向，使其能驶向其他交叉点。开关的初始状态已知，即（初始直接某两点直接相连）。问从出发点到目的地最少要动多少开关才能到达。\n\n```c++\n    3 2 1     3表示共有n个点，接下来有n行，2表示起点，1表示终点\n    2 2 3     第一个数2表示后面有2个数，因为这是第1行，所以后面两个数表示从1到2和从1到3的边\n    2 3 1     表示从2到3和从2到1的边\n    2 1 2     表示从3到1和从3到2的边\n```\n\n## 细节\n\n不用开关的边权值置0，用开关的边权值置1，问题迎刃而解。\n\n就随手写了个dijstra，想着N就100随便过了。然后提交，TLE？？？？思考了一下觉得可能是输入有问题，经过仔细读题，哦题目读错了不要紧（心态平静），然后重写了一下。\n\n然后就坠入WA的地狱了Orz......\n\n排查一个多小时，发现不在函数里输入就会WA（？？？why！！！！？？？？）\n\n心态大崩。\n\n## 代码\n\nWA的版本：\n\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#define inf 0x3f3f3f3f\nusing namespace std;\nint g[110][110];\nint dis[110];\nbool vis[110];\nint n,a,b;\nvoid dijstra()\n{\n//\tmemset(vis,false,sizeof(vis));\n//\tint i,j;\n//\tfor(i=1;i<=n;i++)\n//\t{\n//\t\tdis[i]=e[f][i];\n//\t}\n//\tvis[f]=true;\n//\t\n//\tfor(i=1;i<n;i++)\n//\t{\n//\t\tint min=inf;\n//\t\tint temp;\n//\t\tfor(j=1;j<=n;j++)\n//\t\t{\n//\t\t\tif(dis[j]<min&&!vis[j])\n//\t\t\t{\n//\t\t\t\ttemp=j;\n//\t\t\t\tmin=dis[j];\n//\t\t\t}\n//\t\t}\n//\t\tvis[temp]=true;\n//\t\tint v;\n//\t\tfor(v=1;v<=n;v++)\n//\t\t{\n//\t\t\tif(e[temp][v]<inf)\n//\t\t\t{\n//\t\t\t\tif(!vis[v]&&dis[temp]+e[temp][v]<dis[v])\n//\t\t\t\tdis[v]=dis[temp]+e[temp][v];\n//\t\t\t}\n//\t\t}\n//\t}\n\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tdis[i]=g[a][i];\n\t\t\tvis[i]=false;\n\t\t} \n\t    vis[a]=true;\n\t    for(int k=1;k<n;k++){\n\t        int mind=inf,j;\n\t        for(int i=1;i<=n;i++)\n\t            if(!vis[i] && dis[i]<mind) mind=dis[i],j=i;\n\t        vis[j]=1;\n\t        for(int i=1;i<=n;i++)\n\t            if(!vis[i] && dis[j]+g[j][i]<dis[i]) dis[i]=dis[j]+g[j][i];\n\t    }\n\tif(dis[b]<inf) cout<<dis[b]<<endl;\n    else cout<<-1<<endl;\n}\n\nint main()\n{\n//\tint i,j;\n//\tscanf(\"%d%d%d\",&n,&a,&b);\n//\tfor(i=0;i<=n;i++)\n//\t{\n//\t\tfor(j=0;j<=n;j++)\n//\t\t{\n//\t\t\te[i][j]=inf; \n//\t\t}\n//\t}\n\t\n//\tfor(i=1;i<=n;i++)\n//\t{\n//\t\tint k,m;\n//\t\tscanf(\"%d%d\",&k,&m);\n//\t\te[i][m]=0;\n//\t\tfor(j=1;j<k;j++)\n//\t\t{\n//\t\t\tscanf(\"%d\",&m);\n//\t\t\te[i][m]=1;\n//\t\t}\n//\t}\n\tcin>>n>>a>>b;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=n;j++)\n            g[i][j]=inf;\n    for(int i=1;i<=n;i++)\n\t{\n        int k,m;\n\t\tcin>>k>>m;g[i][m]=0;\n        for(int j=1;j<k;j++)\n\t\t{\n            cin>>m;\n\t\t\tg[i][m]=1;\n        }\n    }\n\tdijstra();\n}\n```\n\n\n\nAC版本：\n\n```c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n#define inf 0x3f3f3f3f\nint g[110][110];\nint d[110],vis[110];\nint n,a,b;\nvoid dij(){\n    cin>>n>>a>>b;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=n;j++)\n            g[i][j]=inf;\n    for(int i=1;i<=n;i++)\n\t{\n        int k,m;\n\t\tcin>>k>>m;g[i][m]=0;\n        for(int j=1;j<k;j++)\n\t\t{\n            cin>>m;\n\t\t\tg[i][m]=1;\n        }\n    }\n    for(int i=1;i<=n;i++)\n\t{\n\t\td[i]=g[a][i];\n\t\tvis[i]=false;\n\t} \n    vis[a]=true;\n    for(int k=1;k<n;k++){\n        int mind=inf,j;\n        for(int i=1;i<=n;i++)\n            if(!vis[i] && d[i]<mind) mind=d[i],j=i;\n        vis[j]=1;\n        for(int i=1;i<=n;i++)\n            if(!vis[i] && d[j]+g[j][i]<d[i]) d[i]=d[j]+g[j][i];\n    }\n    if(d[b]<inf) cout<<d[b]<<endl;\n    else cout<<-1<<endl;\n}\n/*struct edge{\n    int u,v,w;\n}e[10010];\nvoid bellford(){\n    cin>>n>>a>>b; a--; b--; int t=-1;\n    for(int i=0;i<n;i++){\n        int k,m; cin>>k>>m; e[++t].u=i; e[t].v=--m; e[t].w=0;\n        for(int j=1;j<k;j++){\n            cin>>m; e[++t].u=i; e[t].v=--m; e[t].w=1;\n        }\n    }\n    for(int i=0;i<n;i++) d[i]=inf;\n    d[a]=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<=t;j++){\n            if(d[ e[j].u ]+e[j].w < d[ e[j].v ]) d[ e[j].v ]=d[ e[j].u ]+e[j].w;\n        }\n    }\n    if(d[b]<inf) cout<<d[b]<<endl;\n    else cout<<-1<<endl;\n}*/\n#define N 110\n//struct Edge{\n//    int v,w;\n//}e[N*N];\n//int root[N];\n//int next[N*N];\n//void spfa(){\n//    queue<int> q;\n//    cin>>n>>a>>b; a--; b--; int m=-1;\n//    for(int i=0;i<n;i++) root[i]=-1;\n//    for(int i=0;i<n;i++){\n//        int k,y; cin>>k;\n//        for(int j=0;j<k;j++){\n//            cin>>y;\n//            e[++m].v=--y;\n//            e[m].w=(j||0);\n//            next[m]=root[i];\n//            root[i]=m;\n//        }\n//    }\n//    for(int i=0;i<n;i++) d[i]=inf,vis[i]=0;\n//    d[a]=0;\n//    q.push(a);\n//    while(!q.empty()){\n//        int t=q.front();\n//        q.pop(); vis[t]=0;\n//        for(int i=root[t]; i!=-1; i=next[i]){\n//            if( d[t]+e[i].w < d[ e[i].v ] ){\n//                d[ e[i].v ]=d[t]+e[i].w;\n//                if(!vis[ e[i].v ]){\n//                    q.push(e[i].v); vis[ e[i].v ]=1;\n//                }\n//            }\n//        }\n//    }\n//    if(d[b]<inf) cout<<d[b]<<endl;\n//    else cout<<-1<<endl;\n//}\nint main()\n{\n    dij();\n    //bellford();\n//    spfa();\n    return 0;\n}\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj2502","url":"%2F2019%2F08%2F02%2Fpoj2502.html","content":"<p class=\"description\"></p>\npoj2502,单源最短路，时间代替最短路\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2502\n\n## 题意\n\n第一行两个坐标分别是家的坐标和学校的坐标。\n\n接下来每行代表一条地铁线路。相邻两站是联通的。-1-1代表该线结束。\n\n各个坐标间也可以选择步行。步行10km/h，地铁40km/h。\n\n求从家到学校所花的最少分钟数。\n\n## 细节\n\n输入构图麻烦。地铁相邻两站才是联通的，所以地铁站边输入边构图。\n\n还需要注意小时换成分钟数。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#define maxn 500\n#define inf 99999999\nusing namespace std;\n\nstruct node\n{\n\tdouble x,y;\n}n[maxn];\n\ndouble e[maxn][maxn];\n\ndouble dis[maxn];\nbool vis[maxn];\nint sum;\nvoid dijstra(int x)\n{\n\tmemset(vis,false,sizeof(vis));\n\tint i,j,temp;\n\tfor(i=1;i<=sum;i++)\n\tdis[i]=e[1][i];\n\tvis[x]=true;\n\tfor(i=1;i<=sum-1;i++)\n\t{\n\t\tint min=inf;\n\t\tfor(j=1;j<=sum;j++)\n\t\t{\n\t\t\tif(vis[j]==false&&dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tvis[temp]=true;\n\t\tint v;\n\t\tfor(v=1;v<=sum;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[temp]+e[temp][v]<dis[v])\n\t\t\t\t\tdis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i,j,flag;\n\tfor(i=0;i<maxn;i++)\n\tfor(j=0;j<maxn;j++)\n\t\t{\n\t\t\te[i][j]=inf;\n\t\t\tif(i==j)e[i][j]=0;\n\t\t}\n\tscanf(\"%lf%lf\",&n[1].x,&n[1].y);\n\tscanf(\"%lf%lf\",&n[2].x,&n[2].y);\n\ti=3,flag=1;\n\twhile(scanf(\"%lf%lf\",&n[i].x,&n[i].y)!=EOF)\n\t{\n\t\tif(flag==1)\n\t\t{\n\t\t\ti++;\n\t\t\tflag=0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(n[i].x==-1&&n[i].y==-1)\n\t\t{\n\t\t\tflag=1;\n\t\t\tcontinue;\n\t\t}\n\t\te[i][i-1]=sqrt((n[i].x-n[i-1].x)*(n[i].x-n[i-1].x)+(n[i].y-n[i-1].y)*(n[i].y-n[i-1].y))/40000.0*60;\n\t\te[i-1][i]=e[i][i-1];\n\t\ti++;\n\t}\n\tsum=i-1;\n\tint k;\n\tfor(j=1;j<i;j++)\n\t{\n\t\tfor(k=j+1;k<i;k++)\n\t\t{\n\t\t\tif(e[j][k]==inf)\n\t\t\t{\n\t\t\t\te[j][k]=sqrt((n[k].x-n[j].x)*(n[k].x-n[j].x)+(n[k].y-n[j].y)*(n[k].y-n[j].y))/10000.0*60;\n\t\t\t\te[k][j]=e[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tdijstra(1);\n\tprintf(\"%d\",(int)(dis[2]+0.5));\n}\n\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj3159","url":"%2F2019%2F08%2F02%2Fpoj3159.html","content":"<p class=\"description\"></p>\npoj3159，差分约束，单源最短路，dijstra堆优化，前向星存图\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3159\n\n## 题意\n\nn个点，m条边\n\n接下来m行告诉你a，b，c\n\nb比a最多多c个糖果（b-a<=c）\n\n问n最多比1多多少个糖果\n\n## 细节\n\n就是普通的单源最短路，修改一下判断条件就好。\n\n看了眼别人的吐槽：用spfa+queue超时..得改用stack，用刘汝佳的紫书上的dijkstra+优先队列模板也会超时，要改用数组实现的邻接表可以过。\n\n得，直接上前向星堆优化dijstra。\n\n以后考虑用spfa再写一下看看。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define inf 1e10+5\n#define maxn 1000005\nusing namespace std;\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;\nstruct node\n{\n\tint v,w,next;\n}edge[maxn];\nlong long int dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint a[maxn],b[maxn],c[maxn];\nint k,n,m,s;\nvoid adde(int u,int v,int w)\n{\n\tedge[k].v=v;\n\tedge[k].w=w;\n\tedge[k].next=first[u];\n\tfirst[u]=k++;\n}\n\nvoid init()\n{\n\tk=1;\n\tmemset(first,0,sizeof(first));\n\tmemset(edge,0,sizeof(edge));\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\nlong long dijstra(int x)\n{\n\tint i;\n\tdis[x]=0;\n\tq.push(make_pair(dis[x],x));\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top().second;\n\t\tq.pop();\n\t\tif(vis[u]==true)continue;\n\t\tvis[u]=true;\n\t\tfor(i=first[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(!vis[v]&&dis[v]-dis[u]>w)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tq.push(make_pair(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tint i;\n\ts=1;\n\tinit();\n\tint x,y,z;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tadde(x,y,z);\n\t}\n\tdijstra(s);\n\tprintf(\"%d\",dis[n]);\n} \n```\n\n\n\n<hr />\n","tags":["spfa"],"categories":["poj"]},{"title":"P4779","url":"%2F2019%2F08%2F02%2FP4779.html","content":"<p class=\"description\"></p>\n洛谷P4779，单源最短路，dijstra堆优化\n\n标准dijstra堆优化模板\n\n<!-- more -->\n\n## 题目链接\n\nhttps://www.luogu.org/problem/P4779\n\n## 题意\n\n给定一个 N个点，M条有向边的带非负权图，请你计算从 S出发，到每个点的距离。\n\n输入：\n\n第一行为三个正整数N，M，S。 第二行起 M行，每行三个非负整数ui，vi，wi，表示从ui到vi有一条权值为 wi的边。\n\n## 细节\n\n看题目背景感觉小F好惨，以前一直觉得要是我参加过noi就好了，现在觉得打noi的孩子也是不容易。\n\n这题数据蛮大，用普通dijstra应该会TLE。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define inf 1e10+5\n#define maxn 1000005\nusing namespace std;\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;\nstruct node\n{\n\tint v,w,next;\n}edge[maxn];\nlong long int dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint a[maxn],b[maxn],c[maxn];\nint k,n,m,s;\nvoid adde(int u,int v,int w)\n{\n\tedge[k].v=v;\n\tedge[k].w=w;\n\tedge[k].next=first[u];\n\tfirst[u]=k++;\n}\n\nvoid init()\n{\n\tk=1;\n\tmemset(first,0,sizeof(first));\n\tmemset(edge,0,sizeof(edge));\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\nlong long dijstra(int x)\n{\n\tint i;\n\tdis[x]=0;\n\tq.push(make_pair(dis[x],x));\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top().second;\n\t\tq.pop();\n\t\tif(vis[u]==true)continue;\n\t\tvis[u]=true;\n\t\tfor(i=first[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(!vis[v]&&dis[v]>dis[u]+w)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tq.push(make_pair(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&s);\n\tint i;\n\tinit();\n\tint x,y,z;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tadde(x,y,z);\n\t}\n\tdijstra(s);\n\tfor(i=1;i<n;i++)\n\tprintf(\"%d \",dis[i]);\n\tprintf(\"%d\",dis[i]);\n} \n```\n\n\n\n<hr />\n","tags":["洛谷"],"categories":["洛谷"]},{"title":"priority_queue","url":"%2F2019%2F08%2F01%2Fpriority-queue.html","content":"<p class=\"description\"></p>\n## 优先队列（priority_queue）\n\n优先队列是什么呢？\n\n说白了，就是一种功能强大的队列。\n\n强大在于**自动排序**。\n\n原文：https://blog.csdn.net/c20182030/article/details/70757660 \n\n<!-- more -->\n\n优先队列也是队列，所以在头文件queue中。\n\n一个优先队列声明的基本格式是：\n\n**priority_queue<结构类型> 队列名;**\n\n例如：\n\n```c++\npriority_queue <int> i;\npriority_queue <double> d;\n```\n\n但是常用的是这样：\n\n```c++\npriority_queue <node> q;\n//node是一个结构体\n//结构体里重载了‘<’小于符号\npriority_queue <int,vector<int>,greater<int> > q;\n//不需要#include<vector>头文件\n//注意后面两个“>”不要写在一起，“>>”是右移运算符\npriority_queue <int,vector<int>,less<int> >q;\n```\n\n\n\n## 优先队列的基本操作\n\n与队列操作基本一致。\n\n以一个名为q的优先队列为例。\n\n```\nq.size();//返回q里元素个数\nq.empty();//返回q是否为空，空则返回1，否则返回0\nq.push(k);//在q的末尾插入k\nq.pop();//删掉q的第一个元素\nq.top();//返回q的第一个元素\n```\n\n\n\n## 优先队列的特性\n\n**自动排序**\n\n如何排？\n\n#### 默认优先队列（非结构体结构）\n\n```c++\npriority_queue <int> q;\n```\n\n```\n#include<cstdio>\n#include<queue>\nusing namespace std;\npriority_queue <int> q;\nint main()\n{\n\tq.push(10),q.push(8),q.push(12),q.push(14),q.push(6);\n\twhile(!q.empty())\n\t\tprintf(\"%d \",q.top()),q.pop();\n}\n```\n\n程序大意就是在这个优先队列里依次插入10、8、12、14、6，再输出。\n\n结果是什么呢？\n\n14 12 10 8 6\n\n也就是说默认是**从大到小**排序的。\n\n\n\n#### 默认的优先队列（结构体，重载小于）\n\n```c++\nstruct node\n{\n\tint x,y;\n\tbool operator < (const node & a) const\n\t{\n\t\treturn x<a.x;\n\t}\n};\n```\n\n这个node结构体有两个成员，x和y，它的小于规则是x小者小。\n\n验证程序：\n\n```c++\n#include<cstdio>\n#include<queue>\nusing namespace std;\nstruct node\n{\n\tint x,y;\n\tbool operator < (const node & a) const\n\t{\n\t\treturn x<a.x;\n\t}\n}k;\npriority_queue <node> q;\nint main()\n{\n\tk.x=10,k.y=100; q.push(k);\n\tk.x=12,k.y=60; q.push(k);\n\tk.x=14,k.y=40; q.push(k);\n\tk.x=6,k.y=80; q.push(k);\n\tk.x=8,k.y=20; q.push(k);\n\twhile(!q.empty())\n\t{\n\t\tnode m=q.top(); q.pop();\n\t\tprintf(\"(%d,%d) \",m.x,m.y);\n\t}\n}\n```\n\n程序大意就是插入(10,100),(12,60),(14,40),(6,20),(8,20)这五个node。\n\n输出为：\n\n(14,40) (12,60) (10,100) (8,20) (6,80)\n\n它也是按照**重载后的小于规则**，从大到小排序的。\n\n\n\n#### less和greater优先队列\n\n还是以int为例，先来声明：\n\n```c++\npriority_queue <int,vector<int>,less<int> > p;\npriority_queue <int,vector<int>,greater<int> > q;\n```\n\n再次强调：“`>`”不要两个拼在一起。\n\n验证程序：\n\n```\n#include<cstdio>\n#include<queue>\nusing namespace std;\npriority_queue <int,vector<int>,less<int> > p;\npriority_queue <int,vector<int>,greater<int> > q;\nint a[5]={10,12,14,6,8};\nint main()\n{\n\tfor(int i=0;i<5;i++)\n\t\tp.push(a[i]),q.push(a[i]);\n\t\t\n\tprintf(\"less<int>:\")；\n\twhile(!p.empty())\n\t\tprintf(\"%d \",p.top()),p.pop();\t\n\t\t\n\tprintf(\"\\ngreater<int>:\")；\n\twhile(!q.empty())\n\t\tprintf(\"%d \",q.top()),q.pop();\n}\n```\n\n结果：\n\nless<int>:14 12 10 8 6 \n\ngreater<int>:6 8 10 12 14\n\n所以从结果可以知道：**less是从大到小，greater是从小到大**。\n\n\n\n### 总结\n\n平时最好写：\n\n```c++\npriority_queue<int,vector<int>,less<int> >q;\npriority_queue<int,vector<int>,greater<int> >q;\n```\n\n这样两种写法都可以记住。\n\n\n\n### 拓展\n\n如果想把一个队列按不同的方式优先，就要：\n\n```c++\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n;\nstruct node\n{\n\tint fir,sec;\n\tvoid Read() {scanf(\"%d %d\",&fir,&sec);}\n}input;\n\nstruct cmp1\n{\n\tbool operator () (const node &x,const node &y) const\n\t{\n\t\treturn x.fir<y.fir;\n\t}\n};//当一个node x的fir值小于另一个node y的fir值时，称x<y\n\nstruct cmp2\n{\n\tbool operator () (const node &x,const node &y) const\n\t{\n\t\treturn x.sec<y.sec;  \n\t}\n};//当一个node x的sec值小于另一个node y的sec值时，称x<y\n\nstruct cmp3\n{\n\tbool operator () (const node &x,const node &y) const\n\t{\n\t\treturn x.fir+x.sec<y.fir+y.sec; \n\t}\n};//当一个node x的fri值和sec值的和小于另一个node y的fir值和sec值的和时，称x<y\n\npriority_queue<node,vector<node>,cmp1> q1;\npriority_queue<node,vector<node>,cmp2> q2;\npriority_queue<node,vector<node>,cmp3> q3;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) input.Read(),q1.push(input),q2.push(input),q3.push(input);\n\t\n\tprintf(\"\\ncmp1:\\n\");\n\twhile(!q1.empty()) printf(\"(%d,%d) \",q1.top().fir,q1.top().sec),q1.pop();\t\n\t\t\n\tprintf(\"\\n\\ncmp2:\\n\");\n\twhile(!q2.empty()) printf(\"(%d,%d) \",q2.top().fir,q2.top().sec),q2.pop();\t\n\t\t\n\tprintf(\"\\n\\ncmp3:\\n\");\n\twhile(!q3.empty()) printf(\"(%d,%d) \",q3.top().fir,q3.top().sec),q3.pop();\t\n}\n```\n\n读入：\n\n```c++\n7\n1 2\n2 1\n6 9\n9 6\n-100 100\n-500 20\n4000 -3000\n```\n\n输出：\n\n```c++\ncmp1:\n(4000,-3000) (9,6) (6,9) (2,1) (1,2) (-100,100) (-500,20)\n\ncmp2:\n(-100,100) (-500,20) (6,9) (9,6) (1,2) (2,1) (4000,-3000)\n\ncmp3:\n(4000,-3000) (6,9) (9,6) (1,2) (2,1) (-100,100) (-500,20)\n```\n\n\n\n<hr />\n","tags":["STL"],"categories":["STL"]},{"title":"poj1511","url":"%2F2019%2F07%2F31%2Fpoj1511.html","content":"<p class=\"description\"></p>\npoj1511，双向最短路，数据较大，需要SPFA或dijstra堆优化\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1511\n\n## 题意\n\nT组数据。\n\n每组第一行n,m代表有n个点，m条单向边\n\n之后m行告诉你每条边a到b的距离w。\n\n求1到其余各点的最短路径和+其余各点到1的最短路径和。\n\n## 细节\n\n数据很大，最后结果需要longlong存放。\n\n前向星存图。\n\nmemset不能初始化dis为inf。通常只能初始化为0或1。\n\n## 代码\n\n#### SPFA:1844ms\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <iostream>\n#define inf 1e10+5\n#define maxn 1000005\nusing namespace std;\n\nstruct node\n{\n\tint v,w,next;\n}edge[maxn];\n\nint dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint a[maxn],b[maxn],c[maxn];\nint k,n,m;\nvoid adde(int u,int v,int w)\n{\n\tedge[k].v=v;\n\tedge[k].w=w;\n\tedge[k].next=first[u];\n\tfirst[u]=k++;\n}\n\nlong long spfa(int x)\n{\n\tqueue <int>q;\n\tq.push(x);\n\tvis[x]=true;\n\tdis[x]=0;\n\tint i;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tvis[u]=false;\n\t\tfor(i=first[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(dis[v]>dis[u]+w)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tif(!vis[v])\n\t\t\t\t{\n\t\t\t\t\tq.push(v);\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tans=ans+dis[i];\n\t}\n\treturn ans;\n}\n\nvoid init()\n{\n\tk=1;\n\tmemset(first,0,sizeof(first));\n\tmemset(edge,0,sizeof(edge));\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\n\nint main()\n{\n\tint i,j;\n\tlong long ans=0;\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tans=0;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tinit();\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a[i],&b[i],&c[i]);\n\t\t\tadde(a[i],b[i],c[i]);\n\t\t}\n\t\tans=ans+spfa(1);\n\t\tinit();\n\t\tfor(i=1;i<=m;i++)\n\t\t\tadde(b[i],a[i],c[i]);\n\t\tans=ans+spfa(1);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n} \n```\n\n#### dijstra堆优化：2157ms\n\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <functional>\n#define inf 1e10+5\n#define maxn 1000005\nusing namespace std;\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;\nstruct node\n{\n\tint v,w,next;\n}edge[maxn];\nlong long int dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint a[maxn],b[maxn],c[maxn];\nint k,n,m;\nvoid adde(int u,int v,int w)\n{\n\tedge[k].v=v;\n\tedge[k].w=w;\n\tedge[k].next=first[u];\n\tfirst[u]=k++;\n}\n\nvoid init()\n{\n\tk=1;\n\tmemset(first,0,sizeof(first));\n\tmemset(edge,0,sizeof(edge));\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\n\nlong long dijstra(int x)\n{\n\tint i;\n\tdis[x]=0;\n\tq.push(make_pair(dis[x],x));\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top().second;\n\t\tq.pop();\n\t\tif(vis[u]==true)continue;\n\t\tvis[u]=true;\n\t\tfor(i=first[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(!vis[v]&&dis[v]>dis[u]+w)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tq.push(make_pair(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tans=ans+dis[i];\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j;\n\tlong long ans;\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tans=0;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tinit();\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a[i],&b[i],&c[i]);\n\t\t\tadde(a[i],b[i],c[i]);\n\t\t}\n\t\tans=ans+dijstra(1);\n\t\tinit();\n\t\tfor(i=1;i<=m;i++)\n\t\t\tadde(b[i],a[i],c[i]);\n\t\tans=ans+dijstra(1);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n```\n\n#### dijstra堆优化+快速读入+细节改动：1282ms\n\nps：C++提交4250ms，G++提交1282ms\n\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <functional>\n#define inf 1e10+5\n#define maxn 1000005\nusing namespace std;\n\ninline bool scan_d(int &num)  \n{\n        char in;bool IsN=false;\n        in=getchar();\n        if(in==EOF) return false;\n        while(in!='-'&&(in<'0'||in>'9')) in=getchar();\n        if(in=='-'){ IsN=true;num=0;}\n        else num=in-'0';\n        while(in=getchar(),in>='0'&&in<='9'){\n                num*=10,num+=in-'0';\n        }\n        if(IsN) num=-num;\n        return true;\n}\n\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;\nstruct node\n{\n\tint v,w,next;\n}edge[maxn];\nlong long int dis[maxn];\nint first[maxn];\nbool vis[maxn];\nint a[maxn],b[maxn],c[maxn];\nint k,n,m;\nvoid adde(int u,int v,int w)\n{\n\tedge[k].v=v;\n\tedge[k].w=w;\n\tedge[k].next=first[u];\n\tfirst[u]=k++;\n}\n\nvoid init()\n{\n\tk=1;\n\tmemset(first,0,sizeof(first));\n\tmemset(edge,0,sizeof(edge));\n\tmemset(vis,false,sizeof(vis));\n\tint i;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tdis[i]=inf;\n\t}\n}\n\nlong long dijstra(int x)\n{\n\tint i;\n\tdis[x]=0;\n\tq.push(make_pair(dis[x],x));\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top().second;\n\t\tint dd=q.top().first;\n\t\tq.pop();\n\t\tif(dis[u]<dd)continue;//如果前面的点更新了我的距离 \n\t\t//那么队列中会有一个关于这个点的更小的pair<>,最后读到这个点的时候到这个点距离更大\n\t\t//无法更新因此直接跳过 \n\t\tvis[u]=true;\n\t\tfor(i=first[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(!vis[v]&&dis[v]>dis[u]+w)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tq.push(make_pair(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tans=ans+dis[i];\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j;\n\tlong long ans;\n\tint t;\n\tscan_d(t);\n\twhile(t--)\n\t{\n\t\tans=0;\n\t\tscan_d(n);scan_d(m);\n\t\tinit();\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscan_d(a[i]);\n\t\t\tscan_d(b[i]);\n\t\t\tscan_d(c[i]);\n\t\t\tadde(a[i],b[i],c[i]);\n\t\t}\n\t\tans=ans+dijstra(1);\n\t\tinit();\n\t\tfor(i=1;i<=m;i++)\n\t\t\tadde(b[i],a[i],c[i]);\n\t\tans=ans+dijstra(1);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n```\n\n\n\n\n\n<hr />\n","tags":["spfa"],"categories":["poj"]},{"title":"spfa","url":"%2F2019%2F07%2F30%2Fspfa.html","content":"<p class=\"description\"></p>\n## SPFA算法（Shortest Path Faster Algorithm）\n\n复杂度：O（KE）\n\nk为所有顶点进队的平均次数，可以证明k一般小于等于2。\n\n计算单源最短路，图可带负权。玄学复杂度，比普通Dijstra和Floyd要低。\n\n可以判断是否有负环。\n\n<!-- more -->\n\n例：求a点到其余各点的最短路径。\n\n![img](spfa\\1_1.png)\n\n首先建立起始点a到其余各点的最短路径表格dis[]\n\n![img](spfa\\1.jpg)\n\n首先源点a入队，当队列非空时：队首元素（a）出队，对以a为起始点的所有边的终点依次进行松弛操作（此处有b,c,d三个点），此时路径表格状态为：\n\n![img](spfa\\2.jpg)\n\n在松弛时三个点的最短路径估值变小了，而这些点队列中都没有出现，这些点需要入队，此时，队列中新入队了三个结点b,c,d\n\n队首元素b点出队，对以b为起始点的所有边的终点依次进行松弛操作（此处只有e点），此时路径表格状态为：\n\n![img](spfa\\3.jpg)\n\n在最短路径表中，e的最短路径估值也变小了，e在队列中不存在，因此e也要入队，此时队列中的元素为c，d，e\n\n队首元素c点出队，对以c为起始点的所有边的终点依次进行松弛操作（此处有e,f两个点），此时路径表格状态为：\n\n![img](spfa\\4.jpg)\n\n在最短路径表中，e，f的最短路径估值变小了，e在队列中存在，f不存在。因此e不用入队了，f要入队，此时队列中的元素为d，e，f\n\n 队首元素d点出队，对以d为起始点的所有边的终点依次进行松弛操作（此处只有g这个点），此时路径表格状态为：\n\n![img](spfa\\5.jpg)\n\n在最短路径表中，g的最短路径估值没有变小（松弛不成功），没有新结点入队，队列中元素为f，g\n\n队首元素f点出队，对以f为起始点的所有边的终点依次进行松弛操作（此处有d，e，g三个点），此时路径表格状态为：\n\n![img](spfa\\6.jpg)\n\n在最短路径表中，e，g的最短路径估值又变小，队列中无e点，e入队，队列中存在g这个点，g不用入队，此时队列中元素为g，e\n\n队首元素g点出队，对以g为起始点的所有边的终点依次进行松弛操作（此处只有b点），此时路径表格状态为：\n\n![img](spfa\\7.jpg)\n\n在最短路径表中，b的最短路径估值又变小，队列中无b点，b入队，此时队列中元素为e，b队首元素e点出队，对以e为起始点的所有边的终点依次进行松弛操作（此处只有g这个点），此时路径表格状态为：\n\n![img](spfa\\8.jpg)\n\n在最短路径表中，g的最短路径估值没变化（松弛不成功），此时队列中元素为b\n\n队首元素b点出队，对以b为起始点的所有边的终点依次进行松弛操作（此处只有e这个点），此时路径表格状态为：\n\n![img](spfa\\9.jpg)\n\n在最短路径表中，e的最短路径估值没变化（松弛不成功），此时队列为空了。算法结束。\n\n最终dis[]即为a到各点最短路。\n\n若某个点进队了n次即图存在负环。\n\n## 总结\n\n1、创建一个队列，将源点放入。\n\n2、每次从队列中取出一个点X，遍历点X的所有与X相通的节点Y，比较dis[x]+e[x] [y]<dis[y];\n\n如果dis[x]+e[x] [y]<dis[y]，则说明需要更新操作。\n\ndis[y]=dis[x]+e[x] [y]//更新最短路径\n\n由于Y改变了最短路径长度，所以需要以Y开始往后更新，因此如果Y不在队列中，则将Y加入队列。\n\n（在此期间可以记录各个节点的入队次数，判断是否存在负环）\n\n3.循环2，直到队列为空。\n\n## 代码\n\n```c++\nvoid spfa(int x)\n{\n\tqueue <int>q;\n\tq.push(x);//将源点放入队列中\n\tvis[x]=true;//vis变true\n\tdis[x]=0;//源点距离为0，其余点为inf\n\tint i;\n\twhile(!q.empty())//直到队列为空\n\t{\n\t\tint u=q.front();//取出队列第一个元素\n\t\tq.pop();//弹出第一个元素\n\t\tvis[u]=false;//第一个元素因为出队了，所以vis变false\n\t\tfor(i=first[u];i;i=edge[i].next)//遍历第一个元素的所有出边\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tint w=edge[i].w;\n\t\t\tif(dis[v]>dis[u]+w)//判断能否通过第一个元素出边进行松弛\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tif(!vis[v])//可以松弛但不在队列中，那么就放入队列，vis变true\n\t\t\t\t{\n\t\t\t\t\tq.push(v);\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n<hr />\n","tags":["spfa"],"categories":["algorithm"]},{"title":"Topological sort","url":"%2F2019%2F07%2F30%2FTopological-sort.html","content":"<p class=\"description\"></p>\n## 拓扑排序（Topological sort）\n\n拓扑排序是一个比较常用的图论算法，经常用于完成有依赖关系的任务的排序。\n\n时间复杂度：O（N+E）\n\n空间复杂度：O（N）\n\n<!-- more -->\n\n举个例子：\n\n有人想要制作一件工具，但是这个工具不是一次就可以完成的，分很多个步骤，而且这些步骤是有顺序的，也就是说，假设B的顺序在A的后面，那么你就必须要先完成A再完成B，但是也有些步骤不分顺序，意思是你先做哪一个都是可以的。\n\n面对这样的问题，我们可以把步骤建立成一张有向无环图，A指向B意思是A要在B前面完成，那么下面，我们就要找到一个顺序，来使答案符合题目要求。拓扑排序就是干这样的事情的。\n\n![topsort](Topological-sort\\20150507001759702)\n\n那么如何做呢？\n\n只需要遍历一边所有节点，然后找出没有入度的节点，将他们放到一个队列中。\n\n然后通过队列中的无入度的节点，弹出它，删掉这个节点的所有出边，会形成新的没有入度的节点。\n\n再将新的没有入读的节点放入队列，以此循环。\n\n直到队列为空。\n\n如果拓扑排序后的序列个数k小于图的节点数n，那么图中则存在环。环的节点数即为n-k。\n\n## 代码\n\n```c++\nqueue<int>q;\n//priority_queue<int,vector<int>,greater<int>>q;\n//优先队列的话，会按照数值大小有顺序的输出\n//此处为了理解，暂时就用简单队列\ninttopo()\n{\n    for(inti=1;i<=n;i++)\n    {\n        if(indegree[i]==0)\n        {\n            q.push(i);\n        }\n    }\n \n    int temp;\n    while(!q.empty())\n    {\n        temp=q.front();//如果是优先队列，这里可以是top()\n        printf(\"%d->\",temp);\n        q.pop();\n        for(inti=1;i<=n;i++)//遍历从temp出发的每一条边，入度--\n        {\n            if(map[temp][i])\n            {\n                indegree[i]--;\n                if(indegree[i]==0)q.push(i);\n            }\n        }\n    }\n}\n```\n\n\n\n<hr />\n","tags":["topsort"],"categories":["algorithm"]},{"title":"poj2240","url":"%2F2019%2F07%2F29%2Fpoj2240.html","content":"<p class=\"description\"></p>\npoj2240,bellman求正环，map使用\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2240\n\n## 题意\n\nT个国家，接下来T行每个国家的名字。\n\n再输入N，代表N个交换所。\n\n接下来N行，输入A C B\n\n表示A国到B国的汇率是C。\n\n## 细节\n\n用map解决输入问题之后做法就同poj1860\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <iostream>\n#include <map>\nusing namespace std;\nmap<string,int>name;\n\nstruct edge{\n\tint u,v;\n\tdouble w;\n}e[1010];\n\n\n\nint main()\n{\n\tint t,n;\n\tint i=0,j;\n\tstring s,u,v;\n\tdouble w,dis[40];\n\tint time=1;\n\twhile(scanf(\"%d\",&t)!=EOF)\n\t{\n\t\tif(t==0)break;\n\t\tint tt=t;\n\t\ti=0;\n\t\twhile(t--)\n\t\t{\n\t\t\ti++;\n\t\t\tcin >> s;\n\t\t\tname[s]=i;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\ti=1;\n\t\tint k=n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcin >> u >> w >> v ;\n\t\t\te[i].u=name[u];\n\t\t\te[i].v=name[v];\n\t\t\te[i].w=w;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tfor(i=1;i<=tt;i++)\n\t\tdis[i]=0;\n\t\t\n\t\tdis[1]=1;\n\t\t\n\t\tfor(i=1;i<=tt;i++)\n\t\t{\n\t\t\tfor(j=1;j<=k;j++)\n\t\t\t{\n\t\t\t\tif(dis[e[j].v]<dis[e[j].u]*e[j].w)\n\t\t\t\t\tdis[e[j].v]=dis[e[j].u]*e[j].w;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint flag=0;\n\t\tfor(j=1;j<=k;j++)\n\t\t\t{\n\t\t\t\tif(dis[e[j].v]<dis[e[j].u]*e[j].w)\n\t\t\t\t\tflag=1;\n\t\t\t}\n\t\t\t\n\t\tif(flag)printf(\"Case %d: Yes\\n\",time);\n\t\telse printf(\"Case %d: No\\n\",time);\n\t\ttime++;\n\t}\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj3660","url":"%2F2019%2F07%2F28%2Fpoj3660.html","content":"<p class=\"description\"></p>\npojj3660,floyd求有向图的传递闭包\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3660\n\n## 题意\n\nN头牛，给你M个两头牛的关系，即a可以打败b。\n\n问最多能确定几头牛的名次。\n\n即如果这头牛和其余的牛的关系是确定的，那么这个牛的排名就是确定的。\n\n## 细节\n\n传递闭包： 关系之间具有传递性（例如a> b, b> c, 那么a> c）\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999 \nint e[110][110];\nint main()\n{\n\tint n,m,a,b;\n\tscanf(\"%d%d\",&n,&m);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\te[i][j]=0;\n\t\t}\n\t\t\t\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te[a][b]=1;\n\t}\n\t\n\tint k;\n\tfor(k=1;k<=n;k++)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(e[i][k]&&e[k][j])\n\t\t\t\t\t\te[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\n\tint ans=0,flag;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tflag=1;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\telse if(e[i][j]==0&&e[j][i]==0)\n\t\t\t{\n\t\t\t\tflag=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==1)ans++;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj1502","url":"%2F2019%2F07%2F28%2Fpoj1502.html","content":"<p class=\"description\"></p>\npoj1502,单源最短路，坑爹题意，优雅使用sscanf\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1502\n\n## 题意\n\nN个点，之后给你半个邻接矩阵。由于自己到自己是0，所以也不给。\n\nx为无法到达。\n\n求最短路中的最大值。即dis[]中最大值。\n\n## 细节\n\ndijstra模板题。就是输入比较麻烦。\n\nsscanf(s,\"%d\",&e[i] [j]);\n\n这样输入就很简单了。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#define inf 99999999\nint e[110][110];\nint dis[110];\nint book[110];\nint main()\n{\n\tint n,i,j;\n\tscanf(\"%d\",&n);\n\t\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf;\n\t\t}\n\t\n\tchar s[100];\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<i;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%s\",s);\n\t\t\t\tif(s[0]=='x')continue;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsscanf(s,\"%d\",&e[i][j]);\n\t\t\t\t\te[j][i]=e[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\n\tfor(i=1;i<=n;i++)\n\t\tdis[i]=e[1][i];\n\t\n\t\n\tfor(i=1;i<=n;i++)\n\t\tbook[i]=0;\n\t\t\n\tbook[1]=1;\n\tdis[1]=0;\n\tint min,temp;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tmin=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dis[j]<min&&book[j]==0)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\t\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dis[temp]+e[temp][j]<dis[j])\n\t\t\t\tdis[j]=dis[temp]+e[temp][j];\n\t\t}\n\t}\n\t\n\tint max=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(max<dis[i])max=dis[i];\n\t}\n\tprintf(\"%d\\n\",max);\n} \n\n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj3259","url":"%2F2019%2F07%2F28%2Fpoj3259.html","content":"<p class=\"description\"></p>\npoj3259,求负环\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3259\n\n## 题意\n\n有N个点，M条路，W个虫洞。路是双向的，虫洞是单向的。\n\n每次穿越虫洞将会时间回溯虫洞的权值。\n\n问能否通过虫洞回到过去？\n\n## 细节\n\nbellman求负环板子题\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999\nint dis[510];\nint u[6000],v[6000],w[6000];\nint main()\n{\n\tint t,n,m,w1,j;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d%d\",&n,&m,&w1);\n\t\tint i,a,b,c,k=1;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tu[k]=a;v[k]=b;w[k++]=c;\n\t\t\tu[k]=b;v[k]=a;w[k++]=c;\n\t\t}\n\t\tfor(i=1;i<=w1;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tu[k]=a;v[k]=b;w[k++]=-c;\n\t\t}\n\t\t\n\t\tfor(i=1;i<=n;i++)\n\t\tdis[i]=inf;\n\t\t\n\t\tdis[1]=0;\n\t\t\n\t\tfor(j=1;j<=n-1;j++)\n\t\t{\n\t\t\tfor(i=1;i<k;i++)\n\t\t\t{\n\t\t\t\tif(dis[v[i]]>dis[u[i]]+w[i])\n\t\t\t\tdis[v[i]]=dis[u[i]]+w[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint flag=0;\n\t\tfor(i=1;i<k;i++)\n\t\t\t{\n\t\t\t\tif(dis[v[i]]>dis[u[i]]+w[i])\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t\t\n\t\tif(flag==0)printf(\"NO\\n\");\n\t\telse printf(\"YES\\n\");\n\t}\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"bellman","url":"%2F2019%2F07%2F26%2Fbellman.html","content":"\n## Bellman算法\n\nDijstra只能求没有负权边的图，因为当所有边权为正时，不会存在一个路程更短的没有拓展过的点，所以这个点的路程永远不会再改变，从而保证了dijstra的正确性。\n\n那么有没有一个算法可以求带有负权边的指定顶点到其余各个顶点的最短路径算法呢？\n\n那就到Bellman-Ford出场了。\n\n复杂度：O(NM)\n\n优化后：<=O(NM)\n\n<!-- more -->\n\n求1号顶点到其余所有顶点的最短路径。\n\n![1564125629485](bellman\\1564125629485.png)\n\n依旧用dis[]存储1号顶点到所有顶点的距离。\n\n![1564125848909](bellman\\1564125848909.png)\n\n接下来根据边给出的顺序，先处理第一条边2-3  2。\n\n通过2-3这条边进行松弛。即判断dis[3]是否大于dis[2]+2。此时dis[3]是∞，dis[2]也是∞，那么dis[3]<dis[2]+2。所以通过2-3-2不能是dis[3]的值变小，松弛失败。\n\n继续处理第二条边1-2  -3。\n\n发现dis[2]>dis[1]+(-3)，通过这条边可以使dis[2]的值从∞变成-3。因此松弛成功。\n\n以此类推，用同样的方法处理剩下的每一条边。对所有的边松弛一便后的结果如下：\n\n![1564126314876](bellman\\1564126314876.png)\n\n可以发现，1-2和1-5的距离变短了。我们再对所有边进行一轮松弛操作。\n\n![1564126386305](bellman\\1564126386305.png)\n\n如果说floyd是每次只能经过一个点中转来求到达其余个点的最短路径长度，那bellman就是每次只能经过一条边来求到达其余个点的最短路径长度。\n\n如果进行k轮的话，那么就是从1号顶点最多经过k条边到达其余各顶点的最短路径长度。\n\n因为再含有n个顶点的图中，任意两点间的最短路径最多包含n-1条边。\n\n所以最多只需要进行n-1轮松弛即可求出最短路径。\n\n另外，最短路径可能包含回路。\n\n回路分为正权回路和负权回路。\n\n如果包含正权回路，那么去掉正权回路之后一定能找到更短的路径。\n\n如果包含负权回路，那么肯定没有最短路径。因为每多走一次负权回路就可以得到更短的路径。\n\n\n\n继续\n\n![1564127047514](bellman\\1564127047514.png)\n\n完工！\n\n## 总结\n\n对所有的边进行n-1次松弛操作。\n\n## 代码\n\n```c++\nfor(k=1;k<=n;k++)\n\t\tfor(i=1;i<=m;i++)\n\t\t\tif(dis[v[i]]>dis[u[i]]+w[i])\n\t\t\t\tdis[v[i]]=dis[u[i]]+w[i];\n```\n\n## 优化\n\n待施工~~~\n\n<hr />","tags":["bellman"],"categories":["algorithm"]},{"title":"poj1860","url":"%2F2019%2F07%2F26%2Fpoj1860.html","content":"<p class=\"description\"></p>\npoj1860，求图正环\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1860\n\n## 题意\n\n有多种汇币，汇币之间可以交换，这需要手续费，当你用100A币交换B币时，A到B的汇率是29.75，手续费是0.39，那么你可以得到(100 - 0.39) * 29.75 = 2963.3975 B币。问s币的金额经过交换最终得到的s币金额数能否增加。\n\n输入：\n\n第一行，N种货币，M个交换所，你手上拥有的货币种类s，你手上拥有的money；\n\n接下来m行，a币，b币，a到b的汇率，a到b的手续费，b到a的汇率，b到a的手续费。\n\n## 细节\n\nbellman算法求正环，只需要按所有边都松弛一边之后然后进行判断能否再次松弛即可。能继续松弛即为有正环。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999\nint main()\n{\n\tint u[220],v[220];\n\tdouble dis[110],wl[220],ws[220];\n\tint n,m,s,i;\n\tdouble money;\n\tscanf(\"%d%d%d%lf\",&n,&m,&s,&money);\n\ti=0;\n\tint k=m;\n\twhile(m--)\n\t{\n\t\tint a,b;\n\t\tdouble al,as,bl,bs;\n\t\tscanf(\"%d%d%lf%lf%lf%lf\",&a,&b,&al,&as,&bl,&bs);\n\t\tu[i]=a;v[i]=b;wl[i]=al;ws[i]=as;\n\t\ti++;\n\t\tu[i]=b;v[i]=a;wl[i]=bl;ws[i]=bs;\n\t\ti++;\n\t}\n\tint t,j;\n\t\n\tfor(t=0;t<=n;t++)\n\t{\n\t\tdis[t]=0;\n\t}\n\tdis[s]=money;\n\t\n\tfor(t=1;t<=k;t++)\n\t{\n\t\tfor(j=0;j<i;j++)\n\t\t{\n\t\t\tif(dis[v[j]]<(dis[u[j]]-ws[j])*wl[j])\n\t\t\t\tdis[v[j]]=(dis[u[j]]-ws[j])*wl[j];\n\t\t}\n\t}\n\t\n\tint flag=0;\n\tfor(j=0;j<i;j++)\n\t\t{\n\t\t\tif(dis[v[j]]<(dis[u[j]]-ws[j])*wl[j])\n\t\t\t{\n\t\t\t\tdis[v[j]]=(dis[u[j]]-ws[j])*wl[j];\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t\n\tif(flag==1)printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"floyd","url":"%2F2019%2F07%2F25%2Ffloyd.html","content":"<p class=\"description\"></p>\n## Floyed算法\n\n复杂度：O（n^3）\n\npoj又又又又炸了。写一下Floyd吧。核心代码五行，很简单。\n\n求一张图内任意两点间的距离。\n\n![=w=](https://lmf424.oss-cn-beijing.aliyuncs.com/guahua.gif)\n\n<!-- more -->\n\n例如：求任意两个点的最短路程。\n\n![1564051171338](floyd\\1564051171338.png)\n\n用矩阵存储图。\n\n![1564051237886](floyd\\1564051237886.png)\n\n首先我们知道两个点之间的距离了，接下来可以思考，有没有办法通过第三个点来进行中转来缩短路程呢？\n\n因此我们可以假设现在只允许通过1号点进行中转，来进行尝试缩短路程。\n\n只需要判断e[i] [1]+e[1] [j]是否比e[i] [j]小即可。\n\n代码如下：\n\n```c++\nfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[i][j]>e[i][1]+e[1][j])\n\t\t\t\te[i][j]=e[i][1]+e[1][j];\n\t\t}\n\t}\n```\n\n在只允许通过1号顶点的情况下，任意两点间的最短路径更新为：\n\n![1564052208614](floyd\\1564052208614.png)\n\n以此类推，然后考虑只允许通过2号点进行中转。\n\n```c++\nfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[i][j]>e[i][2]+e[2][j])\n\t\t\t\te[i][j]=e[i][2]+e[2][j];\n\t\t}\n\t}\n```\n\n几乎一毛一样，1变成2。\n\n更新：\n\n![1564052291135](floyd\\1564052291135.png)\n\n通过3号点中转更新：\n\n![1564052336765](floyd\\1564052336765.png)\n\n通过4号点中转更新：\n\n![1564052379218](floyd\\1564052379218.png)\n\n更新完毕。上图即为任意两点间最终的最短路程。\n\n## 总结\n\n简单来说就是遍历通过1-n个点的中转来缩短最短路程。\n\n## 代码\n\n```c++\nfor(k=1;k<=n;k++)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(e[i][j]>e[i][k]+e[k][j])\n\t\t\t\t\t\te[i][j]=e[i][k]+e[k][j];\n\t\t\t\t}\n\t\t}\n\t}\n```\n\n\n\n<hr />\n","tags":["floyd"],"categories":["algorithm"]},{"title":"poj3268","url":"%2F2019%2F07%2F25%2Fpoj3268.html","content":"<p class=\"description\"></p>\npoj3268,最短路变形，有向图，求来回距离\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3268\n\n## 题意\n\n给出n个点和m条边，接着是m条边，代表从牛a到牛b需要花费c时间，现在所有牛要到牛x那里去参加聚会，并且所有牛参加聚会后还要回来，给你牛x，除了牛x之外的牛，他们都有一个参加聚会并且回来的最短时间，从这些最短时间里找出一个最大值输出。\n\n## 细节\n\n首先可以想到，所有牛到X的最短距离，那么将X作为起点就可以通过dijstra知道X到其他点的距离。即返程的距离。\n\n只需要转置矩阵一下，就可以求出其他点到X的距离了。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999\nint e[1010][1010];\nint dis[1010];\nint book[1010];\nint sum[1010];\nint n,m,x;\nvoid dijstra()\n{\n\tint i,j;\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[x]=1;\n\tfor(i=1;i<=n;i++)dis[i]=e[x][i];\n\tdis[x]=0;\n\t\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf,temp,v;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0&&dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsum[i]=sum[i]+dis[i];\n\t}\n}\n\nint main()\n{\n\tint a,b,c,i,j;\n\tscanf(\"%d%d%d\",&n,&m,&x);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\te[i][j]=inf;\n\tfor(i=1;i<=n;i++)\n\t\tsum[i]=0;\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t}\n\tdijstra();\n\tint temp;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i;j<=n;j++)\n\t\t{\n\t\t\ttemp=e[i][j];\n\t\t\te[i][j]=e[j][i];\n\t\t\te[j][i]=temp;\n\t\t}\n\tdijstra();\n\tint max=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(i==x)continue;\n\t\telse if(sum[i]>max)max=sum[i];\n\t}\n\tprintf(\"%d\",max);\n} #include <stdio.h>\n#define inf 99999999\nint e[1010][1010];\nint dis[1010];\nint book[1010];\nint sum[1010];\nint n,m,x;\nvoid dijstra()\n{\n\tint i,j;\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[x]=1;\n\tfor(i=1;i<=n;i++)dis[i]=e[x][i];\n\tdis[x]=0;\n\t\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf,temp,v;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0&&dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsum[i]=sum[i]+dis[i];\n\t}\n}\n\nint main()\n{\n\tint a,b,c,i,j;\n\tscanf(\"%d%d%d\",&n,&m,&x);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\te[i][j]=inf;\n\tfor(i=1;i<=n;i++)\n\t\tsum[i]=0;\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t}\n\tdijstra();\n\tint temp;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i;j<=n;j++)\n\t\t{\n\t\t\ttemp=e[i][j];\n\t\t\te[i][j]=e[j][i];\n\t\t\te[j][i]=temp;\n\t\t}\n\tdijstra();\n\tint max=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(i==x)continue;\n\t\telse if(sum[i]>max)max=sum[i];\n\t}\n\tprintf(\"%d\",max);\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"poj1797","url":"%2F2019%2F07%2F24%2Fpoj1797.html","content":"<p class=\"description\"></p>\npoj1797,最短路变形\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1797\n\n## 题意\n\n青蛙那题的变形版本。\n\n输入T组，每组x个点，y条边。\n\n接下来y行分别是a到b的边的权重。\n\n求1到x的所有边中最大的最小边权重。（2333读懂题目就会了）\n\n形象一点理解就是权重为道路的载重量，这题求的就是一辆卡车从1开到x，卡车最多可以载重多少。当然取决于一条路上载重量最低的那条路。输出那条路的载重量。\n\n## 细节\n\n思路：反过来查找dis[]中最大的，那么就能确定1到那个点的最大权重了，然后进行。。松弛？\n\n## 代码\n\nDijstra变形：一开始读错题了导致代码写丑了。\n\n```c++\n#include <stdio.h>\n#include <math.h>\n#define inf 99999999\ndouble funmin(int a,int b)\n{\n\tif(a>b)return b;\n\telse return a;\n}\n\ndouble funmax(int a,int b)\n{\n\tif(a>b)return a;\n\telse return b;\n}\n\nint e[1010][1010],book[1010],dis[1010];\n\nint main()\n{\n\tint t,count=1;\n\tint i,j,x,y,a,b,c;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\tscanf(\"%d%d\",&x,&y);\n\t\n\tfor(i=1;i<=x;i++)\n\t\tfor(j=1;j<=x;j++)\n\t\t\t{\n\t\t\t\tif(i==j)e[i][j]=0;\n\t\t\t\te[i][j]=-inf;\n\t\t\t}\n\t\n\twhile(y--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t\te[b][a]=c;\n\t}\n\t\n\t\n\tfor(i=1;i<=x;i++)\n\t\t{\n\t\t\tdis[i]=e[1][i];\n\t\t\tbook[i]=0;\n\t\t}\n\tdis[1]=0;book[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<x;i++)\n\t{\n\t\tint max=-inf;\n\t\tfor(j=2;j<=x;j++)\n\t\t{\n\t\t\tif(dis[j]>max&&book[j]==0)\n\t\t\t{\n\t\t\t\tmax=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=2;v<=x;v++)\n\t\t{\n\t\t\tif(e[temp][v]>0&&book[v]==0)\n\t\t\t{\n\t\t\t\tdis[v]=funmax(dis[v],funmin(e[temp][v],dis[temp]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Scenario #%d:\\n%d\\n\\n\",count++,dis[x]);\n\t} \n}\n```\n\n\n\n<hr />","tags":["poj"],"categories":["poj"]},{"title":"poj2253","url":"%2F2019%2F07%2F24%2Fpoj2253.html","content":"<p class=\"description\"></p>\npoj2253,最短路变形\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2253\n\n## 题意\n\n第一行T，告诉你有T个点，下面T行是它们的坐标\n\n有两只青蛙，T的第一个是a青蛙坐标，第二个是b青蛙坐标\n\n求a青蛙到b青蛙那里的所有路中最短的 路径中最大的边\n\n\n\n![2253](poj2253\\2253.png)\n\n例：如图所示，1到3距离为1，2到3距离为1，1到2距离为2，那么根据题意，1-3-2最长的边是1，1-2最长的是2，所以输出1。\n\n## 细节\n\n输出有俩\\n\n\n## 代码\n\nDijstra改一改：\n\n```c++\n#include <stdio.h>\n#include <math.h>\n#define inf 99999999\ndouble funmin(double a,double b)\n{\n\tif(a>b)return b;\n\telse return a;\n}\n\ndouble funmax(double a,double b)\n{\n\tif(a>b)return a;\n\telse return b;\n}\n\nint main()\n{\n\tint t,count=1;\n\tint x[210],y[210],book[210];\n\tdouble e[210][210],dis[210];\n\tint i,j;\n\tscanf(\"%d\",&t);\n\twhile(t!=0)\n\t{\n\tfor(i=1;i<=t;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\n\tfor(i=1;i<=t;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\te[i][j]=inf;\n\t\t\t\n\tfor(i=1;i<t;i++)\n\t\tfor(j=i+1;j<=t;j++)\n\t\t{\n\t\t\te[i][j]=e[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t\n\tfor(i=1;i<=t;i++)\n\t\t{\n\t\t\tdis[i]=e[1][i];\n\t\t\tbook[i]=0;\n\t\t}\n\tdis[1]=0;book[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<t;i++)\n\t{\n\t\tdouble min=inf;\n\t\tfor(j=1;j<=t;j++)\n\t\t{\n\t\t\tif(dis[j]<min&&book[j]==0)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=1;v<=t;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tdis[v]=funmin(dis[v],funmax(e[temp][v],dis[temp]));//比较经过temp点松弛后的路线中最长跳跃距离和dis[v]的距离\n\t\t\t\t//if(e[temp][v]+dis[temp]<dis[v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Scenario #%d\\nFrog Distance = %.3lf\\n\\n\",count++,dis[2]);\n\tscanf(\"%d\",&t);\n\t} \n}\n```\n\n\n\n<hr />","tags":["poj"],"categories":["poj"]},{"title":"poj2387","url":"%2F2019%2F07%2F24%2Fpoj2387.html","content":"<p class=\"description\"></p>\n板子题，最短路，poj2387\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2387\n\n## 题意\n\n第一行T组数据，N个顶点\n\n之后T行告诉你a到b的距离c\n\n求到n的最短路径\n\n## 细节\n\n有重边 \\ \\两点之间的路未必只有一条\n\n## 代码\n\nDijstra：\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#define inf 99999999\nint e[1010][1010],dis[1010],book[1010];\n\nint main()\n{\n\tint n,t,a,b,c,i,j;\n\tscanf(\"%d%d\",&t,&n);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf; \n\t\t}\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tif(e[a][b]>c)\n\t\t{\n\t\t\te[a][b]=c;\n\t\t\te[b][a]=c;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tdis[i]=e[1][i];\n\t\tbook[i]=0;\n\t}\n\tdis[1]=0;\n\tbook[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dis[j]<min&&book[j]==0)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",dis[n]);\n} \n```\n\n\n\n<hr />\n","tags":["poj"],"categories":["poj"]},{"title":"dijstra","url":"%2F2019%2F07%2F23%2Fdijstra.html","content":"## Dijstra算法\n\n博客初建，先记录一个基础的单源最短路算法，Dijstra。\n\n复杂度：O（N²）\n\n![lalala](https://lmf424.oss-cn-beijing.aliyuncs.com/lalala.gif)\n\n<!-- more -->\n\n例如求1到各个顶点的最短路径。\n\n![1](dijstra/1563866213798.png)\n\n首先考虑图的存储问题，使用二维数组e来进行存储各个点之间的边的长度。\n\n![2](dijstra/1563862729194.png)\n\n然后创建一个一维数组dis来存储1号顶点到其余各个顶点的初始路程。\n\n![3](dijstra/1563862773804.png)\n\n此时dis数组中的值称为最短路程的“估计值”。\n\n既然是找最短路，那么根据dis可以寻找到离点1最近的顶点是2。\n\n那么dis[2]的值就变成了“确定值”。即点1到点2的最短距离就是dis[2]的值。\n\n既然选择了2号顶点，那就继续看2号顶点的几条出边。有2-3和2-4这两条，先讨论2-3能否让1号顶点到3号顶点的路程变短，即比较dis[3]和dis[2]+e[2] [3]的大小。\n\ndis[3]=12,dis[2]+e[2] [3]=10,dis[3]>dis[2]+e[2] [3],所以可以通过1-2-3这样缩短1-3的距离，因此dis[3]更新为10。这个过程专业点称为“松弛”。\n\n同理，dis[2]+e[2] [4]<dis[4],dis[4]的值可以松弛为4。\n\n这样2号顶点的所有出边就都松弛完了。松弛之后的dis数组为：\n\n![5](dijstra/1563863527940.png)\n\n接下来以此类推，在剩下的3，4，5，6号顶点中选出离1最近的顶点。\n\n通过dis数组可以发现最近的顶点是4。\n\ndis[4]的值变成“确定值”。\n\n然后继续对4号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![6](dijstra/1563863664903.png)\n\n以此类推，在剩下的3，5，6号顶点中，选出离1号最近的顶点。这次选择3号顶点。\n\ndis[3]的值变成“确定值”。\n\n对3号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![7](dijstra/1563863742582.png)\n\n在剩下的5，6号顶点中，选出离1号最近的顶点。选择5号。\n\ndis[5]的值变成“确定值”。\n\n对5号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![8](dijstra/1563863819140.png)\n\n最后选择6号。\n\ndis[6]的值变成“确定值”。\n\n最后对6号顶点的所有出边进行松弛。因为此例6号没有出边，因此不用处理。\n\n至此，dis数组中所有的值都已经从“估计值”变成了“确定值”。\n\n最终dis数组如下，这便是1号顶点到各个顶点的最短路径。\n\n![10](dijstra/1563863951516.png)\n\n## 总结\n\n算法基本思想：每次都找离源点最近的顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define MAXN 101 //最大顶点数 \nint main()\n{\n\tint e[MAXN][MAXN],dis[MAXN];\n\tint temp,v,i,j,a,b,c,n,m,min;\n\tint inf=99999999;//存储一个认为正无穷的值\n\tscanf(\"%d%d\",&n,&m);//n个顶点，m条边\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf;\n\t//初始化 \n\t \n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t} \n\t//读入边\n\t\n\tfor(i=1;i<=n;i++)\n\t\tdis[i]=e[1][i];\n\t//初始化dis数组\n\t\n\tint book[MAXN];//在代码中，需要用一个book数组进行标记估计值还是确定值\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[1]=1;\n\t\n\t//Dijstra算法核心语句\n\tfor(i=1;i<=n-1;i++)\n\t{\n\t\tmin=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0 && dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;//记录最小的顶点号 \n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;//dis[temp]变成确定值\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)//进行松弛 \n\t\t\t{\n\t\t\t\tif(dis[temp]+e[temp][v]<dis[v])\n\t\t\t\t\tdis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(i=1;i<=n;i++)\n\t\tprintf(\"%d \",dis[i]);//输出结果 \n\n} \n```\n\n","tags":["dijstra"],"categories":["algorithm"]},{"title":"my first blog","url":"%2F2019%2F07%2F22%2Fmy-first.html","content":"<p class=\"description\"></p>\n![first](https://lmf424.oss-cn-beijing.aliyuncs.com/first.jpg)\n\n<!-- more -->\n\n经过两天的搭建，终于好像搭好了！安装上了node,git,hexo.然后扔GitHub然后买了个域名。编辑md软件用的Typora，蛮好用。\n\n域名yuanfang.tech，既有远方，又有远芳的意思，还可以记成元芳，给别人记应该很好记23333（没办法lmf太贵了）。本来还想起个英文的，但算了，中文更写意。tech很有dalao的感觉。\n\n计划以后写题啊算法啥的都往上放。\n\n就先这样，功能慢慢加，日后完善。\n\n<hr />\n","tags":["test"],"categories":["somethings"]}]