[{"title":"dijstra","url":"%2F2019%2F07%2F23%2Fdijstra.html","content":"## Dijstra算法\n\n博客初建，先记录一个基础的单源最短路算法，Dijstra。\n\n复杂度：O（N²）\n\n![lalala](http://pv35325dx.bkt.clouddn.com/lalala.gif)\n\n<!-- more -->\n\n例如求1到各个顶点的最短路径。\n\n![1](http://pv35325dx.bkt.clouddn.com/1563866213798.png)\n\n首先考虑图的存储问题，使用二维数组e来进行存储各个点之间的边的长度。\n\n![2](http://pv35325dx.bkt.clouddn.com/1563862729194.png)\n\n然后创建一个一维数组dis来存储1号顶点到其余各个顶点的初始路程。\n\n![3](http://pv35325dx.bkt.clouddn.com/1563862773804.png)\n\n此时dis数组中的值称为最短路程的“估计值”。\n\n既然是找最短路，那么根据dis可以寻找到离点1最近的顶点是2。\n\n那么dis[2]的值就变成了“确定值”。即点1到点2的最短距离就是dis[2]的值。\n\n既然选择了2号顶点，那就继续看2号顶点的几条出边。有2-3和2-4这两条，先讨论2-3能否让1号顶点到3号顶点的路程变短，即比较dis[3]和dis[2]+e[2] [3]的大小。\n\ndis[3]=12,dis[2]+e[2] [3]=10,dis[3]>dis[2]+e[2] [3],所以可以通过1-2-3这样缩短1-3的距离，因此dis[3]更新为10。这个过程专业点称为“松弛”。\n\n同理，dis[2]+e[2] [4]<dis[4],dis[4]的值可以松弛为4。\n\n这样2号顶点的所有出边就都松弛完了。松弛之后的dis数组为：\n\n![5](http://pv35325dx.bkt.clouddn.com/1563863527940.png)\n\n接下来以此类推，在剩下的3，4，5，6号顶点中选出离1最近的顶点。\n\n通过dis数组可以发现最近的顶点是4。\n\ndis[4]的值变成“确定值”。\n\n然后继续对4号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![6](http://pv35325dx.bkt.clouddn.com/1563863664903.png)\n\n以此类推，在剩下的3，5，6号顶点中，选出离1号最近的顶点。这次选择3号顶点。\n\ndis[3]的值变成“确定值”。\n\n对3号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![7](http://pv35325dx.bkt.clouddn.com/1563863742582.png)\n\n在剩下的5，6号顶点中，选出离1号最近的顶点。选择5号。\n\ndis[5]的值变成“确定值”。\n\n对5号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![8](http://pv35325dx.bkt.clouddn.com/1563863819140.png)\n\n最后选择6号。\n\ndis[6]的值变成“确定值”。\n\n最后对6号顶点的所有出边进行松弛。因为此例6号没有出边，因此不用处理。\n\n至此，dis数组中所有的值都已经从“估计值”变成了“确定值”。\n\n最终dis数组如下，这便是1号顶点到各个顶点的最短路径。\n\n![10](http://pv35325dx.bkt.clouddn.com/1563863951516.png)\n\n## 总结\n\n算法基本思想：每次都找离源点最近的顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define MAXN 101 //最大顶点数 \nint main()\n{\n\tint e[MAXN][MAXN],dis[MAXN];\n\tint temp,v,i,j,a,b,c,n,m,min;\n\tint inf=99999999;//存储一个认为正无穷的值\n\tscanf(\"%d%d\",&n,&m);//n个顶点，m条边\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf;\n\t//初始化 \n\t \n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t} \n\t//读入边\n\t\n\tfor(i=1;i<=n;i++)\n\t\tdis[i]=e[1][i];\n\t//初始化dis数组\n\t\n\tint book[MAXN];//在代码中，需要用一个book数组进行标记估计值还是确定值\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[1]=1;\n\t\n\t//Dijstra算法核心语句\n\tfor(i=1;i<=n-1;i++)\n\t{\n\t\tmin=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0 && dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;//记录最小的顶点号 \n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;//dis[temp]变成确定值\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)//进行松弛 \n\t\t\t{\n\t\t\t\tif(dis[temp]+e[temp][v]<dis[v])\n\t\t\t\t\tdis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(i=1;i<=n;i++)\n\t\tprintf(\"%d \",dis[i]);//输出结果 \n\n} \n```\n\n","tags":["dijstra"],"categories":["algorithm"]},{"title":"my first blog","url":"%2F2019%2F07%2F22%2Fmy-first.html","content":"<p class=\"description\"></p>\n![first](http://pv35325dx.bkt.clouddn.com/first.jpg)\n\n<!-- more -->\n\n经过两天的搭建，终于好像搭好了！安装上了node,git,hexo.然后扔GitHub然后买了个域名。编辑md软件用的Typora，蛮好用。\n\n域名yuanfang.tech，既有远方，又有远芳的意思，还可以记成元芳，给别人记应该很好记23333（没办法lmf太贵了）。本来还想起个英文的，但算了，中文更写意。tech很有dalao的感觉。\n\n计划以后写题啊算法啥的都往上放。\n\n就先这样，功能慢慢加，日后完善。\n\n<hr />\n","tags":["test"],"categories":["somethings"]}]