[{"title":"floyd","url":"%2F2019%2F07%2F25%2Ffloyd.html","content":"<p class=\"description\"></p>\n## Floyed算法\n\n复杂度：O（n^3）\n\npoj又又又又炸了。写一下Floyd吧。核心代码五行，很简单。\n\n求一张图内任意两点间的距离。\n\n![=w=](http://pv35325dx.bkt.clouddn.com/guahua.gif)\n\n<!-- more -->\n\n例如：求任意两个点的最短路程。\n\n![1564051171338](floyd\\1564051171338.png)\n\n用矩阵存储图。\n\n![1564051237886](floyd\\1564051237886.png)\n\n首先我们知道两个点之间的距离了，接下来可以思考，有没有办法通过第三个点来进行中转来缩短路程呢？\n\n因此我们可以假设现在只允许通过1号点进行中转，来进行尝试缩短路程。\n\n只需要判断e[i] [1]+e[1] [j]是否比e[i] [j]小即可。\n\n代码如下：\n\n```c++\nfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[i][j]>e[i][1]+e[1][j])\n\t\t\t\te[i][j]=e[i][1]+e[1][j];\n\t\t}\n\t}\n```\n\n在只允许通过1号顶点的情况下，任意两点间的最短路径更新为：\n\n![1564052208614](floyd\\1564052208614.png)\n\n以此类推，然后考虑只允许通过2号点进行中转。\n\n```c++\nfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[i][j]>e[i][2]+e[2][j])\n\t\t\t\te[i][j]=e[i][2]+e[2][j];\n\t\t}\n\t}\n```\n\n几乎一毛一样，1变成2。\n\n更新：\n\n![1564052291135](floyd\\1564052291135.png)\n\n通过3号点中转更新：\n\n![1564052336765](floyd\\1564052336765.png)\n\n通过4号点中转更新：\n\n![1564052379218](floyd\\1564052379218.png)\n\n更新完毕。上图即为任意两点间最终的最短路程。\n\n## 总结\n\n简单来说就是遍历通过1-n个点的中转来缩短最短路程。\n\n## 代码\n\n```c++\nfor(k=1;k<=n;k++)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(e[i][j]>e[i][k]+e[k][j])\n\t\t\t\t\t\te[i][j]=e[i][k]+e[k][j];\n\t\t\t\t}\n\t\t}\n\t}\n```\n\n\n\n<hr />\n","tags":["floyd"],"categories":["algorithm"]},{"title":"poj3268","url":"%2F2019%2F07%2F25%2Fpoj3268.html","content":"<p class=\"description\"></p>\npoj3268,最短路变形，有向图，求来回距离\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3268\n\n## 题意\n\n给出n个点和m条边，接着是m条边，代表从牛a到牛b需要花费c时间，现在所有牛要到牛x那里去参加聚会，并且所有牛参加聚会后还要回来，给你牛x，除了牛x之外的牛，他们都有一个参加聚会并且回来的最短时间，从这些最短时间里找出一个最大值输出。\n\n## 细节\n\n首先可以想到，所有牛到X的最短距离，那么将X作为起点就可以通过dijstra知道X到其他点的距离。即返程的距离。\n\n只需要转置矩阵一下，就可以求出其他点到X的距离了。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999\nint e[1010][1010];\nint dis[1010];\nint book[1010];\nint sum[1010];\nint n,m,x;\nvoid dijstra()\n{\n\tint i,j;\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[x]=1;\n\tfor(i=1;i<=n;i++)dis[i]=e[x][i];\n\tdis[x]=0;\n\t\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf,temp,v;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0&&dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsum[i]=sum[i]+dis[i];\n\t}\n}\n\nint main()\n{\n\tint a,b,c,i,j;\n\tscanf(\"%d%d%d\",&n,&m,&x);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\te[i][j]=inf;\n\tfor(i=1;i<=n;i++)\n\t\tsum[i]=0;\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t}\n\tdijstra();\n\tint temp;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i;j<=n;j++)\n\t\t{\n\t\t\ttemp=e[i][j];\n\t\t\te[i][j]=e[j][i];\n\t\t\te[j][i]=temp;\n\t\t}\n\tdijstra();\n\tint max=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(i==x)continue;\n\t\telse if(sum[i]>max)max=sum[i];\n\t}\n\tprintf(\"%d\",max);\n} #include <stdio.h>\n#define inf 99999999\nint e[1010][1010];\nint dis[1010];\nint book[1010];\nint sum[1010];\nint n,m,x;\nvoid dijstra()\n{\n\tint i,j;\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[x]=1;\n\tfor(i=1;i<=n;i++)dis[i]=e[x][i];\n\tdis[x]=0;\n\t\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf,temp,v;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0&&dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsum[i]=sum[i]+dis[i];\n\t}\n}\n\nint main()\n{\n\tint a,b,c,i,j;\n\tscanf(\"%d%d%d\",&n,&m,&x);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\te[i][j]=inf;\n\tfor(i=1;i<=n;i++)\n\t\tsum[i]=0;\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t}\n\tdijstra();\n\tint temp;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i;j<=n;j++)\n\t\t{\n\t\t\ttemp=e[i][j];\n\t\t\te[i][j]=e[j][i];\n\t\t\te[j][i]=temp;\n\t\t}\n\tdijstra();\n\tint max=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(i==x)continue;\n\t\telse if(sum[i]>max)max=sum[i];\n\t}\n\tprintf(\"%d\",max);\n} \n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["poj"]},{"title":"poj1797","url":"%2F2019%2F07%2F24%2Fpoj1797.html","content":"<p class=\"description\"></p>\npoj1797,最短路变形\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1797\n\n## 题意\n\n青蛙那题的变形版本。\n\n输入T组，每组x个点，y条边。\n\n接下来y行分别是a到b的边的权重。\n\n求1到x的所有边中最大的最小边权重。（2333读懂题目就会了）\n\n形象一点理解就是权重为道路的载重量，这题求的就是一辆卡车从1开到x，卡车最多可以载重多少。当然取决于一条路上载重量最低的那条路。输出那条路的载重量。\n\n## 细节\n\n思路：反过来查找dis[]中最大的，那么就能确定1到那个点的最大权重了，然后进行。。松弛？\n\n## 代码\n\nDijstra变形：一开始读错题了导致代码写丑了。\n\n```c++\n#include <stdio.h>\n#include <math.h>\n#define inf 99999999\ndouble funmin(int a,int b)\n{\n\tif(a>b)return b;\n\telse return a;\n}\n\ndouble funmax(int a,int b)\n{\n\tif(a>b)return a;\n\telse return b;\n}\n\nint e[1010][1010],book[1010],dis[1010];\n\nint main()\n{\n\tint t,count=1;\n\tint i,j,x,y,a,b,c;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\tscanf(\"%d%d\",&x,&y);\n\t\n\tfor(i=1;i<=x;i++)\n\t\tfor(j=1;j<=x;j++)\n\t\t\t{\n\t\t\t\tif(i==j)e[i][j]=0;\n\t\t\t\te[i][j]=-inf;\n\t\t\t}\n\t\n\twhile(y--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t\te[b][a]=c;\n\t}\n\t\n\t\n\tfor(i=1;i<=x;i++)\n\t\t{\n\t\t\tdis[i]=e[1][i];\n\t\t\tbook[i]=0;\n\t\t}\n\tdis[1]=0;book[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<x;i++)\n\t{\n\t\tint max=-inf;\n\t\tfor(j=2;j<=x;j++)\n\t\t{\n\t\t\tif(dis[j]>max&&book[j]==0)\n\t\t\t{\n\t\t\t\tmax=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=2;v<=x;v++)\n\t\t{\n\t\t\tif(e[temp][v]>0&&book[v]==0)\n\t\t\t{\n\t\t\t\tdis[v]=funmax(dis[v],funmin(e[temp][v],dis[temp]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Scenario #%d:\\n%d\\n\\n\",count++,dis[x]);\n\t} \n}\n```\n\n\n\n<hr />","tags":["kuangbin"],"categories":["poj"]},{"title":"poj2253","url":"%2F2019%2F07%2F24%2Fpoj2253.html","content":"<p class=\"description\"></p>\npoj2253,最短路变形\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2253\n\n## 题意\n\n第一行T，告诉你有T个点，下面T行是它们的坐标\n\n有两只青蛙，T的第一个是a青蛙坐标，第二个是b青蛙坐标\n\n求a青蛙到b青蛙那里的所有路中最短的 路径中最大的边\n\n\n\n![2253](poj2253\\2253.png)\n\n例：如图所示，1到3距离为1，2到3距离为1，1到2距离为2，那么根据题意，1-3-2最长的边是1，1-2最长的是2，所以输出1。\n\n## 细节\n\n输出有俩\\n\n\n## 代码\n\nDijstra改一改：\n\n```c++\n#include <stdio.h>\n#include <math.h>\n#define inf 99999999\ndouble funmin(double a,double b)\n{\n\tif(a>b)return b;\n\telse return a;\n}\n\ndouble funmax(double a,double b)\n{\n\tif(a>b)return a;\n\telse return b;\n}\n\nint main()\n{\n\tint t,count=1;\n\tint x[210],y[210],book[210];\n\tdouble e[210][210],dis[210];\n\tint i,j;\n\tscanf(\"%d\",&t);\n\twhile(t!=0)\n\t{\n\tfor(i=1;i<=t;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\n\tfor(i=1;i<=t;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\te[i][j]=inf;\n\t\t\t\n\tfor(i=1;i<t;i++)\n\t\tfor(j=i+1;j<=t;j++)\n\t\t{\n\t\t\te[i][j]=e[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t\n\tfor(i=1;i<=t;i++)\n\t\t{\n\t\t\tdis[i]=e[1][i];\n\t\t\tbook[i]=0;\n\t\t}\n\tdis[1]=0;book[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<t;i++)\n\t{\n\t\tdouble min=inf;\n\t\tfor(j=1;j<=t;j++)\n\t\t{\n\t\t\tif(dis[j]<min&&book[j]==0)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=1;v<=t;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tdis[v]=funmin(dis[v],funmax(e[temp][v],dis[temp]));//比较经过temp点松弛后的路线中最长跳跃距离和dis[v]的距离\n\t\t\t\t//if(e[temp][v]+dis[temp]<dis[v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Scenario #%d\\nFrog Distance = %.3lf\\n\\n\",count++,dis[2]);\n\tscanf(\"%d\",&t);\n\t} \n}\n```\n\n\n\n<hr />","tags":["kuangbin"],"categories":["poj"]},{"title":"poj2387","url":"%2F2019%2F07%2F24%2Fpoj2387.html","content":"<p class=\"description\"></p>\n板子题，最短路，poj2387\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2387\n\n## 题意\n\n第一行T组数据，N个顶点\n\n之后T行告诉你a到b的距离c\n\n求到n的最短路径\n\n## 细节\n\n有重边 \\ \\两点之间的路未必只有一条\n\n## 代码\n\nDijstra：\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#define inf 99999999\nint e[1010][1010],dis[1010],book[1010];\n\nint main()\n{\n\tint n,t,a,b,c,i,j;\n\tscanf(\"%d%d\",&t,&n);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf; \n\t\t}\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tif(e[a][b]>c)\n\t\t{\n\t\t\te[a][b]=c;\n\t\t\te[b][a]=c;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tdis[i]=e[1][i];\n\t\tbook[i]=0;\n\t}\n\tdis[1]=0;\n\tbook[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dis[j]<min&&book[j]==0)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",dis[n]);\n} \n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["poj"]},{"title":"dijstra","url":"%2F2019%2F07%2F23%2Fdijstra.html","content":"## Dijstra算法\n\n博客初建，先记录一个基础的单源最短路算法，Dijstra。\n\n复杂度：O（N²）\n\n![lalala](http://pv35325dx.bkt.clouddn.com/lalala.gif)\n\n<!-- more -->\n\n例如求1到各个顶点的最短路径。\n\n![1](http://pv35325dx.bkt.clouddn.com/1563866213798.png)\n\n首先考虑图的存储问题，使用二维数组e来进行存储各个点之间的边的长度。\n\n![2](http://pv35325dx.bkt.clouddn.com/1563862729194.png)\n\n然后创建一个一维数组dis来存储1号顶点到其余各个顶点的初始路程。\n\n![3](http://pv35325dx.bkt.clouddn.com/1563862773804.png)\n\n此时dis数组中的值称为最短路程的“估计值”。\n\n既然是找最短路，那么根据dis可以寻找到离点1最近的顶点是2。\n\n那么dis[2]的值就变成了“确定值”。即点1到点2的最短距离就是dis[2]的值。\n\n既然选择了2号顶点，那就继续看2号顶点的几条出边。有2-3和2-4这两条，先讨论2-3能否让1号顶点到3号顶点的路程变短，即比较dis[3]和dis[2]+e[2] [3]的大小。\n\ndis[3]=12,dis[2]+e[2] [3]=10,dis[3]>dis[2]+e[2] [3],所以可以通过1-2-3这样缩短1-3的距离，因此dis[3]更新为10。这个过程专业点称为“松弛”。\n\n同理，dis[2]+e[2] [4]<dis[4],dis[4]的值可以松弛为4。\n\n这样2号顶点的所有出边就都松弛完了。松弛之后的dis数组为：\n\n![5](http://pv35325dx.bkt.clouddn.com/1563863527940.png)\n\n接下来以此类推，在剩下的3，4，5，6号顶点中选出离1最近的顶点。\n\n通过dis数组可以发现最近的顶点是4。\n\ndis[4]的值变成“确定值”。\n\n然后继续对4号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![6](http://pv35325dx.bkt.clouddn.com/1563863664903.png)\n\n以此类推，在剩下的3，5，6号顶点中，选出离1号最近的顶点。这次选择3号顶点。\n\ndis[3]的值变成“确定值”。\n\n对3号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![7](http://pv35325dx.bkt.clouddn.com/1563863742582.png)\n\n在剩下的5，6号顶点中，选出离1号最近的顶点。选择5号。\n\ndis[5]的值变成“确定值”。\n\n对5号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![8](http://pv35325dx.bkt.clouddn.com/1563863819140.png)\n\n最后选择6号。\n\ndis[6]的值变成“确定值”。\n\n最后对6号顶点的所有出边进行松弛。因为此例6号没有出边，因此不用处理。\n\n至此，dis数组中所有的值都已经从“估计值”变成了“确定值”。\n\n最终dis数组如下，这便是1号顶点到各个顶点的最短路径。\n\n![10](http://pv35325dx.bkt.clouddn.com/1563863951516.png)\n\n## 总结\n\n算法基本思想：每次都找离源点最近的顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define MAXN 101 //最大顶点数 \nint main()\n{\n\tint e[MAXN][MAXN],dis[MAXN];\n\tint temp,v,i,j,a,b,c,n,m,min;\n\tint inf=99999999;//存储一个认为正无穷的值\n\tscanf(\"%d%d\",&n,&m);//n个顶点，m条边\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf;\n\t//初始化 \n\t \n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t} \n\t//读入边\n\t\n\tfor(i=1;i<=n;i++)\n\t\tdis[i]=e[1][i];\n\t//初始化dis数组\n\t\n\tint book[MAXN];//在代码中，需要用一个book数组进行标记估计值还是确定值\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[1]=1;\n\t\n\t//Dijstra算法核心语句\n\tfor(i=1;i<=n-1;i++)\n\t{\n\t\tmin=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0 && dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;//记录最小的顶点号 \n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;//dis[temp]变成确定值\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)//进行松弛 \n\t\t\t{\n\t\t\t\tif(dis[temp]+e[temp][v]<dis[v])\n\t\t\t\t\tdis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(i=1;i<=n;i++)\n\t\tprintf(\"%d \",dis[i]);//输出结果 \n\n} \n```\n\n","tags":["dijstra"],"categories":["algorithm"]},{"title":"my first blog","url":"%2F2019%2F07%2F22%2Fmy-first.html","content":"<p class=\"description\"></p>\n![first](http://pv35325dx.bkt.clouddn.com/first.jpg)\n\n<!-- more -->\n\n经过两天的搭建，终于好像搭好了！安装上了node,git,hexo.然后扔GitHub然后买了个域名。编辑md软件用的Typora，蛮好用。\n\n域名yuanfang.tech，既有远方，又有远芳的意思，还可以记成元芳，给别人记应该很好记23333（没办法lmf太贵了）。本来还想起个英文的，但算了，中文更写意。tech很有dalao的感觉。\n\n计划以后写题啊算法啥的都往上放。\n\n就先这样，功能慢慢加，日后完善。\n\n<hr />\n","tags":["test"],"categories":["somethings"]}]