[{"title":"Topological sort","url":"%2F2019%2F07%2F30%2FTopological-sort.html","content":"<p class=\"description\"></p>\n## 拓扑排序（Topological sort）\n\n拓扑排序是一个比较常用的图论算法，经常用于完成有依赖关系的任务的排序。\n\n时间复杂度：O（N+E）\n\n空间复杂度：O（N）\n\n<!-- more -->\n\n举个例子：\n\n有人想要制作一件工具，但是这个工具不是一次就可以完成的，分很多个步骤，而且这些步骤是有顺序的，也就是说，假设B的顺序在A的后面，那么你就必须要先完成A再完成B，但是也有些步骤不分顺序，意思是你先做哪一个都是可以的。\n\n面对这样的问题，我们可以把步骤建立成一张有向无环图，A指向B意思是A要在B前面完成，那么下面，我们就要找到一个顺序，来使答案符合题目要求。拓扑排序就是干这样的事情的。\n\n![topsort](Topological-sort\\20150507001759702)\n\n那么如何做呢？\n\n只需要遍历一边所有节点，然后找出没有入度的节点，将他们放到一个队列中。\n\n然后通过队列中的无入度的节点，弹出它，删掉这个节点的所有出边，会形成新的没有入度的节点。\n\n再将新的没有入读的节点放入队列，以此循环。\n\n直到队列为空。\n\n如果拓扑排序后的序列个数k小于图的节点数n，那么图中则存在环。环的节点数即为n-k。\n\n## 代码\n\n```c++\nqueue<int>q;\n//priority_queue<int,vector<int>,greater<int>>q;\n//优先队列的话，会按照数值大小有顺序的输出\n//此处为了理解，暂时就用简单队列\ninttopo()\n{\n    for(inti=1;i<=n;i++)\n    {\n        if(indegree[i]==0)\n        {\n            q.push(i);\n        }\n    }\n \n    int temp;\n    while(!q.empty())\n    {\n        temp=q.front();//如果是优先队列，这里可以是top()\n        printf(\"%d->\",temp);\n        q.pop();\n        for(inti=1;i<=n;i++)//遍历从temp出发的每一条边，入度--\n        {\n            if(map[temp][i])\n            {\n                indegree[i]--;\n                if(indegree[i]==0)q.push(i);\n            }\n        }\n    }\n}\n```\n\n\n\n<hr />\n","tags":["topsort"],"categories":["algorithm"]},{"title":"poj2240","url":"%2F2019%2F07%2F29%2Fpoj2240.html","content":"<p class=\"description\"></p>\npoj2240,bellman求正环，map使用\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2240\n\n## 题意\n\nT个国家，接下来T行每个国家的名字。\n\n再输入N，代表N个交换所。\n\n接下来N行，输入A C B\n\n表示A国到B国的汇率是C。\n\n## 细节\n\n用map解决输入问题之后做法就同poj1860\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <iostream>\n#include <map>\nusing namespace std;\nmap<string,int>name;\n\nstruct edge{\n\tint u,v;\n\tdouble w;\n}e[1010];\n\n\n\nint main()\n{\n\tint t,n;\n\tint i=0,j;\n\tstring s,u,v;\n\tdouble w,dis[40];\n\tint time=1;\n\twhile(scanf(\"%d\",&t)!=EOF)\n\t{\n\t\tif(t==0)break;\n\t\tint tt=t;\n\t\ti=0;\n\t\twhile(t--)\n\t\t{\n\t\t\ti++;\n\t\t\tcin >> s;\n\t\t\tname[s]=i;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\ti=1;\n\t\tint k=n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcin >> u >> w >> v ;\n\t\t\te[i].u=name[u];\n\t\t\te[i].v=name[v];\n\t\t\te[i].w=w;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tfor(i=1;i<=tt;i++)\n\t\tdis[i]=0;\n\t\t\n\t\tdis[1]=1;\n\t\t\n\t\tfor(i=1;i<=tt;i++)\n\t\t{\n\t\t\tfor(j=1;j<=k;j++)\n\t\t\t{\n\t\t\t\tif(dis[e[j].v]<dis[e[j].u]*e[j].w)\n\t\t\t\t\tdis[e[j].v]=dis[e[j].u]*e[j].w;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint flag=0;\n\t\tfor(j=1;j<=k;j++)\n\t\t\t{\n\t\t\t\tif(dis[e[j].v]<dis[e[j].u]*e[j].w)\n\t\t\t\t\tflag=1;\n\t\t\t}\n\t\t\t\n\t\tif(flag)printf(\"Case %d: Yes\\n\",time);\n\t\telse printf(\"Case %d: No\\n\",time);\n\t\ttime++;\n\t}\n} \n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["poj"]},{"title":"poj3660","url":"%2F2019%2F07%2F28%2Fpoj3660.html","content":"<p class=\"description\"></p>\npojj3660,floyd求有向图的传递闭包\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3660\n\n## 题意\n\nN头牛，给你M个两头牛的关系，即a可以打败b。\n\n问最多能确定几头牛的名次。\n\n即如果这头牛和其余的牛的关系是确定的，那么这个牛的排名就是确定的。\n\n## 细节\n\n传递闭包： 关系之间具有传递性（例如a> b, b> c, 那么a> c）\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999 \nint e[110][110];\nint main()\n{\n\tint n,m,a,b;\n\tscanf(\"%d%d\",&n,&m);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\te[i][j]=0;\n\t\t}\n\t\t\t\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te[a][b]=1;\n\t}\n\t\n\tint k;\n\tfor(k=1;k<=n;k++)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(e[i][k]&&e[k][j])\n\t\t\t\t\t\te[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\n\tint ans=0,flag;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tflag=1;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\telse if(e[i][j]==0&&e[j][i]==0)\n\t\t\t{\n\t\t\t\tflag=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==1)ans++;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["poj"]},{"title":"poj1502","url":"%2F2019%2F07%2F28%2Fpoj1502.html","content":"<p class=\"description\"></p>\npoj1502,单源最短路，坑爹题意，优雅使用sscanf\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1502\n\n## 题意\n\nN个点，之后给你半个邻接矩阵。由于自己到自己是0，所以也不给。\n\nx为无法到达。\n\n求最短路中的最大值。即dis[]中最大值。\n\n## 细节\n\ndijstra模板题。就是输入比较麻烦。\n\nsscanf(s,\"%d\",&e[i] [j]);\n\n这样输入就很简单了。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#define inf 99999999\nint e[110][110];\nint dis[110];\nint book[110];\nint main()\n{\n\tint n,i,j;\n\tscanf(\"%d\",&n);\n\t\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf;\n\t\t}\n\t\n\tchar s[100];\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<i;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%s\",s);\n\t\t\t\tif(s[0]=='x')continue;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsscanf(s,\"%d\",&e[i][j]);\n\t\t\t\t\te[j][i]=e[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\n\tfor(i=1;i<=n;i++)\n\t\tdis[i]=e[1][i];\n\t\n\t\n\tfor(i=1;i<=n;i++)\n\t\tbook[i]=0;\n\t\t\n\tbook[1]=1;\n\tdis[1]=0;\n\tint min,temp;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tmin=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dis[j]<min&&book[j]==0)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\t\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dis[temp]+e[temp][j]<dis[j])\n\t\t\t\tdis[j]=dis[temp]+e[temp][j];\n\t\t}\n\t}\n\t\n\tint max=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(max<dis[i])max=dis[i];\n\t}\n\tprintf(\"%d\\n\",max);\n} \n\n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["poj"]},{"title":"poj3259","url":"%2F2019%2F07%2F28%2Fpoj3259.html","content":"<p class=\"description\"></p>\npoj3259,求负环\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3259\n\n## 题意\n\n有N个点，M条路，W个虫洞。路是双向的，虫洞是单向的。\n\n每次穿越虫洞将会时间回溯虫洞的权值。\n\n问能否通过虫洞回到过去？\n\n## 细节\n\nbellman求负环板子题\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999\nint dis[510];\nint u[6000],v[6000],w[6000];\nint main()\n{\n\tint t,n,m,w1,j;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d%d\",&n,&m,&w1);\n\t\tint i,a,b,c,k=1;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tu[k]=a;v[k]=b;w[k++]=c;\n\t\t\tu[k]=b;v[k]=a;w[k++]=c;\n\t\t}\n\t\tfor(i=1;i<=w1;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tu[k]=a;v[k]=b;w[k++]=-c;\n\t\t}\n\t\t\n\t\tfor(i=1;i<=n;i++)\n\t\tdis[i]=inf;\n\t\t\n\t\tdis[1]=0;\n\t\t\n\t\tfor(j=1;j<=n-1;j++)\n\t\t{\n\t\t\tfor(i=1;i<k;i++)\n\t\t\t{\n\t\t\t\tif(dis[v[i]]>dis[u[i]]+w[i])\n\t\t\t\tdis[v[i]]=dis[u[i]]+w[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint flag=0;\n\t\tfor(i=1;i<k;i++)\n\t\t\t{\n\t\t\t\tif(dis[v[i]]>dis[u[i]]+w[i])\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t\t\n\t\tif(flag==0)printf(\"NO\\n\");\n\t\telse printf(\"YES\\n\");\n\t}\n} \n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["poj"]},{"title":"bellman","url":"%2F2019%2F07%2F26%2Fbellman.html","content":"\n## Bellman算法\n\nDijstra只能求没有负权边的图，因为当所有边权为正时，不会存在一个路程更短的没有拓展过的点，所以这个点的路程永远不会再改变，从而保证了dijstra的正确性。\n\n那么有没有一个算法可以求带有负权边的指定顶点到其余各个顶点的最短路径算法呢？\n\n那就到Bellman-Ford出场了。\n\n复杂度：O(NM)\n\n优化后：<=O(NM)\n\n<!-- more -->\n\n求1号顶点到其余所有顶点的最短路径。\n\n![1564125629485](bellman\\1564125629485.png)\n\n依旧用dis[]存储1号顶点到所有顶点的距离。\n\n![1564125848909](bellman\\1564125848909.png)\n\n接下来根据边给出的顺序，先处理第一条边2-3  2。\n\n通过2-3这条边进行松弛。即判断dis[3]是否大于dis[2]+2。此时dis[3]是∞，dis[2]也是∞，那么dis[3]<dis[2]+2。所以通过2-3-2不能是dis[3]的值变小，松弛失败。\n\n继续处理第二条边1-2  -3。\n\n发现dis[2]>dis[1]+(-3)，通过这条边可以使dis[2]的值从∞变成-3。因此松弛成功。\n\n以此类推，用同样的方法处理剩下的每一条边。对所有的边松弛一便后的结果如下：\n\n![1564126314876](bellman\\1564126314876.png)\n\n可以发现，1-2和1-5的距离变短了。我们再对所有边进行一轮松弛操作。\n\n![1564126386305](bellman\\1564126386305.png)\n\n如果说floyd是每次只能经过一个点中转来求到达其余个点的最短路径长度，那bellman就是每次只能经过一条边来求到达其余个点的最短路径长度。\n\n如果进行k轮的话，那么就是从1号顶点最多经过k条边到达其余各顶点的最短路径长度。\n\n因为再含有n个顶点的图中，任意两点间的最短路径最多包含n-1条边。\n\n所以最多只需要进行n-1轮松弛即可求出最短路径。\n\n另外，最短路径可能包含回路。\n\n回路分为正权回路和负权回路。\n\n如果包含正权回路，那么去掉正权回路之后一定能找到更短的路径。\n\n如果包含负权回路，那么肯定没有最短路径。因为每多走一次负权回路就可以得到更短的路径。\n\n\n\n继续\n\n![1564127047514](bellman\\1564127047514.png)\n\n完工！\n\n## 总结\n\n对所有的边进行n-1次松弛操作。\n\n## 代码\n\n```c++\nfor(k=1;k<=n;k++)\n\t\tfor(i=1;i<=m;i++)\n\t\t\tif(dis[v[i]]>dis[u[i]]+w[i])\n\t\t\t\tdis[v[i]]=dis[u[i]]+w[i];\n```\n\n## 优化\n\n待施工~~~\n\n<hr />","tags":["bellman"],"categories":["algorithm"]},{"title":"poj1860","url":"%2F2019%2F07%2F26%2Fpoj1860.html","content":"<p class=\"description\"></p>\npoj1860，求图正环\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1860\n\n## 题意\n\n有多种汇币，汇币之间可以交换，这需要手续费，当你用100A币交换B币时，A到B的汇率是29.75，手续费是0.39，那么你可以得到(100 - 0.39) * 29.75 = 2963.3975 B币。问s币的金额经过交换最终得到的s币金额数能否增加。\n\n输入：\n\n第一行，N种货币，M个交换所，你手上拥有的货币种类s，你手上拥有的money；\n\n接下来m行，a币，b币，a到b的汇率，a到b的手续费，b到a的汇率，b到a的手续费。\n\n## 细节\n\nbellman算法求正环，只需要按所有边都松弛一边之后然后进行判断能否再次松弛即可。能继续松弛即为有正环。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999\nint main()\n{\n\tint u[220],v[220];\n\tdouble dis[110],wl[220],ws[220];\n\tint n,m,s,i;\n\tdouble money;\n\tscanf(\"%d%d%d%lf\",&n,&m,&s,&money);\n\ti=0;\n\tint k=m;\n\twhile(m--)\n\t{\n\t\tint a,b;\n\t\tdouble al,as,bl,bs;\n\t\tscanf(\"%d%d%lf%lf%lf%lf\",&a,&b,&al,&as,&bl,&bs);\n\t\tu[i]=a;v[i]=b;wl[i]=al;ws[i]=as;\n\t\ti++;\n\t\tu[i]=b;v[i]=a;wl[i]=bl;ws[i]=bs;\n\t\ti++;\n\t}\n\tint t,j;\n\t\n\tfor(t=0;t<=n;t++)\n\t{\n\t\tdis[t]=0;\n\t}\n\tdis[s]=money;\n\t\n\tfor(t=1;t<=k;t++)\n\t{\n\t\tfor(j=0;j<i;j++)\n\t\t{\n\t\t\tif(dis[v[j]]<(dis[u[j]]-ws[j])*wl[j])\n\t\t\t\tdis[v[j]]=(dis[u[j]]-ws[j])*wl[j];\n\t\t}\n\t}\n\t\n\tint flag=0;\n\tfor(j=0;j<i;j++)\n\t\t{\n\t\t\tif(dis[v[j]]<(dis[u[j]]-ws[j])*wl[j])\n\t\t\t{\n\t\t\t\tdis[v[j]]=(dis[u[j]]-ws[j])*wl[j];\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t\n\tif(flag==1)printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n} \n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["poj"]},{"title":"floyd","url":"%2F2019%2F07%2F25%2Ffloyd.html","content":"<p class=\"description\"></p>\n## Floyed算法\n\n复杂度：O（n^3）\n\npoj又又又又炸了。写一下Floyd吧。核心代码五行，很简单。\n\n求一张图内任意两点间的距离。\n\n![=w=](http://pv35325dx.bkt.clouddn.com/guahua.gif)\n\n<!-- more -->\n\n例如：求任意两个点的最短路程。\n\n![1564051171338](floyd\\1564051171338.png)\n\n用矩阵存储图。\n\n![1564051237886](floyd\\1564051237886.png)\n\n首先我们知道两个点之间的距离了，接下来可以思考，有没有办法通过第三个点来进行中转来缩短路程呢？\n\n因此我们可以假设现在只允许通过1号点进行中转，来进行尝试缩短路程。\n\n只需要判断e[i] [1]+e[1] [j]是否比e[i] [j]小即可。\n\n代码如下：\n\n```c++\nfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[i][j]>e[i][1]+e[1][j])\n\t\t\t\te[i][j]=e[i][1]+e[1][j];\n\t\t}\n\t}\n```\n\n在只允许通过1号顶点的情况下，任意两点间的最短路径更新为：\n\n![1564052208614](floyd\\1564052208614.png)\n\n以此类推，然后考虑只允许通过2号点进行中转。\n\n```c++\nfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(e[i][j]>e[i][2]+e[2][j])\n\t\t\t\te[i][j]=e[i][2]+e[2][j];\n\t\t}\n\t}\n```\n\n几乎一毛一样，1变成2。\n\n更新：\n\n![1564052291135](floyd\\1564052291135.png)\n\n通过3号点中转更新：\n\n![1564052336765](floyd\\1564052336765.png)\n\n通过4号点中转更新：\n\n![1564052379218](floyd\\1564052379218.png)\n\n更新完毕。上图即为任意两点间最终的最短路程。\n\n## 总结\n\n简单来说就是遍历通过1-n个点的中转来缩短最短路程。\n\n## 代码\n\n```c++\nfor(k=1;k<=n;k++)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(e[i][j]>e[i][k]+e[k][j])\n\t\t\t\t\t\te[i][j]=e[i][k]+e[k][j];\n\t\t\t\t}\n\t\t}\n\t}\n```\n\n\n\n<hr />\n","tags":["floyd"],"categories":["algorithm"]},{"title":"poj3268","url":"%2F2019%2F07%2F25%2Fpoj3268.html","content":"<p class=\"description\"></p>\npoj3268,最短路变形，有向图，求来回距离\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=3268\n\n## 题意\n\n给出n个点和m条边，接着是m条边，代表从牛a到牛b需要花费c时间，现在所有牛要到牛x那里去参加聚会，并且所有牛参加聚会后还要回来，给你牛x，除了牛x之外的牛，他们都有一个参加聚会并且回来的最短时间，从这些最短时间里找出一个最大值输出。\n\n## 细节\n\n首先可以想到，所有牛到X的最短距离，那么将X作为起点就可以通过dijstra知道X到其他点的距离。即返程的距离。\n\n只需要转置矩阵一下，就可以求出其他点到X的距离了。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define inf 99999999\nint e[1010][1010];\nint dis[1010];\nint book[1010];\nint sum[1010];\nint n,m,x;\nvoid dijstra()\n{\n\tint i,j;\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[x]=1;\n\tfor(i=1;i<=n;i++)dis[i]=e[x][i];\n\tdis[x]=0;\n\t\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf,temp,v;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0&&dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsum[i]=sum[i]+dis[i];\n\t}\n}\n\nint main()\n{\n\tint a,b,c,i,j;\n\tscanf(\"%d%d%d\",&n,&m,&x);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\te[i][j]=inf;\n\tfor(i=1;i<=n;i++)\n\t\tsum[i]=0;\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t}\n\tdijstra();\n\tint temp;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i;j<=n;j++)\n\t\t{\n\t\t\ttemp=e[i][j];\n\t\t\te[i][j]=e[j][i];\n\t\t\te[j][i]=temp;\n\t\t}\n\tdijstra();\n\tint max=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(i==x)continue;\n\t\telse if(sum[i]>max)max=sum[i];\n\t}\n\tprintf(\"%d\",max);\n} #include <stdio.h>\n#define inf 99999999\nint e[1010][1010];\nint dis[1010];\nint book[1010];\nint sum[1010];\nint n,m,x;\nvoid dijstra()\n{\n\tint i,j;\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[x]=1;\n\tfor(i=1;i<=n;i++)dis[i]=e[x][i];\n\tdis[x]=0;\n\t\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf,temp,v;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0&&dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsum[i]=sum[i]+dis[i];\n\t}\n}\n\nint main()\n{\n\tint a,b,c,i,j;\n\tscanf(\"%d%d%d\",&n,&m,&x);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\te[i][j]=inf;\n\tfor(i=1;i<=n;i++)\n\t\tsum[i]=0;\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t}\n\tdijstra();\n\tint temp;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i;j<=n;j++)\n\t\t{\n\t\t\ttemp=e[i][j];\n\t\t\te[i][j]=e[j][i];\n\t\t\te[j][i]=temp;\n\t\t}\n\tdijstra();\n\tint max=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(i==x)continue;\n\t\telse if(sum[i]>max)max=sum[i];\n\t}\n\tprintf(\"%d\",max);\n} \n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["poj"]},{"title":"poj1797","url":"%2F2019%2F07%2F24%2Fpoj1797.html","content":"<p class=\"description\"></p>\npoj1797,最短路变形\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=1797\n\n## 题意\n\n青蛙那题的变形版本。\n\n输入T组，每组x个点，y条边。\n\n接下来y行分别是a到b的边的权重。\n\n求1到x的所有边中最大的最小边权重。（2333读懂题目就会了）\n\n形象一点理解就是权重为道路的载重量，这题求的就是一辆卡车从1开到x，卡车最多可以载重多少。当然取决于一条路上载重量最低的那条路。输出那条路的载重量。\n\n## 细节\n\n思路：反过来查找dis[]中最大的，那么就能确定1到那个点的最大权重了，然后进行。。松弛？\n\n## 代码\n\nDijstra变形：一开始读错题了导致代码写丑了。\n\n```c++\n#include <stdio.h>\n#include <math.h>\n#define inf 99999999\ndouble funmin(int a,int b)\n{\n\tif(a>b)return b;\n\telse return a;\n}\n\ndouble funmax(int a,int b)\n{\n\tif(a>b)return a;\n\telse return b;\n}\n\nint e[1010][1010],book[1010],dis[1010];\n\nint main()\n{\n\tint t,count=1;\n\tint i,j,x,y,a,b,c;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\tscanf(\"%d%d\",&x,&y);\n\t\n\tfor(i=1;i<=x;i++)\n\t\tfor(j=1;j<=x;j++)\n\t\t\t{\n\t\t\t\tif(i==j)e[i][j]=0;\n\t\t\t\te[i][j]=-inf;\n\t\t\t}\n\t\n\twhile(y--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t\te[b][a]=c;\n\t}\n\t\n\t\n\tfor(i=1;i<=x;i++)\n\t\t{\n\t\t\tdis[i]=e[1][i];\n\t\t\tbook[i]=0;\n\t\t}\n\tdis[1]=0;book[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<x;i++)\n\t{\n\t\tint max=-inf;\n\t\tfor(j=2;j<=x;j++)\n\t\t{\n\t\t\tif(dis[j]>max&&book[j]==0)\n\t\t\t{\n\t\t\t\tmax=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=2;v<=x;v++)\n\t\t{\n\t\t\tif(e[temp][v]>0&&book[v]==0)\n\t\t\t{\n\t\t\t\tdis[v]=funmax(dis[v],funmin(e[temp][v],dis[temp]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Scenario #%d:\\n%d\\n\\n\",count++,dis[x]);\n\t} \n}\n```\n\n\n\n<hr />","tags":["kuangbin"],"categories":["poj"]},{"title":"poj2253","url":"%2F2019%2F07%2F24%2Fpoj2253.html","content":"<p class=\"description\"></p>\npoj2253,最短路变形\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2253\n\n## 题意\n\n第一行T，告诉你有T个点，下面T行是它们的坐标\n\n有两只青蛙，T的第一个是a青蛙坐标，第二个是b青蛙坐标\n\n求a青蛙到b青蛙那里的所有路中最短的 路径中最大的边\n\n\n\n![2253](poj2253\\2253.png)\n\n例：如图所示，1到3距离为1，2到3距离为1，1到2距离为2，那么根据题意，1-3-2最长的边是1，1-2最长的是2，所以输出1。\n\n## 细节\n\n输出有俩\\n\n\n## 代码\n\nDijstra改一改：\n\n```c++\n#include <stdio.h>\n#include <math.h>\n#define inf 99999999\ndouble funmin(double a,double b)\n{\n\tif(a>b)return b;\n\telse return a;\n}\n\ndouble funmax(double a,double b)\n{\n\tif(a>b)return a;\n\telse return b;\n}\n\nint main()\n{\n\tint t,count=1;\n\tint x[210],y[210],book[210];\n\tdouble e[210][210],dis[210];\n\tint i,j;\n\tscanf(\"%d\",&t);\n\twhile(t!=0)\n\t{\n\tfor(i=1;i<=t;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\n\tfor(i=1;i<=t;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\te[i][j]=inf;\n\t\t\t\n\tfor(i=1;i<t;i++)\n\t\tfor(j=i+1;j<=t;j++)\n\t\t{\n\t\t\te[i][j]=e[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t\n\tfor(i=1;i<=t;i++)\n\t\t{\n\t\t\tdis[i]=e[1][i];\n\t\t\tbook[i]=0;\n\t\t}\n\tdis[1]=0;book[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<t;i++)\n\t{\n\t\tdouble min=inf;\n\t\tfor(j=1;j<=t;j++)\n\t\t{\n\t\t\tif(dis[j]<min&&book[j]==0)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=1;v<=t;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tdis[v]=funmin(dis[v],funmax(e[temp][v],dis[temp]));//比较经过temp点松弛后的路线中最长跳跃距离和dis[v]的距离\n\t\t\t\t//if(e[temp][v]+dis[temp]<dis[v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Scenario #%d\\nFrog Distance = %.3lf\\n\\n\",count++,dis[2]);\n\tscanf(\"%d\",&t);\n\t} \n}\n```\n\n\n\n<hr />","tags":["kuangbin"],"categories":["poj"]},{"title":"poj2387","url":"%2F2019%2F07%2F24%2Fpoj2387.html","content":"<p class=\"description\"></p>\n板子题，最短路，poj2387\n\n<!-- more -->\n\n## 题目链接\n\nhttp://poj.org/problem?id=2387\n\n## 题意\n\n第一行T组数据，N个顶点\n\n之后T行告诉你a到b的距离c\n\n求到n的最短路径\n\n## 细节\n\n有重边 \\ \\两点之间的路未必只有一条\n\n## 代码\n\nDijstra：\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#define inf 99999999\nint e[1010][1010],dis[1010],book[1010];\n\nint main()\n{\n\tint n,t,a,b,c,i,j;\n\tscanf(\"%d%d\",&t,&n);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf; \n\t\t}\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tif(e[a][b]>c)\n\t\t{\n\t\t\te[a][b]=c;\n\t\t\te[b][a]=c;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tdis[i]=e[1][i];\n\t\tbook[i]=0;\n\t}\n\tdis[1]=0;\n\tbook[1]=1;\n\t\n\tint temp;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tint min=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dis[j]<min&&book[j]==0)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;\n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;\n\t\tint v;\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)\n\t\t\t{\n\t\t\t\tif(dis[v]>dis[temp]+e[temp][v])dis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",dis[n]);\n} \n```\n\n\n\n<hr />\n","tags":["kuangbin"],"categories":["poj"]},{"title":"dijstra","url":"%2F2019%2F07%2F23%2Fdijstra.html","content":"## Dijstra算法\n\n博客初建，先记录一个基础的单源最短路算法，Dijstra。\n\n复杂度：O（N²）\n\n![lalala](http://pv35325dx.bkt.clouddn.com/lalala.gif)\n\n<!-- more -->\n\n例如求1到各个顶点的最短路径。\n\n![1](http://pv35325dx.bkt.clouddn.com/1563866213798.png)\n\n首先考虑图的存储问题，使用二维数组e来进行存储各个点之间的边的长度。\n\n![2](http://pv35325dx.bkt.clouddn.com/1563862729194.png)\n\n然后创建一个一维数组dis来存储1号顶点到其余各个顶点的初始路程。\n\n![3](http://pv35325dx.bkt.clouddn.com/1563862773804.png)\n\n此时dis数组中的值称为最短路程的“估计值”。\n\n既然是找最短路，那么根据dis可以寻找到离点1最近的顶点是2。\n\n那么dis[2]的值就变成了“确定值”。即点1到点2的最短距离就是dis[2]的值。\n\n既然选择了2号顶点，那就继续看2号顶点的几条出边。有2-3和2-4这两条，先讨论2-3能否让1号顶点到3号顶点的路程变短，即比较dis[3]和dis[2]+e[2] [3]的大小。\n\ndis[3]=12,dis[2]+e[2] [3]=10,dis[3]>dis[2]+e[2] [3],所以可以通过1-2-3这样缩短1-3的距离，因此dis[3]更新为10。这个过程专业点称为“松弛”。\n\n同理，dis[2]+e[2] [4]<dis[4],dis[4]的值可以松弛为4。\n\n这样2号顶点的所有出边就都松弛完了。松弛之后的dis数组为：\n\n![5](http://pv35325dx.bkt.clouddn.com/1563863527940.png)\n\n接下来以此类推，在剩下的3，4，5，6号顶点中选出离1最近的顶点。\n\n通过dis数组可以发现最近的顶点是4。\n\ndis[4]的值变成“确定值”。\n\n然后继续对4号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![6](http://pv35325dx.bkt.clouddn.com/1563863664903.png)\n\n以此类推，在剩下的3，5，6号顶点中，选出离1号最近的顶点。这次选择3号顶点。\n\ndis[3]的值变成“确定值”。\n\n对3号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![7](http://pv35325dx.bkt.clouddn.com/1563863742582.png)\n\n在剩下的5，6号顶点中，选出离1号最近的顶点。选择5号。\n\ndis[5]的值变成“确定值”。\n\n对5号顶点的所有出边进行松弛。松弛之后的dis数组为：\n\n![8](http://pv35325dx.bkt.clouddn.com/1563863819140.png)\n\n最后选择6号。\n\ndis[6]的值变成“确定值”。\n\n最后对6号顶点的所有出边进行松弛。因为此例6号没有出边，因此不用处理。\n\n至此，dis数组中所有的值都已经从“估计值”变成了“确定值”。\n\n最终dis数组如下，这便是1号顶点到各个顶点的最短路径。\n\n![10](http://pv35325dx.bkt.clouddn.com/1563863951516.png)\n\n## 总结\n\n算法基本思想：每次都找离源点最近的顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。\n\n## 代码\n\n```c++\n#include <stdio.h>\n#define MAXN 101 //最大顶点数 \nint main()\n{\n\tint e[MAXN][MAXN],dis[MAXN];\n\tint temp,v,i,j,a,b,c,n,m,min;\n\tint inf=99999999;//存储一个认为正无穷的值\n\tscanf(\"%d%d\",&n,&m);//n个顶点，m条边\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(i==j)e[i][j]=0;\n\t\t\telse e[i][j]=inf;\n\t//初始化 \n\t \n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\te[a][b]=c;\n\t} \n\t//读入边\n\t\n\tfor(i=1;i<=n;i++)\n\t\tdis[i]=e[1][i];\n\t//初始化dis数组\n\t\n\tint book[MAXN];//在代码中，需要用一个book数组进行标记估计值还是确定值\n\tfor(i=1;i<=n;i++)book[i]=0;\n\tbook[1]=1;\n\t\n\t//Dijstra算法核心语句\n\tfor(i=1;i<=n-1;i++)\n\t{\n\t\tmin=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(book[j]==0 && dis[j]<min)\n\t\t\t{\n\t\t\t\tmin=dis[j];\n\t\t\t\ttemp=j;//记录最小的顶点号 \n\t\t\t}\n\t\t}\n\t\tbook[temp]=1;//dis[temp]变成确定值\n\t\tfor(v=1;v<=n;v++)\n\t\t{\n\t\t\tif(e[temp][v]<inf)//进行松弛 \n\t\t\t{\n\t\t\t\tif(dis[temp]+e[temp][v]<dis[v])\n\t\t\t\t\tdis[v]=dis[temp]+e[temp][v];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(i=1;i<=n;i++)\n\t\tprintf(\"%d \",dis[i]);//输出结果 \n\n} \n```\n\n","tags":["dijstra"],"categories":["algorithm"]},{"title":"my first blog","url":"%2F2019%2F07%2F22%2Fmy-first.html","content":"<p class=\"description\"></p>\n![first](http://pv35325dx.bkt.clouddn.com/first.jpg)\n\n<!-- more -->\n\n经过两天的搭建，终于好像搭好了！安装上了node,git,hexo.然后扔GitHub然后买了个域名。编辑md软件用的Typora，蛮好用。\n\n域名yuanfang.tech，既有远方，又有远芳的意思，还可以记成元芳，给别人记应该很好记23333（没办法lmf太贵了）。本来还想起个英文的，但算了，中文更写意。tech很有dalao的感觉。\n\n计划以后写题啊算法啥的都往上放。\n\n就先这样，功能慢慢加，日后完善。\n\n<hr />\n","tags":["test"],"categories":["somethings"]}]